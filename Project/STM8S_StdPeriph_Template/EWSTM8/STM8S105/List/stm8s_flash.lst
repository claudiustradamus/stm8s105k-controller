###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             14/Aug/2013  09:25:08 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Users\Administrator\Desktop\stm8s105k-controller\Libr #
#                    aries\STM8S_StdPeriph_Driver\src\stm8s_flash.c           #
#    Command line =  C:\Users\Administrator\Desktop\stm8s105k-controller\Libr #
#                    aries\STM8S_StdPeriph_Driver\src\stm8s_flash.c -e -Ohz   #
#                    --debug --code_model medium --data_model medium -o       #
#                    C:\Users\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Obj\        #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0\stm8\LIB\dlstm8mmf.h" -D  #
#                    STM8S105 -lC C:\Users\Administrator\Desktop\stm8s105k-co #
#                    ntroller\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S10 #
#                    5\List\ -lA C:\Users\Administrator\Desktop\stm8s105k-con #
#                    troller\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S105 #
#                    \List\ -I C:\Users\Administrator\Desktop\stm8s105k-contr #
#                    oller\Project\STM8S_StdPeriph_Template\EWSTM8\..\ -I     #
#                    C:\Users\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Libraries\S #
#                    TM8S_StdPeriph_Driver\inc\ --vregs 16                    #
#    List file    =  C:\Users\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\List\stm8s_ #
#                    flash.lst                                                #
#    Object file  =  C:\Users\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Obj\stm8s_f #
#                    lash.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\stm8s105k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_flash.c
      4            * @author  MCD Application Team
      5          	* @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the FLASH peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_flash.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /**
     29          @code
     30           This driver provides functions to configure and program the Flash memory of all
     31           STM8S devices.
     32          
     33           It includes as well functions that can be either executed from RAM or not, and
     34           other functions that must be executed from RAM otherwise useless.
     35          
     36           The table below lists the functions that can be executed from RAM.
     37          
     38           +--------------------------------------------------------------------------------|
     39           |   Functions prototypes      |    RAM execution            |     Comments       |
     40           ---------------------------------------------------------------------------------|
     41           |                             | Mandatory in case of block  | Can be executed    |
     42           | FLASH_WaitForLastOperation  | Operation:                  | from Flash in case |
     43           |                             | - Block programming         | of byte and word   |
     44           |                             | - Block erase               | Operations         |
     45           |--------------------------------------------------------------------------------|
     46           | FLASH_ProgramBlock          |       Exclusively           | useless from Flash |
     47           |--------------------------------------------------------------------------------|
     48           | FLASH_EraseBlock            |       Exclusively           | useless from Flash |
     49           |--------------------------------------------------------------------------------|
     50          
     51           To be able to execute functions from RAM several steps have to be followed.
     52           These steps may differ from one toolchain to another.
     53           A detailed description is available below within this driver.
     54           You can also refer to the FLASH examples provided within the
     55           STM8S_StdPeriph_Lib package.
     56          
     57          @endcode
     58          */
     59          
     60          
     61          /* Private typedef -----------------------------------------------------------*/
     62          /* Private define ------------------------------------------------------------*/
     63          #define FLASH_CLEAR_BYTE ((uint8_t)0x00)
     64          #define FLASH_SET_BYTE  ((uint8_t)0xFF)
     65          #define OPERATION_TIMEOUT  ((uint32_t)0xFFFFF)
     66          /* Private macro -------------------------------------------------------------*/
     67          /* Private variables ---------------------------------------------------------*/
     68          /* Private function prototypes -----------------------------------------------*/
     69          /* Private Constants ---------------------------------------------------------*/
     70          
     71          /** @addtogroup FLASH_Public_functions
     72            * @{
     73            */
     74          
     75          /**
     76            * @brief   Unlocks the program or data EEPROM memory
     77            * @param  FLASH_MemType : Memory type to unlock
     78            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
     79            * @retval None
     80            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine0:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 AE0000                LDW       X, #`?<Constant "C:\\\\Users\\\\Administrato...">`
   \   000008 AC000000              JPF       assert_failed

   \                                 In section .far_func.text, align 1
     81          void FLASH_Unlock(FLASH_MemType_TypeDef FLASH_MemType)
     82          {
     83              /* Check parameter */
     84              assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \                     FLASH_Unlock:
   \   000000 A1FD                  CP        A, #0xfd
   \   000002 2714                  JREQ      L:??FLASH_Unlock_0
   \   000004 A1F7                  CP        A, #0xf7
   \   000006 2707                  JREQ      L:??CrossCallReturnLabel_0
   \   000008 AE0054                LDW       X, #0x54
   \   00000B 8D000000              CALLF     ?Subroutine0
     85          
     86              /* Unlock program memory */
     87              if (FLASH_MemType == FLASH_MEMTYPE_PROG)
     88              {
     89                  FLASH->PUKR = FLASH_RASS_KEY1;
     90                  FLASH->PUKR = FLASH_RASS_KEY2;
     91              }
     92              /* Unlock data memory */
     93              else
     94              {
     95                  FLASH->DUKR = FLASH_RASS_KEY2; /* Warning: keys are reversed on data memory !!! */
   \                     ??CrossCallReturnLabel_0:
   \   00000F 35AE5064              MOV       L:0x5064, #0xae
     96                  FLASH->DUKR = FLASH_RASS_KEY1;
   \   000013 35565064              MOV       L:0x5064, #0x56
     97              }
     98          }
   \   000017 87                    RETF
   \                     ??FLASH_Unlock_0:
   \   000018 35565062              MOV       L:0x5062, #0x56
   \   00001C 35AE5062              MOV       L:0x5062, #0xae
   \   000020 87                    RETF
     99          
    100          /**
    101            * @brief   Locks the program or data EEPROM memory
    102            * @param  FLASH_MemType : Memory type
    103            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
    104            * @retval None
    105            */

   \                                 In section .far_func.text, align 1
    106          void FLASH_Lock(FLASH_MemType_TypeDef FLASH_MemType)
    107          {
   \                     FLASH_Lock:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    108              /* Check parameter */
    109              assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000005 A1FD                  CP        A, #0xfd
   \   000007 270B                  JREQ      L:??CrossCallReturnLabel_1
   \   000009 A1F7                  CP        A, #0xf7
   \   00000B 2707                  JREQ      L:??CrossCallReturnLabel_1
   \   00000D AE006D                LDW       X, #0x6d
   \   000010 8D000000              CALLF     ?Subroutine0
    110          
    111            /* Lock memory */
    112            FLASH->IAPSR &= (uint8_t)FLASH_MemType;
   \                     ??CrossCallReturnLabel_1:
   \   000014 B600                  LD        A, S:?b8
   \   000016 C4505F                AND       A, L:0x505f
   \   000019 C7505F                LD        L:0x505f, A
    113          }
   \   00001C 320000                POP       S:?b8
   \   00001F 87                    RETF
    114          
    115          /**
    116            * @brief   Deinitializes the FLASH registers to their default reset values.
    117            * @param  None
    118            * @retval None
    119            */

   \                                 In section .far_func.text, align 1
    120          void FLASH_DeInit(void)
    121          {
    122              FLASH->CR1 = FLASH_CR1_RESET_VALUE;
   \                     FLASH_DeInit:
   \   000000 725F505A              CLR       L:0x505a
    123              FLASH->CR2 = FLASH_CR2_RESET_VALUE;
   \   000004 725F505B              CLR       L:0x505b
    124              FLASH->NCR2 = FLASH_NCR2_RESET_VALUE;
   \   000008 35FF505C              MOV       L:0x505c, #0xff
    125              FLASH->IAPSR &= (uint8_t)(~FLASH_IAPSR_DUL);
   \   00000C 7217505F              BRES      L:0x505f, #0x3
    126              FLASH->IAPSR &= (uint8_t)(~FLASH_IAPSR_PUL);
   \   000010 7213505F              BRES      L:0x505f, #0x1
    127              (void) FLASH->IAPSR; /* Reading of this register causes the clearing of status flags */
   \   000014 C6505F                LD        A, L:0x505f
    128          }
   \   000017 87                    RETF
    129          
    130          /**
    131            * @brief   Enables or Disables the Flash interrupt mode
    132            * @param  NewState : The new state of the flash interrupt mode
    133            *         This parameter can be a value of @ref FunctionalState enumeration.
    134            * @retval None
    135            */

   \                                 In section .far_func.text, align 1
    136          void FLASH_ITConfig(FunctionalState NewState)
    137          {
    138                /* Check parameter */
    139            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     FLASH_ITConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??FLASH_ITConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_2
   \   000007 AE008B                LDW       X, #0x8b
   \   00000A 8D000000              CALLF     ?Subroutine0
    140            
    141              if (NewState != DISABLE)
    142              {
    143                  FLASH->CR1 |= FLASH_CR1_IE; /* Enables the interrupt sources */
   \                     ??CrossCallReturnLabel_2:
   \   00000E 7212505A              BSET      L:0x505a, #0x1
   \   000012 87                    RETF
    144              }
    145              else
    146              {
    147                  FLASH->CR1 &= (uint8_t)(~FLASH_CR1_IE); /* Disables the interrupt sources */
   \                     ??FLASH_ITConfig_0:
   \   000013 7213505A              BRES      L:0x505a, #0x1
    148              }
    149          }
   \   000017 87                    RETF
    150          
    151          /**
    152            * @brief   Erases one byte in the program or data EEPROM memory
    153            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    154            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    155            * @param  Address : Address of the byte to erase
    156            * @retval None
    157            */

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000 8D000000              CALLF     L:?mov_l2_l0
   \   000004                       REQUIRE ??Subroutine5_0
   \   000004                       ;               // Fall through to label ??Subroutine5_0

   \                                 In section .far_func.text, align 1
   \                     ??Subroutine5_0:
   \   000000 5F                    CLRW      X
   \   000001 5A                    DECW      X
   \   000002 BF00                  LDW       S:?w0, X
   \   000004 54                    SRLW      X
   \   000005 5C                    INCW      X
   \   000006 BF00                  LDW       S:?w1, X
   \   000008 8D000000              CALLF     L:?mov_l1_l2
   \   00000C 8D000000              CALLF     L:?add32_l0_l0_l1
   \   000010 BE00                  LDW       X, S:?w0
   \   000012 A30000                CPW       X, #0x0
   \   000015 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine2:
   \   000000 AEC000                LDW       X, #0xc000
   \   000003 BF00                  LDW       S:?w1, X
   \   000005 5F                    CLRW      X
   \   000006 5A                    DECW      X
   \   000007 BF00                  LDW       S:?w0, X
   \   000009 8D000000              CALLF     L:?add32_l0_l0_l1
   \   00000D BE00                  LDW       X, S:?w0
   \   00000F A30000                CPW       X, #0x0
   \   000012 87                    RETF

   \                                 In section .far_func.text, align 1
    158          void FLASH_EraseByte(uint32_t Address)
    159          {
   \                     FLASH_EraseByte:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     ?Subroutine1
    160              /* Check parameter */
    161              assert_param(IS_FLASH_ADDRESS_OK(Address));
   \                     ??CrossCallReturnLabel_30:
   \   000008 2605                  JRNE      L:??FLASH_EraseByte_0
   \   00000A BE00                  LDW       X, S:?w1
   \   00000C A38000                CPW       X, #0x8000
   \                     ??FLASH_EraseByte_0:
   \   00000F 2514                  JRC       L:??CrossCallReturnLabel_3
   \   000011 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_23:
   \   000015 2605                  JRNE      L:??FLASH_EraseByte_1
   \   000017 BE00                  LDW       X, S:?w1
   \   000019 A30400                CPW       X, #0x400
   \                     ??FLASH_EraseByte_1:
   \   00001C 2507                  JRC       L:??CrossCallReturnLabel_3
   \   00001E AE00A1                LDW       X, #0xa1
   \   000021 8D000000              CALLF     ?Subroutine0
    162              
    163              /* Erase byte */
    164             *(PointerAttr uint8_t*) (uint16_t)Address = FLASH_CLEAR_BYTE; 
   \                     ??CrossCallReturnLabel_3:
   \   000025 4F                    CLR       A
   \   000026 92C700                LD        [S:?w5.w], A
    165          
    166          }
   \   000029 AC000000              JPF       L:?epilogue_l2
    167          
    168          /**
    169            * @brief   Programs one byte in program or data EEPROM memory
    170            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    171            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    172            * @param  Address : Address where the byte will be programmed
    173            * @param  Data : Value to be programmed
    174            * @retval None
    175            */

   \                                 In section .far_func.text, align 1
    176          void FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    177          {
   \                     FLASH_ProgramByte:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 3B0000                PUSH      S:?b12
   \   000007 8D000000              CALLF     L:?mov_l2_l0
   \   00000B B700                  LD        S:?b12, A
    178              /* Check parameters */
    179              assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   00000D 8D000000              CALLF     ??Subroutine5_0
   \                     ??CrossCallReturnLabel_31:
   \   000011 2605                  JRNE      L:??FLASH_ProgramByte_0
   \   000013 BE00                  LDW       X, S:?w1
   \   000015 A38000                CPW       X, #0x8000
   \                     ??FLASH_ProgramByte_0:
   \   000018 2514                  JRC       L:??CrossCallReturnLabel_4
   \   00001A 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_22:
   \   00001E 2605                  JRNE      L:??FLASH_ProgramByte_1
   \   000020 BE00                  LDW       X, S:?w1
   \   000022 A30400                CPW       X, #0x400
   \                     ??FLASH_ProgramByte_1:
   \   000025 2507                  JRC       L:??CrossCallReturnLabel_4
   \   000027 AE00B3                LDW       X, #0xb3
   \   00002A 8D000000              CALLF     ?Subroutine0
    180              *(PointerAttr uint8_t*) (uint16_t)Address = Data;
   \                     ??CrossCallReturnLabel_4:
   \   00002E B600                  LD        A, S:?b12
   \   000030 92C700                LD        [S:?w5.w], A
    181          }
   \   000033 320000                POP       S:?b12
   \   000036 AC000000              JPF       L:?epilogue_l2
    182          
    183          /**
    184            * @brief   Reads any byte from flash memory
    185            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    186            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    187            * @param  Address : Address to read
    188            * @retval Value of the byte
    189            */

   \                                 In section .far_func.text, align 1
    190          uint8_t FLASH_ReadByte(uint32_t Address)
    191          {
   \                     FLASH_ReadByte:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     ?Subroutine1
    192              /* Check parameter */
    193              assert_param(IS_FLASH_ADDRESS_OK(Address));
   \                     ??CrossCallReturnLabel_29:
   \   000008 2605                  JRNE      L:??FLASH_ReadByte_0
   \   00000A BE00                  LDW       X, S:?w1
   \   00000C A38000                CPW       X, #0x8000
   \                     ??FLASH_ReadByte_0:
   \   00000F 2514                  JRC       L:??CrossCallReturnLabel_5
   \   000011 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_21:
   \   000015 2605                  JRNE      L:??FLASH_ReadByte_1
   \   000017 BE00                  LDW       X, S:?w1
   \   000019 A30400                CPW       X, #0x400
   \                     ??FLASH_ReadByte_1:
   \   00001C 2507                  JRC       L:??CrossCallReturnLabel_5
   \   00001E AE00C1                LDW       X, #0xc1
   \   000021 8D000000              CALLF     ?Subroutine0
    194              
    195              /* Read byte */
    196              return(*(PointerAttr uint8_t *) (uint16_t)Address); 
   \                     ??CrossCallReturnLabel_5:
   \   000025 BE00                  LDW       X, S:?w5
   \   000027 F6                    LD        A, (X)
   \   000028 AC000000              JPF       L:?epilogue_l2
    197          
    198          }
    199          /**
    200            * @brief   Programs one word (4 bytes) in program or data EEPROM memory
    201            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    202            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    203            * @param  Address : The address where the data will be programmed
    204            * @param  Data : Value to be programmed
    205            * @retval None
    206            */

   \                                 In section .far_func.text, align 1
    207          void FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    208          {
   \                     FLASH_ProgramWord:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l1
   \   000008 8D000000              CALLF     ?Subroutine1
    209              /* Check parameters */
    210              assert_param(IS_FLASH_ADDRESS_OK(Address));
   \                     ??CrossCallReturnLabel_28:
   \   00000C 2605                  JRNE      L:??FLASH_ProgramWord_0
   \   00000E BE00                  LDW       X, S:?w1
   \   000010 A38000                CPW       X, #0x8000
   \                     ??FLASH_ProgramWord_0:
   \   000013 2514                  JRC       L:??CrossCallReturnLabel_6
   \   000015 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_20:
   \   000019 2605                  JRNE      L:??FLASH_ProgramWord_1
   \   00001B BE00                  LDW       X, S:?w1
   \   00001D A30400                CPW       X, #0x400
   \                     ??FLASH_ProgramWord_1:
   \   000020 2507                  JRC       L:??CrossCallReturnLabel_6
   \   000022 AE00D2                LDW       X, #0xd2
   \   000025 8D000000              CALLF     ?Subroutine0
    211          
    212              /* Enable Word Write Once */
    213              FLASH->CR2 |= FLASH_CR2_WPRG;
   \                     ??CrossCallReturnLabel_6:
   \   000029 721C505B              BSET      L:0x505b, #0x6
    214              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NWPRG);
   \   00002D 721D505C              BRES      L:0x505c, #0x6
    215          
    216              /* Write one byte - from lowest address*/
    217              *((PointerAttr uint8_t*)(uint16_t)Address)       = *((uint8_t*)(&Data));
   \   000031 BE00                  LDW       X, S:?w5
   \   000033 7B01                  LD        A, (0x1,SP)
   \   000035 F7                    LD        (X), A
    218              /* Write one byte*/
    219              *(((PointerAttr uint8_t*)(uint16_t)Address) + 1) = *((uint8_t*)(&Data)+1); 
   \   000036 7B02                  LD        A, (0x2,SP)
   \   000038 9093                  LDW       Y, X
   \   00003A 905C                  INCW      Y
   \   00003C 90F7                  LD        (Y), A
    220              /* Write one byte*/    
    221              *(((PointerAttr uint8_t*)(uint16_t)Address) + 2) = *((uint8_t*)(&Data)+2); 
   \   00003E 7B03                  LD        A, (0x3,SP)
   \   000040 9093                  LDW       Y, X
   \   000042 72A90002              ADDW      Y, #0x2
   \   000046 90F7                  LD        (Y), A
    222              /* Write one byte - from higher address*/
    223              *(((PointerAttr uint8_t*)(uint16_t)Address) + 3) = *((uint8_t*)(&Data)+3); 
   \   000048 7B04                  LD        A, (0x4,SP)
   \   00004A 1C0003                ADDW      X, #0x3
   \   00004D F7                    LD        (X), A
    224          }
   \   00004E 5B04                  ADD       SP, #0x4
   \   000050 AC000000              JPF       L:?epilogue_l2
    225          
    226          /**
    227            * @brief   Programs option byte
    228            * @param  Address : option byte address to program
    229            * @param  Data : Value to write
    230            * @retval None
    231            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine3:
   \   000000 A6FD                  LD        A, #0xfd
   \   000002 8D000000              CALLF     FLASH_WaitForLastOperation
   \   000006 721F505B              BRES      L:0x505b, #0x7
   \   00000A 721E505C              BSET      L:0x505c, #0x7
   \   00000E 87                    RETF

   \                                 In section .far_func.text, align 1
    232          void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data)
    233          {
   \                     FLASH_ProgramOptionByte:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 BF00                  LDW       S:?w4, X
   \   000009 B700                  LD        S:?b10, A
    234              /* Check parameter */
    235              assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   00000B 1CB800                ADDW      X, #0xb800
   \   00000E A30080                CPW       X, #0x80
   \   000011 2507                  JRC       L:??CrossCallReturnLabel_7
   \   000013 AE00EB                LDW       X, #0xeb
   \   000016 8D000000              CALLF     ?Subroutine0
    236          
    237              /* Enable write access to option bytes */
    238              FLASH->CR2 |= FLASH_CR2_OPT;
   \                     ??CrossCallReturnLabel_7:
   \   00001A 8D000000              CALLF     ?Subroutine4
    239              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NOPT);
    240          
    241              /* check if the option byte to program is ROP*/
    242              if (Address == 0x4800)
   \                     ??CrossCallReturnLabel_27:
   \   00001E 2607                  JRNE      L:??FLASH_ProgramOptionByte_0
    243              {
    244                 /* Program option byte*/
    245                 *((NEAR uint8_t*)Address) = Data;
   \   000020 B600                  LD        A, S:?b10
   \   000022 C74800                LD        L:0x4800, A
   \   000025 200B                  JRA       L:??FLASH_ProgramOptionByte_1
    246              }
    247              else
    248              {
    249                 /* Program option byte and his complement */
    250                 *((NEAR uint8_t*)Address) = Data;
   \                     ??FLASH_ProgramOptionByte_0:
   \   000027 B600                  LD        A, S:?b10
   \   000029 92C700                LD        [S:?w4.w], A
    251                 *((NEAR uint8_t*)((uint16_t)(Address + 1))) = (uint8_t)(~Data);
   \   00002C 5C                    INCW      X
   \   00002D 3300                  CPL       S:?b10
   \   00002F B600                  LD        A, S:?b10
   \   000031 F7                    LD        (X), A
    252              }
    253              FLASH_WaitForLastOperation(FLASH_MEMTYPE_PROG);
   \                     ??FLASH_ProgramOptionByte_1:
   \   000032 8D000000              CALLF     ?Subroutine3
    254          
    255              /* Disable write access to option bytes */
    256              FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
    257              FLASH->NCR2 |= FLASH_NCR2_NOPT;
    258          }
   \                     ??CrossCallReturnLabel_25:
   \   000036 320000                POP       S:?b10
   \   000039 AC000000              JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine4:
   \   000000 721E505B              BSET      L:0x505b, #0x7
   \   000004 721F505C              BRES      L:0x505c, #0x7
   \   000008 BE00                  LDW       X, S:?w4
   \   00000A A34800                CPW       X, #0x4800
   \   00000D 87                    RETF
    259          
    260          /**
    261            * @brief   Erases option byte
    262            * @param  Address : Option byte address to erase
    263            * @retval None
    264            */

   \                                 In section .far_func.text, align 1
    265          void FLASH_EraseOptionByte(uint16_t Address)
    266          {
   \                     FLASH_EraseOptionByte:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    267              /* Check parameter */
    268              assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   000006 1CB800                ADDW      X, #0xb800
   \   000009 A30080                CPW       X, #0x80
   \   00000C 2507                  JRC       L:??CrossCallReturnLabel_8
   \   00000E AE010C                LDW       X, #0x10c
   \   000011 8D000000              CALLF     ?Subroutine0
    269          
    270              /* Enable write access to option bytes */
    271              FLASH->CR2 |= FLASH_CR2_OPT;
   \                     ??CrossCallReturnLabel_8:
   \   000015 8D000000              CALLF     ?Subroutine4
    272              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NOPT);
    273          
    274               /* check if the option byte to erase is ROP */
    275               if (Address == 0x4800)
   \                     ??CrossCallReturnLabel_26:
   \   000019 2606                  JRNE      L:??FLASH_EraseOptionByte_0
    276              {
    277                 /* Erase option byte */
    278                 *((NEAR uint8_t*)Address) = FLASH_CLEAR_BYTE;
   \   00001B 725F4800              CLR       L:0x4800
   \   00001F 2008                  JRA       L:??FLASH_EraseOptionByte_1
    279              }
    280              else
    281              {
    282                 /* Erase option byte and his complement */
    283                 *((NEAR uint8_t*)Address) = FLASH_CLEAR_BYTE;
   \                     ??FLASH_EraseOptionByte_0:
   \   000021 4F                    CLR       A
   \   000022 92C700                LD        [S:?w4.w], A
    284                 *((NEAR uint8_t*)((uint16_t)(Address + (uint16_t)1 ))) = FLASH_SET_BYTE;
   \   000025 5C                    INCW      X
   \   000026 A6FF                  LD        A, #0xff
   \   000028 F7                    LD        (X), A
    285              }
    286              FLASH_WaitForLastOperation(FLASH_MEMTYPE_PROG);
   \                     ??FLASH_EraseOptionByte_1:
   \   000029 8D000000              CALLF     ?Subroutine3
    287          
    288              /* Disable write access to option bytes */
    289              FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
    290              FLASH->NCR2 |= FLASH_NCR2_NOPT;
    291          }
   \                     ??CrossCallReturnLabel_24:
   \   00002D AC000000              JPF       L:?epilogue_w4
    292          /**
    293            * @brief   Reads one option byte
    294            * @param  Address  option byte address to read.
    295            * @retval Option byte read value + its complement
    296            */

   \                                 In section .far_func.text, align 1
    297          uint16_t FLASH_ReadOptionByte(uint16_t Address)
    298          {
   \                     FLASH_ReadOptionByte:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    299              uint8_t value_optbyte, value_optbyte_complement = 0;
    300              uint16_t res_value = 0;
    301          
    302              /* Check parameter */
    303              assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   000006 1CB800                ADDW      X, #0xb800
   \   000009 A30080                CPW       X, #0x80
   \   00000C 2507                  JRC       L:??CrossCallReturnLabel_9
   \   00000E AE012F                LDW       X, #0x12f
   \   000011 8D000000              CALLF     ?Subroutine0
    304          
    305          
    306              value_optbyte = *((NEAR uint8_t*)Address); /* Read option byte */
   \                     ??CrossCallReturnLabel_9:
   \   000015 BE00                  LDW       X, S:?w4
   \   000017 F6                    LD        A, (X)
   \   000018 B700                  LD        S:?b1, A
    307              value_optbyte_complement = *(((NEAR uint8_t*)Address) + 1); /* Read option byte complement */
   \   00001A 5C                    INCW      X
   \   00001B F6                    LD        A, (X)
   \   00001C B700                  LD        S:?b0, A
    308          
    309              /* Read-out protection option byte */
    310              if (Address == 0x4800)	 
   \   00001E 5F                    CLRW      X
   \   00001F 41                    EXG       A, XL
   \   000020 B600                  LD        A, S:?b1
   \   000022 41                    EXG       A, XL
   \   000023 90BE00                LDW       Y, S:?w4
   \   000026 90A34800              CPW       Y, #0x4800
   \   00002A 2717                  JREQ      L:??FLASH_ReadOptionByte_0
    311              {
    312                  res_value =	 value_optbyte;
    313              }
    314              else
    315              {
    316                  if (value_optbyte == (uint8_t)(~value_optbyte_complement))
   \   00002C 43                    CPL       A
   \   00002D B100                  CP        A, S:?b1
   \   00002F 260F                  JRNE      L:??FLASH_ReadOptionByte_1
    317                  {
    318                      res_value = (uint16_t)((uint16_t)value_optbyte << 8);
    319                      res_value = res_value | (uint16_t)value_optbyte_complement;
   \   000031 905F                  CLRW      Y
   \   000033 B600                  LD        A, S:?b0
   \   000035 61                    EXG       A, YL
   \   000036 90BF00                LDW       S:?w0, Y
   \   000039 BA00                  OR        A, S:?b1
   \   00003B 02                    RLWA      X, A
   \   00003C AC000000              JPF       L:?epilogue_w4
    320                  }
    321                  else
    322                  {
    323                      res_value = FLASH_OPTIONBYTE_ERROR;
   \                     ??FLASH_ReadOptionByte_1:
   \   000040 AE5555                LDW       X, #0x5555
    324                  }
    325              }
    326              return(res_value);
   \                     ??FLASH_ReadOptionByte_0:
   \   000043 AC000000              JPF       L:?epilogue_w4
    327          }
    328          
    329          /**
    330            * @brief   Select the Flash behaviour in low power mode
    331            * @param  FLASH_LPMode Low power mode selection
    332            *         This parameter can be any of the @ref FLASH_LPMode_TypeDef values.
    333            * @retval None
    334            */

   \                                 In section .far_func.text, align 1
    335          void FLASH_SetLowPowerMode(FLASH_LPMode_TypeDef FLASH_LPMode)
    336          {
   \                     FLASH_SetLowPowerMode:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    337              /* Check parameter */
    338              assert_param(IS_FLASH_LOW_POWER_MODE_OK(FLASH_LPMode));
   \   000005 A104                  CP        A, #0x4
   \   000007 2713                  JREQ      L:??CrossCallReturnLabel_10
   \   000009 A108                  CP        A, #0x8
   \   00000B 270F                  JREQ      L:??CrossCallReturnLabel_10
   \   00000D 3D00                  TNZ       S:?b8
   \   00000F 270B                  JREQ      L:??CrossCallReturnLabel_10
   \   000011 A10C                  CP        A, #0xc
   \   000013 2707                  JREQ      L:??CrossCallReturnLabel_10
   \   000015 AE0152                LDW       X, #0x152
   \   000018 8D000000              CALLF     ?Subroutine0
    339          
    340              /* Clears the two bits */
    341              FLASH->CR1 &= (uint8_t)(~(FLASH_CR1_HALT | FLASH_CR1_AHALT)); 
   \                     ??CrossCallReturnLabel_10:
   \   00001C C6505A                LD        A, L:0x505a
   \   00001F A4F3                  AND       A, #0xf3
   \   000021 C7505A                LD        L:0x505a, A
    342              
    343              /* Sets the new mode */
    344              FLASH->CR1 |= (uint8_t)FLASH_LPMode; 
   \   000024 B600                  LD        A, S:?b8
   \   000026 CA505A                OR        A, L:0x505a
   \   000029 C7505A                LD        L:0x505a, A
    345          }
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    346          
    347          /**
    348            * @brief   Sets the fixed programming time
    349            * @param  FLASH_ProgTime Indicates the programming time to be fixed
    350            *         This parameter can be any of the @ref FLASH_ProgramTime_TypeDef values.
    351            * @retval None
    352            */

   \                                 In section .far_func.text, align 1
    353          void FLASH_SetProgrammingTime(FLASH_ProgramTime_TypeDef FLASH_ProgTime)
    354          {
   \                     FLASH_SetProgrammingTime:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    355              /* Check parameter */
    356              assert_param(IS_FLASH_PROGRAM_TIME_OK(FLASH_ProgTime));
   \   000005 270B                  JREQ      L:??CrossCallReturnLabel_11
   \   000007 A101                  CP        A, #0x1
   \   000009 2707                  JREQ      L:??CrossCallReturnLabel_11
   \   00000B AE0164                LDW       X, #0x164
   \   00000E 8D000000              CALLF     ?Subroutine0
    357          
    358              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_FIX);
   \                     ??CrossCallReturnLabel_11:
   \   000012 7211505A              BRES      L:0x505a, #0x0
    359              FLASH->CR1 |= (uint8_t)FLASH_ProgTime;
   \   000016 B600                  LD        A, S:?b8
   \   000018 CA505A                OR        A, L:0x505a
   \   00001B C7505A                LD        L:0x505a, A
    360          }
   \   00001E 320000                POP       S:?b8
   \   000021 87                    RETF
    361          
    362          /**
    363            * @brief  Returns the Flash behaviour type in low power mode
    364            * @param  None
    365            * @retval FLASH_LPMode_TypeDef Flash behaviour type in low power mode
    366            */

   \                                 In section .far_func.text, align 1
    367          FLASH_LPMode_TypeDef FLASH_GetLowPowerMode(void)
    368          {
    369              return((FLASH_LPMode_TypeDef)(FLASH->CR1 & (uint8_t)(FLASH_CR1_HALT | FLASH_CR1_AHALT)));
   \                     FLASH_GetLowPowerMode:
   \   000000 C6505A                LD        A, L:0x505a
   \   000003 A40C                  AND       A, #0xc
   \   000005 87                    RETF
    370          }
    371          
    372          /**
    373            * @brief  Returns the fixed programming time
    374            * @param  None
    375            * @retval FLASH_ProgramTime_TypeDef Fixed programming time value
    376            */

   \                                 In section .far_func.text, align 1
    377          FLASH_ProgramTime_TypeDef FLASH_GetProgrammingTime(void)
    378          {
    379              return((FLASH_ProgramTime_TypeDef)(FLASH->CR1 & FLASH_CR1_FIX));
   \                     FLASH_GetProgrammingTime:
   \   000000 C6505A                LD        A, L:0x505a
   \   000003 A401                  AND       A, #0x1
   \   000005 87                    RETF
    380          }
    381          
    382          /**
    383            * @brief  Returns the Boot memory size in bytes
    384            * @param  None
    385            * @retval Boot memory size in bytes
    386            */

   \                                 In section .far_func.text, align 1
    387          uint32_t FLASH_GetBootSize(void)
    388          {
    389              uint32_t temp = 0;
    390          
    391              /* Calculates the number of bytes */
    392              temp = (uint32_t)((uint32_t)FLASH->FPR * (uint32_t)512);
   \                     FLASH_GetBootSize:
   \   000000 C6505D                LD        A, L:0x505d
   \   000003 5F                    CLRW      X
   \   000004 97                    LD        XL, A
   \   000005 BF00                  LDW       S:?w1, X
   \   000007 5F                    CLRW      X
   \   000008 BF00                  LDW       S:?w0, X
   \   00000A A609                  LD        A, #0x9
   \   00000C 8D000000              CALLF     L:?sll32_l0_l0_a
    393          
    394              /* Correction because size of 127.5 kb doesn't exist */
    395              if (FLASH->FPR == 0xFF)
   \   000010 C6505D                LD        A, L:0x505d
   \   000013 A1FF                  CP        A, #0xff
   \   000015 260C                  JRNE      L:??FLASH_GetBootSize_0
    396              {
    397                  temp += 512;
   \   000017 AE0200                LDW       X, #0x200
   \   00001A BF00                  LDW       S:?w3, X
   \   00001C 5F                    CLRW      X
   \   00001D BF00                  LDW       S:?w2, X
   \   00001F 8D000000              CALLF     L:?add32_l0_l0_l1
    398              }
    399          
    400              /* Return value */
    401              return(temp);
   \                     ??FLASH_GetBootSize_0:
   \   000023 87                    RETF
    402          }
    403          
    404          /**
    405            * @brief  Checks whether the specified SPI flag is set or not.
    406            * @param  FLASH_FLAG : Specifies the flag to check.
    407            *         This parameter can be any of the @ref FLASH_Flag_TypeDef enumeration.
    408            * @retval FlagStatus : Indicates the state of FLASH_FLAG.
    409            *         This parameter can be any of the @ref FlagStatus enumeration.
    410            * @note   This function can clear the EOP, WR_PG_DIS flags in the IAPSR register.
    411            */

   \                                 In section .far_func.text, align 1
    412          FlagStatus FLASH_GetFlagStatus(FLASH_Flag_TypeDef FLASH_FLAG)
    413          {
   \                     FLASH_GetFlagStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    414              FlagStatus status = RESET;
    415              /* Check parameters */
    416              assert_param(IS_FLASH_FLAGS_OK(FLASH_FLAG));
   \   000005 A140                  CP        A, #0x40
   \   000007 2717                  JREQ      L:??CrossCallReturnLabel_12
   \   000009 A108                  CP        A, #0x8
   \   00000B 2713                  JREQ      L:??CrossCallReturnLabel_12
   \   00000D A104                  CP        A, #0x4
   \   00000F 270F                  JREQ      L:??CrossCallReturnLabel_12
   \   000011 A102                  CP        A, #0x2
   \   000013 270B                  JREQ      L:??CrossCallReturnLabel_12
   \   000015 A101                  CP        A, #0x1
   \   000017 2707                  JREQ      L:??CrossCallReturnLabel_12
   \   000019 AE01A0                LDW       X, #0x1a0
   \   00001C 8D000000              CALLF     ?Subroutine0
    417          
    418              /* Check the status of the specified FLASH flag */
    419              if ((FLASH->IAPSR & (uint8_t)FLASH_FLAG) != (uint8_t)RESET)
   \                     ??CrossCallReturnLabel_12:
   \   000020 B600                  LD        A, S:?b8
   \   000022 C5505F                BCP       A, L:0x505f
   \   000025 2704                  JREQ      L:??FLASH_GetFlagStatus_0
    420              {
    421                  status = SET; /* FLASH_FLAG is set */
   \   000027 A601                  LD        A, #0x1
   \   000029 2001                  JRA       L:??FLASH_GetFlagStatus_1
    422              }
    423              else
    424              {
    425                  status = RESET; /* FLASH_FLAG is reset*/
   \                     ??FLASH_GetFlagStatus_0:
   \   00002B 4F                    CLR       A
    426              }
    427          
    428              /* Return the FLASH_FLAG status */
    429              return status;
   \                     ??FLASH_GetFlagStatus_1:
   \   00002C 320000                POP       S:?b8
   \   00002F 87                    RETF
    430          }
    431          
    432          /**
    433          @code
    434           All the functions defined below must be executed from RAM exclusively, except
    435           for the FLASH_WaitForLastOperation function which can be executed from Flash.
    436          
    437           Steps of the execution from RAM differs from one toolchain to another:
    438           - For Cosmic Compiler:
    439              1- Define a segment FLASH_CODE by the mean of " #pragma section (FLASH_CODE)".
    440              This segment is defined in the stm8s_flash.c file.
    441            2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file,
    442              or define it in Cosmic compiler preprocessor to enable the FLASH_CODE segment
    443             definition.
    444            3- In STVD Select Project\Settings\Linker\Category "input" and in the RAM section
    445              add the FLASH_CODE segment with "-ic" options.
    446            4- In main.c file call the _fctcpy() function with first segment character as 
    447              parameter "_fctcpy('F');" to load the declared moveable code segment
    448              (FLASH_CODE) in RAM before execution.
    449            5- By default the _fctcpy function is packaged in the Cosmic machine library,
    450              so the function prototype "int _fctcopy(char name);" must be added in main.c
    451              file.
    452          
    453            - For Raisonance Compiler
    454             1- Use the inram keyword in the function declaration to specify that it can be
    455              executed from RAM.
    456              This is done within the stm8s_flash.c file, and it's conditioned by 
    457              RAM_EXECUTION definition.
    458             2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file, or 
    459             define it in Raisonance compiler preprocessor to enable the access for the 
    460             inram functions.
    461             3- An inram function code is copied from Flash to RAM by the C startup code. 
    462             In some applications, the RAM area where the code was initially stored may be
    463             erased or corrupted, so it may be desirable to perform the copy again. 
    464             Depending on the application memory model, the memcpy() or fmemcpy() functions
    465             should be used to perform the copy.
    466                 In case your project uses the SMALL memory model (code smaller than 64K),
    467                 memcpy()function is recommended to perform the copy
    468                 In case your project uses the LARGE memory model, functions can be 
    469                everywhenre in the 24-bits address space (not limited to the first 64KB of
    470                code), In this case, the use of memcpy() function will not be appropriate,
    471                you need to use the specific fmemcpy() function (which copies objects with
    472                24-bit addresses).
    473                - The linker automatically defines 2 symbols for each inram function:
    474                      __address__functionname is a symbol that holds the Flash address 
    475                     where the given function code is stored.
    476                      __size__functionname is a symbol that holds the function size in bytes.
    477               And we already have the function address (which is itself a pointer)
    478            4- In main.c file these two steps should be performed for each inram function:
    479                Import the "__address__functionname" and "__size__functionname" symbols
    480                 as global variables:
    481                   extern int __address__functionname; // Symbol holding the flash address
    482                   extern int __size__functionname;    // Symbol holding the function size
    483                In case of SMALL memory model use, Call the memcpy() function to copy the
    484                inram function to the RAM destination address:
    485                          memcpy(functionname, // RAM destination address
    486                                (void*)&__address__functionname, // Flash source address
    487                                (int)&__size__functionname); // Code size of the function
    488                In case of LARGE memory model use, call the fmemcpy() function to copy 
    489               the inram function to the RAM destination address:
    490                           memcpy(functionname, // RAM destination address
    491                                (void @far*)&__address__functionname, // Flash source address
    492                                (int)&__size__functionname); // Code size of the function
    493          
    494           - For IAR Compiler:
    495              1- Use the __ramfunc keyword in the function declaration to specify that it 
    496              can be executed from RAM..
    497              This is done within the stm8s_flash.c file, and it's conditioned by 
    498              RAM_EXECUTION definition.
    499              2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file, or 
    500             define it in IAR compiler preprocessor to enable the access for the 
    501             __ramfunc functions.
    502           
    503           The FLASH examples given within the STM8S_StdPeriph_Lib package, details all 
    504           the steps described above.
    505          
    506          @endcode
    507          */
    508          
    509          /**
    510            * @brief
    511            *******************************************************************************
    512            *                         Execution from RAM enable
    513            *******************************************************************************
    514            *
    515            * To enable execution from RAM you can either uncomment the following define 
    516            * in the stm8s.h file or define it in your toolchain compiler preprocessor
    517            * - #define RAM_EXECUTION  (1) 
    518            */
    519            
    520          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    521           #pragma section (FLASH_CODE)
    522          #endif  /* _COSMIC_ && RAM_EXECUTION */
    523          /**
    524            * @brief  Wait for a Flash operation to complete.
    525            * @note   The call and execution of this function must be done from RAM in case
    526            *         of Block operation, otherwise it can be executed from Flash
    527            * @param  FLASH_MemType : Memory type
    528            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
    529            * @retval FLASH status
    530            */

   \                                 In section .far_func.text, align 1
    531          IN_RAM(FLASH_Status_TypeDef FLASH_WaitForLastOperation(FLASH_MemType_TypeDef FLASH_MemType)) 
    532          {
    533              uint8_t flagstatus = 0x00;
    534              uint32_t timeout = OPERATION_TIMEOUT;
   \                     FLASH_WaitForLastOperation:
   \   000000 5F                    CLRW      X
   \   000001 5A                    DECW      X
   \   000002 BF00                  LDW       S:?w1, X
   \   000004 AE000F                LDW       X, #0xf
   \   000007 BF00                  LDW       S:?w0, X
    535              
    536              /* Wait until operation completion or write protection page occurred */
    537          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined(STM8S105) || \
    538              defined(STM8S005) || defined(STM8AF52Ax) || defined(STM8AF62Ax) || defined(STM8AF626x)  
    539              if (FLASH_MemType == FLASH_MEMTYPE_PROG)
   \   000009 A1FD                  CP        A, #0xfd
   \   00000B 261E                  JRNE      L:??FLASH_WaitForLastOperation_0
    540              {
    541                  while ((flagstatus == 0x00) && (timeout != 0x00))
    542                  {
    543                      flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_EOP |
    544                                                        FLASH_IAPSR_WR_PG_DIS));
   \                     ??FLASH_WaitForLastOperation_1:
   \   00000D C6505F                LD        A, L:0x505f
   \   000010 A405                  AND       A, #0x5
    545                      timeout--;
   \   000012 8D000000              CALLF     L:?dec32_l0_l0
    546                  }
   \   000016 4D                    TNZ       A
   \   000017 261E                  JRNE      L:??FLASH_WaitForLastOperation_2
   \   000019 BE00                  LDW       X, S:?w0
   \   00001B 2602                  JRNE      L:??FLASH_WaitForLastOperation_3
   \   00001D BE00                  LDW       X, S:?w1
   \                     ??FLASH_WaitForLastOperation_3:
   \   00001F 26EC                  JRNE      L:??FLASH_WaitForLastOperation_1
   \   000021 201C                  JRA       L:??FLASH_WaitForLastOperation_4
    547              }
    548              else
    549              {
    550                  while ((flagstatus == 0x00) && (timeout != 0x00))
   \                     ??FLASH_WaitForLastOperation_5:
   \   000023 BE00                  LDW       X, S:?w0
   \   000025 2602                  JRNE      L:??FLASH_WaitForLastOperation_6
   \   000027 BE00                  LDW       X, S:?w1
   \                     ??FLASH_WaitForLastOperation_6:
   \   000029 2714                  JREQ      L:??FLASH_WaitForLastOperation_4
    551                  {
    552                      flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_HVOFF |
    553                                                        FLASH_IAPSR_WR_PG_DIS));
   \                     ??FLASH_WaitForLastOperation_0:
   \   00002B C6505F                LD        A, L:0x505f
   \   00002E A441                  AND       A, #0x41
    554                      timeout--;
   \   000030 8D000000              CALLF     L:?dec32_l0_l0
    555                  }
   \   000034 4D                    TNZ       A
   \   000035 27EC                  JREQ      L:??FLASH_WaitForLastOperation_5
    556              }
    557          #else /*STM8S103, STM8S903*/
    558              while ((flagstatus == 0x00) && (timeout != 0x00))
    559              {
    560                  flagstatus = (uint8_t)(FLASH->IAPSR & (FLASH_IAPSR_EOP | FLASH_IAPSR_WR_PG_DIS));
    561                  timeout--;
    562              }
    563          
    564          #endif /* STM8S208, STM8S207, STM8S105, STM8AF52Ax, STM8AF62Ax, STM8AF262x */
    565              
    566              if (timeout == 0x00 )
   \                     ??FLASH_WaitForLastOperation_2:
   \   000037 BE00                  LDW       X, S:?w0
   \   000039 2602                  JRNE      L:??FLASH_WaitForLastOperation_7
   \   00003B BE00                  LDW       X, S:?w1
   \                     ??FLASH_WaitForLastOperation_7:
   \   00003D 2602                  JRNE      L:??FLASH_WaitForLastOperation_8
    567              {
    568                  flagstatus = FLASH_STATUS_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_4:
   \   00003F A602                  LD        A, #0x2
    569              }
    570          
    571              return((FLASH_Status_TypeDef)flagstatus);
   \                     ??FLASH_WaitForLastOperation_8:
   \   000041 87                    RETF
    572          }
    573          
    574          /**
    575            * @brief  Erases a block in the program or data memory.
    576            * @note   This function should be called and executed from RAM.
    577            * @param  FLASH_MemType :  The type of memory to erase
    578            * @param  BlockNum : Indicates the block number to erase
    579            * @retval None.
    580            */

   \                                 In section .far_func.text, align 1
    581          IN_RAM(void FLASH_EraseBlock(uint16_t BlockNum, FLASH_MemType_TypeDef FLASH_MemType))
    582          {
   \                     FLASH_EraseBlock:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    583            uint32_t startaddress = 0;
    584              
    585          #if defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) || \
    586              defined (STM8S903) || defined (STM8AF626x)
    587            uint32_t PointerAttr  *pwFlash;
    588          #elif defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || defined (STM8AF52Ax) 
    589            uint8_t PointerAttr  *pwFlash;
    590          #endif
    591          
    592            /* Check parameters */
    593            assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000006 A1FD                  CP        A, #0xfd
   \   000008 2743                  JREQ      L:??FLASH_EraseBlock_0
   \   00000A A1F7                  CP        A, #0xf7
   \   00000C 2707                  JREQ      L:??CrossCallReturnLabel_15
   \   00000E AE0251                LDW       X, #0x251
   \   000011 8D000000              CALLF     ?Subroutine0
    594            if (FLASH_MemType == FLASH_MEMTYPE_PROG)
    595            {
    596                assert_param(IS_FLASH_PROG_BLOCK_NUMBER_OK(BlockNum));
    597                startaddress = FLASH_PROG_START_PHYSICAL_ADDRESS;
    598            }
    599            else
    600            {
    601                assert_param(IS_FLASH_DATA_BLOCK_NUMBER_OK(BlockNum));
   \                     ??CrossCallReturnLabel_15:
   \   000015 BE00                  LDW       X, S:?w4
   \   000017 A30008                CPW       X, #0x8
   \   00001A 2507                  JRC       L:??CrossCallReturnLabel_14
   \   00001C AE0259                LDW       X, #0x259
   \   00001F 8D000000              CALLF     ?Subroutine0
    602                startaddress = FLASH_DATA_START_PHYSICAL_ADDRESS;
   \                     ??CrossCallReturnLabel_14:
   \   000023 AE4000                LDW       X, #0x4000
   \                     ??FLASH_EraseBlock_1:
   \   000026 BF00                  LDW       S:?w1, X
    603            }
    604          
    605              /* Point to the first block address */
    606          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || defined (STM8AF52Ax)
    607              pwFlash = (PointerAttr uint8_t *)(uint32_t)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
    608          #elif defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) || \
    609                defined (STM8S903) || defined (STM8AF626x)
    610              pwFlash = (PointerAttr uint32_t *)(uint16_t)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
    611          #endif	/* STM8S208, STM8S207 */
    612          
    613              /* Enable erase block mode */
    614              FLASH->CR2 |= FLASH_CR2_ERASE;
   \   000028 721A505B              BSET      L:0x505b, #0x5
    615              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NERASE);
   \   00002C 721B505C              BRES      L:0x505c, #0x5
    616          
    617          #if defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) ||  \
    618              defined (STM8S903) || defined (STM8AF626x)
    619              *pwFlash = (uint32_t)0;
   \   000030 BE00                  LDW       X, S:?w4
   \   000032 54                    SRLW      X
   \   000033 4F                    CLR       A
   \   000034 46                    RRC       A
   \   000035 02                    RLWA      X, A
   \   000036 90BE00                LDW       Y, S:?w1
   \   000039 BF00                  LDW       S:?w0, X
   \   00003B 72B90000              ADDW      Y, S:?w0
   \   00003F 5F                    CLRW      X
   \   000040 BF00                  LDW       S:?w1, X
   \   000042 BF00                  LDW       S:?w0, X
   \   000044 93                    LDW       X, Y
   \   000045 8D000000              CALLF     L:?load32_0x_l0
    620          #elif defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || \
    621                defined (STM8AF52Ax)
    622            *pwFlash = (uint8_t)0;
    623            *(pwFlash + 1) = (uint8_t)0;
    624            *(pwFlash + 2) = (uint8_t)0;
    625            *(pwFlash + 3) = (uint8_t)0;    
    626          #endif
    627          }
   \   000049 AC000000              JPF       L:?epilogue_w4
   \                     ??FLASH_EraseBlock_0:
   \   00004D A30100                CPW       X, #0x100
   \   000050 2507                  JRC       L:??CrossCallReturnLabel_13
   \   000052 AE0254                LDW       X, #0x254
   \   000055 8D000000              CALLF     ?Subroutine0
   \                     ??CrossCallReturnLabel_13:
   \   000059 AE8000                LDW       X, #0x8000
   \   00005C 20C8                  JRA       ??FLASH_EraseBlock_1
    628          
    629          /**
    630            * @brief  Programs a memory block
    631            * @note   This function should be called and executed from RAM.
    632            * @param  FLASH_MemType : The type of memory to program
    633            * @param  BlockNum : The block number
    634            * @param  FLASH_ProgMode : The programming mode.
    635            * @param  Buffer : Pointer to buffer containing source data.
    636            * @retval None.
    637            */

   \                                 In section .far_func.text, align 1
    638          IN_RAM(void FLASH_ProgramBlock(uint16_t BlockNum, FLASH_MemType_TypeDef FLASH_MemType, 
    639                                  FLASH_ProgramMode_TypeDef FLASH_ProgMode, uint8_t *Buffer))
    640          {
   \                     FLASH_ProgramBlock:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 9089                  PUSHW     Y
   \   00000A BF00                  LDW       S:?w4, X
   \   00000C B700                  LD        S:?b11, A
   \   00000E 450000                MOV       S:?b10, S:?b0
    641              uint16_t Count = 0;
    642              uint32_t startaddress = 0;
    643          
    644              /* Check parameters */
    645              assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000011 A1FD                  CP        A, #0xfd
   \   000013 270B                  JREQ      L:??CrossCallReturnLabel_19
   \   000015 A1F7                  CP        A, #0xf7
   \   000017 2707                  JREQ      L:??CrossCallReturnLabel_19
   \   000019 AE0285                LDW       X, #0x285
   \   00001C 8D000000              CALLF     ?Subroutine0
    646              assert_param(IS_FLASH_PROGRAM_MODE_OK(FLASH_ProgMode));
   \                     ??CrossCallReturnLabel_19:
   \   000020 3D00                  TNZ       S:?b10
   \   000022 270D                  JREQ      L:??CrossCallReturnLabel_18
   \   000024 B600                  LD        A, S:?b10
   \   000026 A110                  CP        A, #0x10
   \   000028 2707                  JREQ      L:??CrossCallReturnLabel_18
   \   00002A AE0286                LDW       X, #0x286
   \   00002D 8D000000              CALLF     ?Subroutine0
    647              if (FLASH_MemType == FLASH_MEMTYPE_PROG)
   \                     ??CrossCallReturnLabel_18:
   \   000031 B600                  LD        A, S:?b11
   \   000033 A1FD                  CP        A, #0xfd
   \   000035 2616                  JRNE      L:??FLASH_ProgramBlock_0
    648              {
    649                  assert_param(IS_FLASH_PROG_BLOCK_NUMBER_OK(BlockNum));
   \   000037 BE00                  LDW       X, S:?w4
   \   000039 A30100                CPW       X, #0x100
   \   00003C 2507                  JRC       L:??CrossCallReturnLabel_17
   \   00003E AE0289                LDW       X, #0x289
   \   000041 8D000000              CALLF     ?Subroutine0
    650                  startaddress = FLASH_PROG_START_PHYSICAL_ADDRESS;
   \                     ??CrossCallReturnLabel_17:
   \   000045 AE8000                LDW       X, #0x8000
   \   000048 BF00                  LDW       S:?w3, X
   \   00004A 58                    SLLW      X
   \   00004B 2014                  JRA       ??FLASH_ProgramBlock_1
    651              }
    652              else
    653              {
    654                  assert_param(IS_FLASH_DATA_BLOCK_NUMBER_OK(BlockNum));
   \                     ??FLASH_ProgramBlock_0:
   \   00004D BE00                  LDW       X, S:?w4
   \   00004F A30008                CPW       X, #0x8
   \   000052 2507                  JRC       L:??CrossCallReturnLabel_16
   \   000054 AE028E                LDW       X, #0x28e
   \   000057 8D000000              CALLF     ?Subroutine0
    655                  startaddress = FLASH_DATA_START_PHYSICAL_ADDRESS;
   \                     ??CrossCallReturnLabel_16:
   \   00005B AE4000                LDW       X, #0x4000
   \   00005E BF00                  LDW       S:?w3, X
   \   000060 5F                    CLRW      X
   \                     ??FLASH_ProgramBlock_1:
   \   000061 BF00                  LDW       S:?w2, X
    656              }
    657          
    658              /* Point to the first block address */
    659              startaddress = startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE);
   \   000063 8D000000              CALLF     L:?mov_w1_w4
   \   000067 BF00                  LDW       S:?w0, X
   \   000069 A607                  LD        A, #0x7
   \   00006B 8D000000              CALLF     L:?sll32_l0_l0_a
   \   00006F 8D000000              CALLF     L:?mov_l3_l0
   \   000073 8D000000              CALLF     L:?mov_l0_l1
   \   000077 8D000000              CALLF     L:?mov_l1_l3
   \   00007B 8D000000              CALLF     L:?add32_l0_l0_l1
    660          
    661              /* Selection of Standard or Fast programming mode */
    662              if (FLASH_ProgMode == FLASH_PROGRAMMODE_STANDARD)
   \   00007F 3D00                  TNZ       S:?b10
   \   000081 260A                  JRNE      L:??FLASH_ProgramBlock_2
    663              {
    664                  /* Standard programming mode */ /*No need in standard mode */
    665                  FLASH->CR2 |= FLASH_CR2_PRG;
   \   000083 7210505B              BSET      L:0x505b, #0x0
    666                  FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NPRG);
   \   000087 7211505C              BRES      L:0x505c, #0x0
   \   00008B 2008                  JRA       L:??FLASH_ProgramBlock_3
    667              }
    668              else
    669              {
    670                  /* Fast programming mode */
    671                  FLASH->CR2 |= FLASH_CR2_FPRG;
   \                     ??FLASH_ProgramBlock_2:
   \   00008D 7218505B              BSET      L:0x505b, #0x4
    672                  FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NFPRG);
   \   000091 7219505C              BRES      L:0x505c, #0x4
    673              }
    674          
    675              /* Copy data bytes from RAM to FLASH memory */
    676              for (Count = 0; Count < FLASH_BLOCK_SIZE; Count++)
   \                     ??FLASH_ProgramBlock_3:
   \   000095 3F00                  CLR       S:?b5
    677              {
    678          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined(STM8S105) || \
    679              defined(STM8S005) || defined (STM8AF62Ax) || defined (STM8AF52Ax) || defined (STM8AF626x)
    680            *((PointerAttr uint8_t*) (uint16_t)startaddress + Count) = ((uint8_t)(Buffer[Count]));
   \                     ??FLASH_ProgramBlock_4:
   \   000097 BE00                  LDW       X, S:?w1
   \   000099 72BB0000              ADDW      X, S:?w2
   \   00009D 90BE00                LDW       Y, S:?w2
   \   0000A0 72F901                ADDW      Y, (0x1,SP)
   \   0000A3 90F6                  LD        A, (Y)
   \   0000A5 F7                    LD        (X), A
    681          #elif defined(STM8S103) || defined(STM8S003) ||  defined (STM8S903)
    682            *((PointerAttr uint8_t*) (uint16_t)startaddress + Count) = ((uint8_t)(Buffer[Count]));
    683          #endif       
    684              }
   \   0000A6 BE00                  LDW       X, S:?w2
   \   0000A8 5C                    INCW      X
   \   0000A9 BF00                  LDW       S:?w2, X
   \   0000AB A30080                CPW       X, #0x80
   \   0000AE 25E7                  JRC       L:??FLASH_ProgramBlock_4
    685          }
   \   0000B0 5B02                  ADD       SP, #0x2
   \   0000B2 AC000000              JPF       L:?epilogue_l2_l3

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\Users\\\\Administrato...">`:
   \   000000 433A5C557365          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \   000008 5C41646D696E          DC8 5CH, 41H, 64H, 6DH, 69H, 6EH, 69H, 73H
   \   000010 747261746F72          DC8 74H, 72H, 61H, 74H, 6FH, 72H, 5CH, 44H
   \   000018 65736B746F70          DC8 65H, 73H, 6BH, 74H, 6FH, 70H, 5CH, 73H
   \   000020 746D38733130          DC8 74H, 6DH, 38H, 73H, 31H, 30H, 35H, 6BH
   \   000028 2D636F6E7472          DC8 2DH, 63H, 6FH, 6EH, 74H, 72H, 6FH, 6CH
   \   000030 6C65725C4C69          DC8 6CH, 65H, 72H, 5CH, 4CH, 69H, 62H, 72H
   \   000038 61726965735C          DC8 61H, 72H, 69H, 65H, 73H, 5CH, 53H, 54H
   \   000040 4D38535F5374          DC8 4DH, 38H, 53H, 5FH, 53H, 74H, 64H, 50H
   \   000048 65726970685F          DC8 65H, 72H, 69H, 70H, 68H, 5FH, 44H, 72H
   \   000050 697665725C73          DC8 69H, 76H, 65H, 72H, 5CH, 73H, 72H, 63H
   \   000058 5C73746D3873          DC8 5CH, 73H, 74H, 6DH, 38H, 73H, 5FH, 66H
   \   000060 6C6173682E63          DC8 6CH, 61H, 73H, 68H, 2EH, 63H, 0
    686          
    687          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    688           /* End of FLASH_CODE section */
    689           #pragma section ()
    690          #endif /* _COSMIC_ && RAM_EXECUTION */
    691          
    692          
    693          /**
    694            * @}
    695            */
    696            
    697          /**
    698            * @}
    699            */
    700            
    701          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     ?Subroutine0                               12
     FLASH_Unlock                               33
     FLASH_Lock                                 32
     FLASH_DeInit                               24
     FLASH_ITConfig                             24
     ?Subroutine1                                4
     ??Subroutine5_0                            22
     ?Subroutine2                               19
     FLASH_EraseByte                            45
     FLASH_ProgramByte                          58
     FLASH_ReadByte                             44
     FLASH_ProgramWord                          84
     ?Subroutine3                               15
     FLASH_ProgramOptionByte                    61
     ?Subroutine4                               14
     FLASH_EraseOptionByte                      49
     FLASH_ReadOptionByte                       71
     FLASH_SetLowPowerMode                      48
     FLASH_SetProgrammingTime                   34
     FLASH_GetLowPowerMode                       6
     FLASH_GetProgrammingTime                    6
     FLASH_GetBootSize                          36
     FLASH_GetFlagStatus                        48
     FLASH_WaitForLastOperation                 66
     FLASH_EraseBlock                           94
     FLASH_ProgramBlock                        182
     ?<Constant "C:\\Users\\Administrato...">  103

 
 1 131 bytes in section .far_func.text
   103 bytes in section .near.rodata
 
 1 131 bytes of CODE  memory
   103 bytes of CONST memory

Errors: none
Warnings: none
