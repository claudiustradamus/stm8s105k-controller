###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             14/Aug/2013  09:25:07 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Users\Administrator\Desktop\stm8s105k-controller\Libr #
#                    aries\STM8S_StdPeriph_Driver\src\stm8s_adc1.c            #
#    Command line =  C:\Users\Administrator\Desktop\stm8s105k-controller\Libr #
#                    aries\STM8S_StdPeriph_Driver\src\stm8s_adc1.c -e -Ohz    #
#                    --debug --code_model medium --data_model medium -o       #
#                    C:\Users\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Obj\        #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0\stm8\LIB\dlstm8mmf.h" -D  #
#                    STM8S105 -lC C:\Users\Administrator\Desktop\stm8s105k-co #
#                    ntroller\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S10 #
#                    5\List\ -lA C:\Users\Administrator\Desktop\stm8s105k-con #
#                    troller\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S105 #
#                    \List\ -I C:\Users\Administrator\Desktop\stm8s105k-contr #
#                    oller\Project\STM8S_StdPeriph_Template\EWSTM8\..\ -I     #
#                    C:\Users\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\..\..\..\Libraries\S #
#                    TM8S_StdPeriph_Driver\inc\ --vregs 16                    #
#    List file    =  C:\Users\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\List\stm8s_ #
#                    adc1.lst                                                 #
#    Object file  =  C:\Users\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Obj\stm8s_a #
#                    dc1.o                                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\stm8s105k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s_adc1.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_adc1.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions/macros for the ADC1 peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_adc1.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          
     35          /* Public functions ----------------------------------------------------------*/
     36          
     37          /**
     38            * @addtogroup ADC1_Public_Functions
     39            * @{
     40            */
     41          
     42          /**
     43            * @brief  Deinitializes the ADC1 peripheral registers to their default reset
     44            * values.
     45            * @param  None
     46            * @retval None
     47            */

   \                                 In section .far_func.text, align 1
     48          void ADC1_DeInit(void)
     49          {
     50              ADC1->CSR  = ADC1_CSR_RESET_VALUE;
   \                     ADC1_DeInit:
   \   000000 725F5400              CLR       L:0x5400
     51              ADC1->CR1  = ADC1_CR1_RESET_VALUE;
   \   000004 725F5401              CLR       L:0x5401
     52              ADC1->CR2  = ADC1_CR2_RESET_VALUE;
   \   000008 725F5402              CLR       L:0x5402
     53              ADC1->CR3  = ADC1_CR3_RESET_VALUE;
   \   00000C 725F5403              CLR       L:0x5403
     54              ADC1->TDRH = ADC1_TDRH_RESET_VALUE;
   \   000010 725F5406              CLR       L:0x5406
     55              ADC1->TDRL = ADC1_TDRL_RESET_VALUE;
   \   000014 725F5407              CLR       L:0x5407
     56              ADC1->HTRH = ADC1_HTRH_RESET_VALUE;
   \   000018 35FF5408              MOV       L:0x5408, #0xff
     57              ADC1->HTRL = ADC1_HTRL_RESET_VALUE;
   \   00001C 35035409              MOV       L:0x5409, #0x3
     58              ADC1->LTRH = ADC1_LTRH_RESET_VALUE;
   \   000020 725F540A              CLR       L:0x540a
     59              ADC1->LTRL = ADC1_LTRL_RESET_VALUE;
   \   000024 725F540B              CLR       L:0x540b
     60              ADC1->AWCRH = ADC1_AWCRH_RESET_VALUE;
   \   000028 725F540E              CLR       L:0x540e
     61              ADC1->AWCRL = ADC1_AWCRL_RESET_VALUE;
   \   00002C 725F540F              CLR       L:0x540f
     62          }
   \   000030 87                    RETF
     63          
     64          
     65          /**
     66            * @brief  Initializes the ADC1 peripheral according to the specified parameters
     67            * @param   ADC1_ConversionMode: specifies the conversion mode
     68            * can be one of the values of @ref ADC1_ConvMode_TypeDef.
     69            * @param   ADC1_Channel: specifies the channel to convert
     70            * can be one of the values of @ref ADC1_Channel_TypeDef.
     71            * @param   ADC1_PrescalerSelection: specifies the ADC1 prescaler
     72            * can be one of the values of @ref ADC1_PresSel_TypeDef.
     73            * @param   ADC1_ExtTrigger: specifies the external trigger
     74            * can be one of the values of @ref ADC1_ExtTrig_TypeDef.
     75            * @param   ADC1_ExtTriggerState: specifies the external trigger new state
     76            * can be one of the values of @ref FunctionalState.
     77            * @param   ADC1_Align: specifies the converted data alignment
     78            * can be one of the values of @ref ADC1_Align_TypeDef.
     79            * @param   ADC1_SchmittTriggerChannel: specifies the schmitt trigger channel
     80            * can be one of the values of @ref ADC1_SchmittTrigg_TypeDef.
     81            * @param   ADC1_SchmittTriggerState: specifies the schmitt trigger state
     82            * can be one of the values of @ref FunctionalState.
     83            * @retval None
     84            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine1:
   \   000000 8D000000              CALLF     ?Subroutine8
   \                     ??CrossCallReturnLabel_39:
   \   000004 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine8:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 AE0000                LDW       X, #`?<Constant "C:\\\\Users\\\\Administrato...">`
   \   000008 AC000000              JPF       assert_failed

   \                                 In section .far_func.text, align 1
     85          void ADC1_Init(ADC1_ConvMode_TypeDef ADC1_ConversionMode, ADC1_Channel_TypeDef ADC1_Channel, ADC1_PresSel_TypeDef ADC1_PrescalerSelection, ADC1_ExtTrig_TypeDef ADC1_ExtTrigger, FunctionalState ADC1_ExtTriggerState, ADC1_Align_TypeDef ADC1_Align, ADC1_SchmittTrigg_TypeDef ADC1_SchmittTriggerChannel, FunctionalState ADC1_SchmittTriggerState)
     86          {
   \                     ADC1_Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 B700                  LD        S:?b15, A
   \   00000A 450000                MOV       S:?b8, S:?b0
   \   00000D 450000                MOV       S:?b9, S:?b1
   \   000010 450000                MOV       S:?b14, S:?b2
   \   000013 450000                MOV       S:?b13, S:?b3
   \   000016 450000                MOV       S:?b12, S:?b4
   \   000019 450000                MOV       S:?b10, S:?b5
   \   00001C 450000                MOV       S:?b11, S:?b6
     87          
     88              /* Check the parameters */
     89              assert_param(IS_ADC1_CONVERSIONMODE_OK(ADC1_ConversionMode));
   \   00001F 270B                  JREQ      L:??CrossCallReturnLabel_21
   \   000021 A101                  CP        A, #0x1
   \   000023 2707                  JREQ      L:??CrossCallReturnLabel_21
   \   000025 AE0059                LDW       X, #0x59
   \   000028 8D000000              CALLF     ?Subroutine1
     90              assert_param(IS_ADC1_CHANNEL_OK(ADC1_Channel));
   \                     ??CrossCallReturnLabel_21:
   \   00002C 3D00                  TNZ       S:?b8
   \   00002E 2731                  JREQ      L:??CrossCallReturnLabel_22
   \   000030 B600                  LD        A, S:?b8
   \   000032 A101                  CP        A, #0x1
   \   000034 272B                  JREQ      L:??CrossCallReturnLabel_22
   \   000036 A102                  CP        A, #0x2
   \   000038 2727                  JREQ      L:??CrossCallReturnLabel_22
   \   00003A A103                  CP        A, #0x3
   \   00003C 2723                  JREQ      L:??CrossCallReturnLabel_22
   \   00003E A104                  CP        A, #0x4
   \   000040 271F                  JREQ      L:??CrossCallReturnLabel_22
   \   000042 A105                  CP        A, #0x5
   \   000044 271B                  JREQ      L:??CrossCallReturnLabel_22
   \   000046 A106                  CP        A, #0x6
   \   000048 2717                  JREQ      L:??CrossCallReturnLabel_22
   \   00004A A107                  CP        A, #0x7
   \   00004C 2713                  JREQ      L:??CrossCallReturnLabel_22
   \   00004E A108                  CP        A, #0x8
   \   000050 270F                  JREQ      L:??CrossCallReturnLabel_22
   \   000052 A10C                  CP        A, #0xc
   \   000054 270B                  JREQ      L:??CrossCallReturnLabel_22
   \   000056 A109                  CP        A, #0x9
   \   000058 2707                  JREQ      L:??CrossCallReturnLabel_22
   \   00005A AE005A                LDW       X, #0x5a
   \   00005D 8D000000              CALLF     ?Subroutine1
     91              assert_param(IS_ADC1_PRESSEL_OK(ADC1_PrescalerSelection));
   \                     ??CrossCallReturnLabel_22:
   \   000061 3D00                  TNZ       S:?b9
   \   000063 2725                  JREQ      L:??CrossCallReturnLabel_23
   \   000065 B600                  LD        A, S:?b9
   \   000067 A110                  CP        A, #0x10
   \   000069 271F                  JREQ      L:??CrossCallReturnLabel_23
   \   00006B A120                  CP        A, #0x20
   \   00006D 271B                  JREQ      L:??CrossCallReturnLabel_23
   \   00006F A130                  CP        A, #0x30
   \   000071 2717                  JREQ      L:??CrossCallReturnLabel_23
   \   000073 A140                  CP        A, #0x40
   \   000075 2713                  JREQ      L:??CrossCallReturnLabel_23
   \   000077 A150                  CP        A, #0x50
   \   000079 270F                  JREQ      L:??CrossCallReturnLabel_23
   \   00007B A160                  CP        A, #0x60
   \   00007D 270B                  JREQ      L:??CrossCallReturnLabel_23
   \   00007F A170                  CP        A, #0x70
   \   000081 2707                  JREQ      L:??CrossCallReturnLabel_23
   \   000083 AE005B                LDW       X, #0x5b
   \   000086 8D000000              CALLF     ?Subroutine1
     92              assert_param(IS_ADC1_EXTTRIG_OK(ADC1_ExtTrigger));
   \                     ??CrossCallReturnLabel_23:
   \   00008A 3D00                  TNZ       S:?b14
   \   00008C 270D                  JREQ      L:??CrossCallReturnLabel_24
   \   00008E B600                  LD        A, S:?b14
   \   000090 A110                  CP        A, #0x10
   \   000092 2707                  JREQ      L:??CrossCallReturnLabel_24
   \   000094 AE005C                LDW       X, #0x5c
   \   000097 8D000000              CALLF     ?Subroutine1
     93              assert_param(IS_FUNCTIONALSTATE_OK(((ADC1_ExtTriggerState))));
   \                     ??CrossCallReturnLabel_24:
   \   00009B 3D00                  TNZ       S:?b13
   \   00009D 270D                  JREQ      L:??CrossCallReturnLabel_25
   \   00009F B600                  LD        A, S:?b13
   \   0000A1 A101                  CP        A, #0x1
   \   0000A3 2707                  JREQ      L:??CrossCallReturnLabel_25
   \   0000A5 AE005D                LDW       X, #0x5d
   \   0000A8 8D000000              CALLF     ?Subroutine1
     94              assert_param(IS_ADC1_ALIGN_OK(ADC1_Align));
   \                     ??CrossCallReturnLabel_25:
   \   0000AC 3D00                  TNZ       S:?b12
   \   0000AE 270D                  JREQ      L:??CrossCallReturnLabel_26
   \   0000B0 B600                  LD        A, S:?b12
   \   0000B2 A108                  CP        A, #0x8
   \   0000B4 2707                  JREQ      L:??CrossCallReturnLabel_26
   \   0000B6 AE005E                LDW       X, #0x5e
   \   0000B9 8D000000              CALLF     ?Subroutine1
     95              assert_param(IS_ADC1_SCHMITTTRIG_OK(ADC1_SchmittTriggerChannel));
   \                     ??CrossCallReturnLabel_26:
   \   0000BD 3D00                  TNZ       S:?b10
   \   0000BF 2735                  JREQ      L:??CrossCallReturnLabel_27
   \   0000C1 B600                  LD        A, S:?b10
   \   0000C3 A101                  CP        A, #0x1
   \   0000C5 272F                  JREQ      L:??CrossCallReturnLabel_27
   \   0000C7 A102                  CP        A, #0x2
   \   0000C9 272B                  JREQ      L:??CrossCallReturnLabel_27
   \   0000CB A103                  CP        A, #0x3
   \   0000CD 2727                  JREQ      L:??CrossCallReturnLabel_27
   \   0000CF A104                  CP        A, #0x4
   \   0000D1 2723                  JREQ      L:??CrossCallReturnLabel_27
   \   0000D3 A105                  CP        A, #0x5
   \   0000D5 271F                  JREQ      L:??CrossCallReturnLabel_27
   \   0000D7 A106                  CP        A, #0x6
   \   0000D9 271B                  JREQ      L:??CrossCallReturnLabel_27
   \   0000DB A107                  CP        A, #0x7
   \   0000DD 2717                  JREQ      L:??CrossCallReturnLabel_27
   \   0000DF A108                  CP        A, #0x8
   \   0000E1 2713                  JREQ      L:??CrossCallReturnLabel_27
   \   0000E3 A10C                  CP        A, #0xc
   \   0000E5 270F                  JREQ      L:??CrossCallReturnLabel_27
   \   0000E7 A1FF                  CP        A, #0xff
   \   0000E9 270B                  JREQ      L:??CrossCallReturnLabel_27
   \   0000EB A109                  CP        A, #0x9
   \   0000ED 2707                  JREQ      L:??CrossCallReturnLabel_27
   \   0000EF AE005F                LDW       X, #0x5f
   \   0000F2 8D000000              CALLF     ?Subroutine1
     96              assert_param(IS_FUNCTIONALSTATE_OK(ADC1_SchmittTriggerState));
   \                     ??CrossCallReturnLabel_27:
   \   0000F6 3D00                  TNZ       S:?b11
   \   0000F8 270D                  JREQ      L:??CrossCallReturnLabel_28
   \   0000FA B600                  LD        A, S:?b11
   \   0000FC A101                  CP        A, #0x1
   \   0000FE 2707                  JREQ      L:??CrossCallReturnLabel_28
   \   000100 AE0060                LDW       X, #0x60
   \   000103 8D000000              CALLF     ?Subroutine1
     97          
     98              /*-----------------CR1 & CSR configuration --------------------*/
     99              /* Configure the conversion mode and the channel to convert
    100              respectively according to ADC1_ConversionMode & ADC1_Channel values  &  ADC1_Align values */
    101              ADC1_ConversionConfig(ADC1_ConversionMode, ADC1_Channel, ADC1_Align);
   \                     ??CrossCallReturnLabel_28:
   \   000107 450000                MOV       S:?b1, S:?b12
   \   00010A 450000                MOV       S:?b0, S:?b8
   \   00010D B600                  LD        A, S:?b15
   \   00010F 8D000000              CALLF     ADC1_ConversionConfig
    102              /* Select the prescaler division factor according to ADC1_PrescalerSelection values */
    103              ADC1_PrescalerConfig(ADC1_PrescalerSelection);
   \   000113 B600                  LD        A, S:?b9
   \   000115 8D000000              CALLF     ADC1_PrescalerConfig
    104          
    105              /*-----------------CR2 configuration --------------------*/
    106              /* Configure the external trigger state and event respectively
    107              according to NewState, ADC1_ExtTrigger */
    108              ADC1_ExternalTriggerConfig(ADC1_ExtTrigger, ADC1_ExtTriggerState);
   \   000119 450000                MOV       S:?b0, S:?b13
   \   00011C B600                  LD        A, S:?b14
   \   00011E 8D000000              CALLF     ADC1_ExternalTriggerConfig
    109          
    110              /*------------------TDR configuration ---------------------------*/
    111              /* Configure the schmitt trigger channel and state respectively
    112              according to ADC1_SchmittTriggerChannel & ADC1_SchmittTriggerNewState  values */
    113              ADC1_SchmittTriggerConfig(ADC1_SchmittTriggerChannel, ADC1_SchmittTriggerState);
   \   000122 450000                MOV       S:?b0, S:?b11
   \   000125 B600                  LD        A, S:?b10
   \   000127 8D000000              CALLF     ADC1_SchmittTriggerConfig
    114          
    115              /* Enable the ADC1 peripheral */
    116              ADC1->CR1 |= ADC1_CR1_ADON;
   \   00012B 72105401              BSET      L:0x5401, #0x0
    117          
    118          }
   \   00012F AC000000              JPF       L:?epilogue_l2_l3
    119          
    120          
    121          /**
    122            * @brief  Enables or Disables the ADC1 peripheral.
    123            * @param   NewState: specifies the peripheral enabled or disabled state.
    124            * @retval None
    125            */

   \                                 In section .far_func.text, align 1
    126          void ADC1_Cmd(FunctionalState NewState)
    127          {
    128          
    129              /* Check the parameters */
    130              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ADC1_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??ADC1_Cmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_20
   \   000007 AE0082                LDW       X, #0x82
   \   00000A 8D000000              CALLF     ?Subroutine1
    131          
    132              if (NewState != DISABLE)
    133              {
    134                  ADC1->CR1 |= ADC1_CR1_ADON;
   \                     ??CrossCallReturnLabel_20:
   \   00000E 72105401              BSET      L:0x5401, #0x0
   \   000012 87                    RETF
    135              }
    136              else /* NewState == DISABLE */
    137              {
    138                  ADC1->CR1 &= (uint8_t)(~ADC1_CR1_ADON);
   \                     ??ADC1_Cmd_0:
   \   000013 72115401              BRES      L:0x5401, #0x0
    139              }
    140          
    141          }
   \   000017 87                    RETF
    142          
    143          /**
    144            * @brief  Enables or Disables the ADC1 scan mode.
    145            * @param   NewState: specifies the selected mode enabled or disabled state.
    146            * @retval None
    147            */

   \                                 In section .far_func.text, align 1
    148          void ADC1_ScanModeCmd(FunctionalState NewState)
    149          {
    150          
    151              /* Check the parameters */
    152              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ADC1_ScanModeCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??ADC1_ScanModeCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_19
   \   000007 AE0098                LDW       X, #0x98
   \   00000A 8D000000              CALLF     ?Subroutine1
    153          
    154              if (NewState != DISABLE)
    155              {
    156                  ADC1->CR2 |= ADC1_CR2_SCAN;
   \                     ??CrossCallReturnLabel_19:
   \   00000E 72125402              BSET      L:0x5402, #0x1
   \   000012 87                    RETF
    157              }
    158              else /* NewState == DISABLE */
    159              {
    160                  ADC1->CR2 &= (uint8_t)(~ADC1_CR2_SCAN);
   \                     ??ADC1_ScanModeCmd_0:
   \   000013 72135402              BRES      L:0x5402, #0x1
    161              }
    162          
    163          }
   \   000017 87                    RETF
    164          
    165          /**
    166            * @brief  Enables or Disables the ADC1 data store into the Data Buffer registers rather than in the Data Register
    167            * @param   NewState: specifies the selected mode enabled or disabled state.
    168            * @retval None
    169            */

   \                                 In section .far_func.text, align 1
    170          void ADC1_DataBufferCmd(FunctionalState NewState)
    171          {
    172          
    173              /* Check the parameters */
    174              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ADC1_DataBufferCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??ADC1_DataBufferCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_18
   \   000007 AE00AE                LDW       X, #0xae
   \   00000A 8D000000              CALLF     ?Subroutine1
    175          
    176              if (NewState != DISABLE)
    177              {
    178                  ADC1->CR3 |= ADC1_CR3_DBUF;
   \                     ??CrossCallReturnLabel_18:
   \   00000E 721E5403              BSET      L:0x5403, #0x7
   \   000012 87                    RETF
    179              }
    180              else /* NewState == DISABLE */
    181              {
    182                  ADC1->CR3 &= (uint8_t)(~ADC1_CR3_DBUF);
   \                     ??ADC1_DataBufferCmd_0:
   \   000013 721F5403              BRES      L:0x5403, #0x7
    183              }
    184          
    185          }
   \   000017 87                    RETF
    186          
    187          /**
    188            * @brief  Enables or disables the ADC1 interrupt.
    189            * @param   ADC1_IT specifies the name of the interrupt to enable or disable.
    190            * This parameter can be one of the following values:
    191            *    - ADC1_IT_AWDITEN : Analog WDG interrupt enable
    192            *    - ADC1_IT_EOCITEN  : EOC iterrupt enable
    193            * @param   NewState specifies the state of the interrupt to apply.
    194            * @retval None
    195            */

   \                                 In section .far_func.text, align 1
    196          void ADC1_ITConfig(ADC1_IT_TypeDef ADC1_IT, FunctionalState NewState)
    197          {
   \                     ADC1_ITConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 BF00                  LDW       S:?w4, X
   \   000009 B700                  LD        S:?b10, A
    198          
    199              /* Check the parameters */
    200              assert_param(IS_ADC1_IT_OK(ADC1_IT));
   \   00000B A30020                CPW       X, #0x20
   \   00000E 270C                  JREQ      L:??CrossCallReturnLabel_16
   \   000010 A30010                CPW       X, #0x10
   \   000013 2707                  JREQ      L:??CrossCallReturnLabel_16
   \   000015 AE00C8                LDW       X, #0xc8
   \   000018 8D000000              CALLF     ?Subroutine1
    201              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_16:
   \   00001C 3D00                  TNZ       S:?b10
   \   00001E 2714                  JREQ      L:??ADC1_ITConfig_0
   \   000020 B600                  LD        A, S:?b10
   \   000022 A101                  CP        A, #0x1
   \   000024 2707                  JREQ      L:??CrossCallReturnLabel_17
   \   000026 AE00C9                LDW       X, #0xc9
   \   000029 8D000000              CALLF     ?Subroutine1
    202          
    203              if (NewState != DISABLE)
    204              {
    205                  /* Enable the ADC1 interrupts */
    206                  ADC1->CSR |= (uint8_t)ADC1_IT;
   \                     ??CrossCallReturnLabel_17:
   \   00002D B600                  LD        A, S:?b9
   \   00002F CA5400                OR        A, L:0x5400
   \   000032 2006                  JRA       ??ADC1_ITConfig_1
    207              }
    208              else  /* NewState == DISABLE */
    209              {
    210                  /* Disable the ADC1 interrupts */
    211                  ADC1->CSR &= (uint8_t)((uint16_t)~(uint16_t)ADC1_IT);
   \                     ??ADC1_ITConfig_0:
   \   000034 B600                  LD        A, S:?b9
   \   000036 43                    CPL       A
   \   000037 C45400                AND       A, L:0x5400
   \                     ??ADC1_ITConfig_1:
   \   00003A C75400                LD        L:0x5400, A
    212              }
    213          
    214          }
   \   00003D 320000                POP       S:?b10
   \   000040 AC000000              JPF       L:?epilogue_w4
    215          
    216          /**
    217            * @brief  Configure the ADC1 prescaler division factor.
    218            * @param   ADC1_Prescaler: the selected precaler.
    219            * It can be one of the values of @ref ADC1_PresSel_TypeDef.
    220            * @retval None
    221            */

   \                                 In section .far_func.text, align 1
    222          void ADC1_PrescalerConfig(ADC1_PresSel_TypeDef ADC1_Prescaler)
    223          {
   \                     ADC1_PrescalerConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    224          
    225              /* Check the parameter */
    226              assert_param(IS_ADC1_PRESSEL_OK(ADC1_Prescaler));
   \   000005 2723                  JREQ      L:??CrossCallReturnLabel_15
   \   000007 A110                  CP        A, #0x10
   \   000009 271F                  JREQ      L:??CrossCallReturnLabel_15
   \   00000B A120                  CP        A, #0x20
   \   00000D 271B                  JREQ      L:??CrossCallReturnLabel_15
   \   00000F A130                  CP        A, #0x30
   \   000011 2717                  JREQ      L:??CrossCallReturnLabel_15
   \   000013 A140                  CP        A, #0x40
   \   000015 2713                  JREQ      L:??CrossCallReturnLabel_15
   \   000017 A150                  CP        A, #0x50
   \   000019 270F                  JREQ      L:??CrossCallReturnLabel_15
   \   00001B A160                  CP        A, #0x60
   \   00001D 270B                  JREQ      L:??CrossCallReturnLabel_15
   \   00001F A170                  CP        A, #0x70
   \   000021 2707                  JREQ      L:??CrossCallReturnLabel_15
   \   000023 AE00E2                LDW       X, #0xe2
   \   000026 8D000000              CALLF     ?Subroutine1
    227          
    228              /* Clear the SPSEL bits */
    229              ADC1->CR1 &= (uint8_t)(~ADC1_CR1_SPSEL);
   \                     ??CrossCallReturnLabel_15:
   \   00002A C65401                LD        A, L:0x5401
   \   00002D A48F                  AND       A, #0x8f
   \   00002F C75401                LD        L:0x5401, A
    230              /* Select the prescaler division factor according to ADC1_PrescalerSelection values */
    231              ADC1->CR1 |= (uint8_t)(ADC1_Prescaler);
   \   000032 B600                  LD        A, S:?b8
   \   000034 CA5401                OR        A, L:0x5401
   \   000037 C75401                LD        L:0x5401, A
    232          
    233          }
   \   00003A 320000                POP       S:?b8
   \   00003D 87                    RETF
    234          
    235          
    236          /**
    237            * @brief  Enables or disables the ADC1 Schmitt Trigger on a selected channel.
    238            * @param   ADC1_SchmittTriggerChannel specifies the desired Channel.
    239            * It can be set of the values of @ref ADC1_SchmittTrigg_TypeDef.
    240            * @param   NewState specifies Channel new status.
    241            * can have one of the values of @ref FunctionalState.
    242            * @retval None
    243            */

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000 ABF8                  ADD       A, #0xf8
   \   000002                       REQUIRE ??Subroutine9_0
   \   000002                       ;               // Fall through to label ??Subroutine9_0

   \                                 In section .far_func.text, align 1
   \                     ??Subroutine9_0:
   \   000000 8D000000              CALLF     ??Subroutine10_0
   \                     ??CrossCallReturnLabel_48:
   \   000004 3D00                  TNZ       S:?b9
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ??Subroutine10_0:
   \   000000 5F                    CLRW      X
   \   000001 5C                    INCW      X
   \   000002 8D000000              CALLF     L:?sll16_x_x_a
   \   000006 9F                    LD        A, XL
   \   000007 87                    RETF

   \                                 In section .far_func.text, align 1
    244          void ADC1_SchmittTriggerConfig(ADC1_SchmittTrigg_TypeDef ADC1_SchmittTriggerChannel, FunctionalState NewState)
    245          {
   \                     ADC1_SchmittTriggerConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    246          
    247              /* Check the parameters */
    248              assert_param(IS_ADC1_SCHMITTTRIG_OK(ADC1_SchmittTriggerChannel));
   \   000009 2733                  JREQ      L:??CrossCallReturnLabel_13
   \   00000B A101                  CP        A, #0x1
   \   00000D 272F                  JREQ      L:??CrossCallReturnLabel_13
   \   00000F A102                  CP        A, #0x2
   \   000011 272B                  JREQ      L:??CrossCallReturnLabel_13
   \   000013 A103                  CP        A, #0x3
   \   000015 2727                  JREQ      L:??CrossCallReturnLabel_13
   \   000017 A104                  CP        A, #0x4
   \   000019 2723                  JREQ      L:??CrossCallReturnLabel_13
   \   00001B A105                  CP        A, #0x5
   \   00001D 271F                  JREQ      L:??CrossCallReturnLabel_13
   \   00001F A106                  CP        A, #0x6
   \   000021 271B                  JREQ      L:??CrossCallReturnLabel_13
   \   000023 A107                  CP        A, #0x7
   \   000025 2717                  JREQ      L:??CrossCallReturnLabel_13
   \   000027 A108                  CP        A, #0x8
   \   000029 2713                  JREQ      L:??CrossCallReturnLabel_13
   \   00002B A10C                  CP        A, #0xc
   \   00002D 270F                  JREQ      L:??CrossCallReturnLabel_13
   \   00002F A1FF                  CP        A, #0xff
   \   000031 270B                  JREQ      L:??CrossCallReturnLabel_13
   \   000033 A109                  CP        A, #0x9
   \   000035 2707                  JREQ      L:??CrossCallReturnLabel_13
   \   000037 AE00F8                LDW       X, #0xf8
   \   00003A 8D000000              CALLF     ?Subroutine1
    249              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_13:
   \   00003E 3D00                  TNZ       S:?b9
   \   000040 270D                  JREQ      L:??CrossCallReturnLabel_14
   \   000042 B600                  LD        A, S:?b9
   \   000044 A101                  CP        A, #0x1
   \   000046 2707                  JREQ      L:??CrossCallReturnLabel_14
   \   000048 AE00F9                LDW       X, #0xf9
   \   00004B 8D000000              CALLF     ?Subroutine1
    250          
    251              if (ADC1_SchmittTriggerChannel == ADC1_SCHMITTTRIG_ALL)
   \                     ??CrossCallReturnLabel_14:
   \   00004F B600                  LD        A, S:?b8
   \   000051 A1FF                  CP        A, #0xff
   \   000053 2628                  JRNE      L:??ADC1_SchmittTriggerConfig_0
    252              {
    253                  if (NewState != DISABLE)
   \   000055 3D00                  TNZ       S:?b9
   \   000057 2712                  JREQ      L:??ADC1_SchmittTriggerConfig_1
    254                  {
    255                      ADC1->TDRL &= (uint8_t)0x0;
   \   000059 C65407                LD        A, L:0x5407
   \   00005C 725F5407              CLR       L:0x5407
    256                      ADC1->TDRH &= (uint8_t)0x0;
   \   000060 C65406                LD        A, L:0x5406
   \   000063 725F5406              CLR       L:0x5406
   \   000067 AC000000              JPF       L:?epilogue_w4
    257                  }
    258                  else /* NewState == DISABLE */
    259                  {
    260                      ADC1->TDRL |= (uint8_t)0xFF;
   \                     ??ADC1_SchmittTriggerConfig_1:
   \   00006B C65407                LD        A, L:0x5407
   \   00006E 35FF5407              MOV       L:0x5407, #0xff
    261                      ADC1->TDRH |= (uint8_t)0xFF;
   \   000072 C65406                LD        A, L:0x5406
   \   000075 35FF5406              MOV       L:0x5406, #0xff
   \   000079 AC000000              JPF       L:?epilogue_w4
    262                  }
    263              }
    264              else if (ADC1_SchmittTriggerChannel < ADC1_SCHMITTTRIG_CHANNEL8)
   \                     ??ADC1_SchmittTriggerConfig_0:
   \   00007D A108                  CP        A, #0x8
   \   00007F 2416                  JRNC      L:??ADC1_SchmittTriggerConfig_2
   \   000081 8D000000              CALLF     ??Subroutine9_0
   \                     ??CrossCallReturnLabel_41:
   \   000085 270B                  JREQ      L:??ADC1_SchmittTriggerConfig_3
    265              {
    266                  if (NewState != DISABLE)
    267                  {
    268                      ADC1->TDRL &= (uint8_t)(~(uint8_t)((uint8_t)0x01 << (uint8_t)ADC1_SchmittTriggerChannel));
   \   000087 43                    CPL       A
   \   000088 C45407                AND       A, L:0x5407
   \                     ??ADC1_SchmittTriggerConfig_4:
   \   00008B C75407                LD        L:0x5407, A
   \   00008E AC000000              JPF       L:?epilogue_w4
    269                  }
    270                  else /* NewState == DISABLE */
    271                  {
    272                      ADC1->TDRL |= (uint8_t)((uint8_t)0x01 << (uint8_t)ADC1_SchmittTriggerChannel);
   \                     ??ADC1_SchmittTriggerConfig_3:
   \   000092 CA5407                OR        A, L:0x5407
   \   000095 20F4                  JRA       ??ADC1_SchmittTriggerConfig_4
    273                  }
    274              }
    275              else /* ADC1_SchmittTriggerChannel >= ADC1_SCHMITTTRIG_CHANNEL8 */
    276              {
    277                  if (NewState != DISABLE)
   \                     ??ADC1_SchmittTriggerConfig_2:
   \   000097 8D000000              CALLF     ?Subroutine6
   \                     ??CrossCallReturnLabel_43:
   \   00009B 2706                  JREQ      L:??ADC1_SchmittTriggerConfig_5
    278                  {
    279                      ADC1->TDRH &= (uint8_t)(~(uint8_t)((uint8_t)0x01 << ((uint8_t)ADC1_SchmittTriggerChannel - (uint8_t)8)));
   \   00009D 43                    CPL       A
   \   00009E C45406                AND       A, L:0x5406
   \   0000A1 2003                  JRA       ??ADC1_SchmittTriggerConfig_6
    280                  }
    281                  else /* NewState == DISABLE */
    282                  {
    283                      ADC1->TDRH |= (uint8_t)((uint8_t)0x01 << ((uint8_t)ADC1_SchmittTriggerChannel - (uint8_t)8));
   \                     ??ADC1_SchmittTriggerConfig_5:
   \   0000A3 CA5406                OR        A, L:0x5406
   \                     ??ADC1_SchmittTriggerConfig_6:
   \   0000A6 C75406                LD        L:0x5406, A
    284                  }
    285              }
    286          
    287          }
   \   0000A9 AC000000              JPF       L:?epilogue_w4
    288          
    289          
    290          /**
    291            * @brief  Configure the ADC1 conversion on selected channel.
    292            * @param   ADC1_ConversionMode Specifies the conversion type.
    293            * It can be set of the values of @ref ADC1_ConvMode_TypeDef
    294            * @param   ADC1_Channel specifies the ADC1 Channel.
    295            * It can be set of the values of @ref ADC1_Channel_TypeDef
    296            * @param   ADC1_Align specifies the conerted data alignment.
    297            * It can be set of the values of @ref ADC1_Align_TypeDef
    298            * @retval None
    299            */

   \                                 In section .far_func.text, align 1
    300          void ADC1_ConversionConfig(ADC1_ConvMode_TypeDef ADC1_ConversionMode, ADC1_Channel_TypeDef ADC1_Channel, ADC1_Align_TypeDef ADC1_Align)
    301          {
   \                     ADC1_ConversionConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 B700                  LD        S:?b8, A
   \   000009 450000                MOV       S:?b9, S:?b0
   \   00000C 450000                MOV       S:?b10, S:?b1
    302          
    303              /* Check the parameters */
    304              assert_param(IS_ADC1_CONVERSIONMODE_OK(ADC1_ConversionMode));
   \   00000F 270B                  JREQ      L:??CrossCallReturnLabel_10
   \   000011 A101                  CP        A, #0x1
   \   000013 2707                  JREQ      L:??CrossCallReturnLabel_10
   \   000015 AE0130                LDW       X, #0x130
   \   000018 8D000000              CALLF     ?Subroutine1
    305              assert_param(IS_ADC1_CHANNEL_OK(ADC1_Channel));
   \                     ??CrossCallReturnLabel_10:
   \   00001C 3D00                  TNZ       S:?b9
   \   00001E 2731                  JREQ      L:??CrossCallReturnLabel_11
   \   000020 B600                  LD        A, S:?b9
   \   000022 A101                  CP        A, #0x1
   \   000024 272B                  JREQ      L:??CrossCallReturnLabel_11
   \   000026 A102                  CP        A, #0x2
   \   000028 2727                  JREQ      L:??CrossCallReturnLabel_11
   \   00002A A103                  CP        A, #0x3
   \   00002C 2723                  JREQ      L:??CrossCallReturnLabel_11
   \   00002E A104                  CP        A, #0x4
   \   000030 271F                  JREQ      L:??CrossCallReturnLabel_11
   \   000032 A105                  CP        A, #0x5
   \   000034 271B                  JREQ      L:??CrossCallReturnLabel_11
   \   000036 A106                  CP        A, #0x6
   \   000038 2717                  JREQ      L:??CrossCallReturnLabel_11
   \   00003A A107                  CP        A, #0x7
   \   00003C 2713                  JREQ      L:??CrossCallReturnLabel_11
   \   00003E A108                  CP        A, #0x8
   \   000040 270F                  JREQ      L:??CrossCallReturnLabel_11
   \   000042 A10C                  CP        A, #0xc
   \   000044 270B                  JREQ      L:??CrossCallReturnLabel_11
   \   000046 A109                  CP        A, #0x9
   \   000048 2707                  JREQ      L:??CrossCallReturnLabel_11
   \   00004A AE0131                LDW       X, #0x131
   \   00004D 8D000000              CALLF     ?Subroutine1
    306              assert_param(IS_ADC1_ALIGN_OK(ADC1_Align));
   \                     ??CrossCallReturnLabel_11:
   \   000051 3D00                  TNZ       S:?b10
   \   000053 270D                  JREQ      L:??CrossCallReturnLabel_12
   \   000055 B600                  LD        A, S:?b10
   \   000057 A108                  CP        A, #0x8
   \   000059 2707                  JREQ      L:??CrossCallReturnLabel_12
   \   00005B AE0132                LDW       X, #0x132
   \   00005E 8D000000              CALLF     ?Subroutine1
    307          
    308              /* Clear the align bit */
    309              ADC1->CR2 &= (uint8_t)(~ADC1_CR2_ALIGN);
   \                     ??CrossCallReturnLabel_12:
   \   000062 72175402              BRES      L:0x5402, #0x3
    310              /* Configure the data alignment */
    311              ADC1->CR2 |= (uint8_t)(ADC1_Align);
   \   000066 B600                  LD        A, S:?b10
   \   000068 CA5402                OR        A, L:0x5402
   \   00006B C75402                LD        L:0x5402, A
    312          
    313              if (ADC1_ConversionMode == ADC1_CONVERSIONMODE_CONTINUOUS)
   \   00006E B600                  LD        A, S:?b8
   \   000070 A101                  CP        A, #0x1
   \   000072 2606                  JRNE      L:??ADC1_ConversionConfig_0
    314              {
    315                  /* Set the continuous coversion mode */
    316                  ADC1->CR1 |= ADC1_CR1_CONT;
   \   000074 72125401              BSET      L:0x5401, #0x1
   \   000078 2004                  JRA       L:??ADC1_ConversionConfig_1
    317              }
    318              else /* ADC1_ConversionMode == ADC1_CONVERSIONMODE_SINGLE */
    319              {
    320                  /* Set the single conversion mode */
    321                  ADC1->CR1 &= (uint8_t)(~ADC1_CR1_CONT);
   \                     ??ADC1_ConversionConfig_0:
   \   00007A 72135401              BRES      L:0x5401, #0x1
    322              }
    323          
    324              /* Clear the ADC1 channels */
    325              ADC1->CSR &= (uint8_t)(~ADC1_CSR_CH);
   \                     ??ADC1_ConversionConfig_1:
   \   00007E C65400                LD        A, L:0x5400
   \   000081 A4F0                  AND       A, #0xf0
   \   000083 C75400                LD        L:0x5400, A
    326              /* Select the ADC1 channel */
    327              ADC1->CSR |= (uint8_t)(ADC1_Channel);
   \   000086 B600                  LD        A, S:?b9
   \   000088 CA5400                OR        A, L:0x5400
   \   00008B C75400                LD        L:0x5400, A
    328          
    329          }
   \   00008E 320000                POP       S:?b10
   \   000091 AC000000              JPF       L:?epilogue_w4
    330          
    331          
    332          /**
    333            * @brief  Configure the ADC1 conversion on external trigger event.
    334            * @par Full description:
    335            * The selected external trigger evant can be enabled or disabled.
    336            * @param   ADC1_ExtTrigger to select the External trigger event.
    337            * can have one of the values of @ref ADC1_ExtTrig_TypeDef.
    338            * @param   NewState to enable/disable the selected external trigger
    339            * can have one of the values of @ref FunctionalState.
    340            * @retval None
    341            */

   \                                 In section .far_func.text, align 1
    342          void ADC1_ExternalTriggerConfig(ADC1_ExtTrig_TypeDef ADC1_ExtTrigger, FunctionalState NewState)
    343          {
   \                     ADC1_ExternalTriggerConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    344          
    345              /* Check the parameters */
    346              assert_param(IS_ADC1_EXTTRIG_OK(ADC1_ExtTrigger));
   \   000009 270B                  JREQ      L:??CrossCallReturnLabel_8
   \   00000B A110                  CP        A, #0x10
   \   00000D 2707                  JREQ      L:??CrossCallReturnLabel_8
   \   00000F AE015A                LDW       X, #0x15a
   \   000012 8D000000              CALLF     ?Subroutine1
    347              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_8:
   \   000016 3D00                  TNZ       S:?b9
   \   000018 270D                  JREQ      L:??CrossCallReturnLabel_9
   \   00001A B600                  LD        A, S:?b9
   \   00001C A101                  CP        A, #0x1
   \   00001E 2707                  JREQ      L:??CrossCallReturnLabel_9
   \   000020 AE015B                LDW       X, #0x15b
   \   000023 8D000000              CALLF     ?Subroutine1
    348          
    349              /* Clear the external trigger selection bits */
    350              ADC1->CR2 &= (uint8_t)(~ADC1_CR2_EXTSEL);
   \                     ??CrossCallReturnLabel_9:
   \   000027 C65402                LD        A, L:0x5402
   \   00002A A4CF                  AND       A, #0xcf
   \   00002C C75402                LD        L:0x5402, A
    351          
    352              if (NewState != DISABLE)
   \   00002F 3D00                  TNZ       S:?b9
   \   000031 2706                  JREQ      L:??ADC1_ExternalTriggerConfig_0
    353              {
    354                  /* Enable the selected external Trigger */
    355                  ADC1->CR2 |= (uint8_t)(ADC1_CR2_EXTTRIG);
   \   000033 721C5402              BSET      L:0x5402, #0x6
   \   000037 2004                  JRA       L:??ADC1_ExternalTriggerConfig_1
    356              }
    357              else /* NewState == DISABLE */
    358              {
    359                  /* Disable the selected external trigger */
    360                  ADC1->CR2 &= (uint8_t)(~ADC1_CR2_EXTTRIG);
   \                     ??ADC1_ExternalTriggerConfig_0:
   \   000039 721D5402              BRES      L:0x5402, #0x6
    361              }
    362          
    363              /* Set the selected external trigger */
    364              ADC1->CR2 |= (uint8_t)(ADC1_ExtTrigger);
   \                     ??ADC1_ExternalTriggerConfig_1:
   \   00003D B600                  LD        A, S:?b8
   \   00003F CA5402                OR        A, L:0x5402
   \   000042 C75402                LD        L:0x5402, A
    365          
    366          }
   \   000045 AC000000              JPF       L:?epilogue_w4
    367          
    368          
    369          /**
    370            * @brief  Start ADC1 conversion
    371            * @par Full description:
    372            * This function  triggers the start of conversion, after ADC1 configuration.
    373            * @param  None
    374            * @retval None
    375            * @par Required preconditions:
    376            * Enable the ADC1 peripheral before calling this function
    377            */

   \                                 In section .far_func.text, align 1
    378          void ADC1_StartConversion(void)
    379          {
    380              ADC1->CR1 |= ADC1_CR1_ADON;
   \                     ADC1_StartConversion:
   \   000000 72105401              BSET      L:0x5401, #0x0
    381          }
   \   000004 87                    RETF
    382          
    383          /**
    384            * @brief  Get one sample of measured signal.
    385            * @param  None
    386            * @retval ConversionValue:  value of the measured signal.
    387            * @par Required preconditions:
    388            * ADC1 conversion finished.
    389            */

   \                                 In section .far_func.text, align 1
    390          uint16_t ADC1_GetConversionValue(void)
    391          {
    392          
    393              uint16_t temph = 0;
    394              uint8_t templ = 0;
    395          
    396              if ((ADC1->CR2 & ADC1_CR2_ALIGN) != 0) /* Right alignment */
   \                     ADC1_GetConversionValue:
   \   000000 7207540219            BTJF      L:0x5402, #0x3, L:??ADC1_GetConversionValue_0
    397              {
    398                  /* Read LSB first */
    399                  templ = ADC1->DRL;
   \   000005 C65405                LD        A, L:0x5405
   \   000008 B700                  LD        S:?b0, A
    400                  /* Then read MSB */
    401                  temph = ADC1->DRH;
   \   00000A C65404                LD        A, L:0x5404
    402          
    403                  temph = (uint16_t)(templ | (uint16_t)(temph << (uint8_t)8));
   \   00000D 5F                    CLRW      X
   \   00000E 97                    LD        XL, A
   \   00000F 4F                    CLR       A
   \   000010 02                    RLWA      X, A
   \   000011 905F                  CLRW      Y
   \   000013 B600                  LD        A, S:?b0
   \   000015 61                    EXG       A, YL
   \   000016 BF00                  LDW       S:?w0, X
   \   000018 93                    LDW       X, Y
   \   000019 02                    RLWA      X, A
   \   00001A BA00                  OR        A, S:?b0
   \   00001C 201E                  JRA       ??ADC1_GetConversionValue_1
    404              }
    405              else /* Left alignment */
    406              {
    407                  /* Read MSB firts*/
    408                  temph = ADC1->DRH;
   \                     ??ADC1_GetConversionValue_0:
   \   00001E C65404                LD        A, L:0x5404
   \   000021 B700                  LD        S:?b1, A
    409                  /* Then read LSB */
    410                  templ = ADC1->DRL;
   \   000023 C65405                LD        A, L:0x5405
   \   000026 B700                  LD        S:?b0, A
    411          
    412                  temph = (uint16_t)((uint16_t)((uint16_t)templ << 6) | (uint16_t)((uint16_t)temph << 8));
   \   000028 5F                    CLRW      X
   \   000029 41                    EXG       A, XL
   \   00002A B600                  LD        A, S:?b1
   \   00002C 41                    EXG       A, XL
   \   00002D 4F                    CLR       A
   \   00002E 02                    RLWA      X, A
   \   00002F BF00                  LDW       S:?w1, X
   \   000031 5F                    CLRW      X
   \   000032 B600                  LD        A, S:?b0
   \   000034 41                    EXG       A, XL
   \   000035 8D000000              CALLF     L:?sll16_x_x_6
   \   000039 02                    RLWA      X, A
   \   00003A BA00                  OR        A, S:?b2
   \                     ??ADC1_GetConversionValue_1:
   \   00003C 01                    RRWA      X, A
    413              }
    414          
    415              return ((uint16_t)temph);
   \   00003D 87                    RETF
    416          
    417          }
    418          
    419          /**
    420            * @brief  Enables or disables the analog watchdog for the given channel.
    421            * @param   Channel specifies the desired Channel.
    422            * It can be set of the values of @ref ADC1_Channel_TypeDef.
    423            * @param   NewState specifies the analog watchdog new state.
    424            * can have one of the values of @ref FunctionalState.
    425            * @retval None
    426            */

   \                                 In section .far_func.text, align 1
    427          void ADC1_AWDChannelConfig(ADC1_Channel_TypeDef Channel, FunctionalState NewState)
    428          {
   \                     ADC1_AWDChannelConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    429              /* Check the parameters */
    430              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000009 3D00                  TNZ       S:?b9
   \   00000B 270D                  JREQ      L:??CrossCallReturnLabel_7
   \   00000D B600                  LD        A, S:?b9
   \   00000F A101                  CP        A, #0x1
   \   000011 2707                  JREQ      L:??CrossCallReturnLabel_7
   \   000013 AE01AE                LDW       X, #0x1ae
   \   000016 8D000000              CALLF     ?Subroutine1
    431              assert_param(IS_ADC1_CHANNEL_OK(Channel));
   \                     ??CrossCallReturnLabel_7:
   \   00001A 3D00                  TNZ       S:?b8
   \   00001C 2733                  JREQ      L:??ADC1_AWDChannelConfig_0
   \   00001E B600                  LD        A, S:?b8
   \   000020 A101                  CP        A, #0x1
   \   000022 272D                  JREQ      L:??ADC1_AWDChannelConfig_0
   \   000024 A102                  CP        A, #0x2
   \   000026 2729                  JREQ      L:??ADC1_AWDChannelConfig_0
   \   000028 A103                  CP        A, #0x3
   \   00002A 2725                  JREQ      L:??ADC1_AWDChannelConfig_0
   \   00002C A104                  CP        A, #0x4
   \   00002E 2721                  JREQ      L:??ADC1_AWDChannelConfig_0
   \   000030 A105                  CP        A, #0x5
   \   000032 271D                  JREQ      L:??ADC1_AWDChannelConfig_0
   \   000034 A106                  CP        A, #0x6
   \   000036 2719                  JREQ      L:??ADC1_AWDChannelConfig_0
   \   000038 A107                  CP        A, #0x7
   \   00003A 2715                  JREQ      L:??ADC1_AWDChannelConfig_0
   \   00003C A108                  CP        A, #0x8
   \   00003E 272E                  JREQ      L:??ADC1_AWDChannelConfig_1
   \   000040 A10C                  CP        A, #0xc
   \   000042 272A                  JREQ      L:??ADC1_AWDChannelConfig_1
   \   000044 A109                  CP        A, #0x9
   \   000046 2726                  JREQ      L:??ADC1_AWDChannelConfig_1
   \   000048 AE01AF                LDW       X, #0x1af
   \   00004B 8D000000              CALLF     ?Subroutine0
    432          
    433              if (Channel < (uint8_t)8)
   \                     ??CrossCallReturnLabel_1:
   \   00004F 241D                  JRNC      L:??ADC1_AWDChannelConfig_1
   \                     ??ADC1_AWDChannelConfig_0:
   \   000051 5F                    CLRW      X
   \   000052 5C                    INCW      X
   \   000053 B600                  LD        A, S:?b8
   \   000055 8D000000              CALLF     L:?sll16_x_x_a
   \   000059 9F                    LD        A, XL
   \   00005A 3D00                  TNZ       S:?b9
   \   00005C 270A                  JREQ      L:??ADC1_AWDChannelConfig_2
    434              {
    435                  if (NewState != DISABLE)
    436                  {
    437                      ADC1->AWCRL |= (uint8_t)((uint8_t)1 << Channel);
   \   00005E CA540F                OR        A, L:0x540f
   \                     ??ADC1_AWDChannelConfig_3:
   \   000061 C7540F                LD        L:0x540f, A
   \   000064 AC000000              JPF       L:?epilogue_w4
    438                  }
    439                  else /* NewState == DISABLE */
    440                  {
    441                      ADC1->AWCRL &= (uint8_t)~(uint8_t)((uint8_t)1 << Channel);
   \                     ??ADC1_AWDChannelConfig_2:
   \   000068 43                    CPL       A
   \   000069 C4540F                AND       A, L:0x540f
   \   00006C 20F3                  JRA       ??ADC1_AWDChannelConfig_3
    442                  }
    443              }
    444              else
    445              {
    446                  if (NewState != DISABLE)
   \                     ??ADC1_AWDChannelConfig_1:
   \   00006E 8D000000              CALLF     ?Subroutine6
   \                     ??CrossCallReturnLabel_42:
   \   000072 2705                  JREQ      L:??ADC1_AWDChannelConfig_4
    447                  {
    448                      ADC1->AWCRH |= (uint8_t)((uint8_t)1 << (Channel - (uint8_t)8));
   \   000074 CA540E                OR        A, L:0x540e
   \   000077 2004                  JRA       ??ADC1_AWDChannelConfig_5
    449                  }
    450                  else /* NewState == DISABLE */
    451                  {
    452                      ADC1->AWCRH &= (uint8_t)~(uint8_t)((uint8_t)1 << (uint8_t)(Channel - (uint8_t)8));
   \                     ??ADC1_AWDChannelConfig_4:
   \   000079 43                    CPL       A
   \   00007A C4540E                AND       A, L:0x540e
   \                     ??ADC1_AWDChannelConfig_5:
   \   00007D C7540E                LD        L:0x540e, A
    453                  }
    454              }
    455          }
   \   000080 AC000000              JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine0:
   \   000000 8D000000              CALLF     ?Subroutine8
   \                     ??CrossCallReturnLabel_40:
   \   000004 B600                  LD        A, S:?b8
   \   000006 A108                  CP        A, #0x8
   \   000008 87                    RETF
    456          
    457          /**
    458            * @brief  Sets the high threshold of the analog watchdog.
    459            * @param   Threshold specifies the high threshold value.
    460            * this value depends on the reference voltage range.
    461            * @retval None
    462            */

   \                                 In section .far_func.text, align 1
    463          void ADC1_SetHighThreshold(uint16_t Threshold)
    464          {
   \                     ADC1_SetHighThreshold:
   \   000000 9093                  LDW       Y, X
    465              ADC1->HTRH = (uint8_t)(Threshold >> (uint8_t)2);
   \   000002 54                    SRLW      X
   \   000003 54                    SRLW      X
   \   000004 9F                    LD        A, XL
   \   000005 C75408                LD        L:0x5408, A
    466              ADC1->HTRL = (uint8_t)Threshold;
   \   000008 909F                  LD        A, YL
   \   00000A C75409                LD        L:0x5409, A
    467          }
   \   00000D 87                    RETF
    468          
    469          /**
    470            * @brief  Sets the low threshold of the analog watchdog.
    471            * @param   Threshold specifies the low threshold value.
    472            * this value depends on the reference voltage range.
    473            * @retval None
    474            */

   \                                 In section .far_func.text, align 1
    475          void ADC1_SetLowThreshold(uint16_t Threshold)
    476          {
    477              ADC1->LTRL = (uint8_t)Threshold;
   \                     ADC1_SetLowThreshold:
   \   000000 9F                    LD        A, XL
   \   000001 C7540B                LD        L:0x540b, A
    478              ADC1->LTRH = (uint8_t)(Threshold >> (uint8_t)2);
   \   000004 54                    SRLW      X
   \   000005 54                    SRLW      X
   \   000006 9F                    LD        A, XL
   \   000007 C7540A                LD        L:0x540a, A
    479          }
   \   00000A 87                    RETF
    480          
    481          /**
    482            * @brief  Get one sample of measured signal.
    483            * @param   Buffer specifies the buffer to read.
    484            * @retval BufferValue:  value read from the given buffer.
    485            * @par Required preconditions:
    486            * ADC1 conversion finished.
    487            */

   \                                 In section .far_func.text, align 1
    488          uint16_t ADC1_GetBufferValue(uint8_t Buffer)
    489          {
   \                     ADC1_GetBufferValue:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    490          
    491              uint16_t temph = 0;
    492              uint8_t templ = 0;
    493          
    494              /* Check the parameters */
    495              assert_param(IS_ADC1_BUFFER_OK(Buffer));
   \   000005 A10A                  CP        A, #0xa
   \   000007 2507                  JRC       L:??CrossCallReturnLabel_6
   \   000009 AE01EF                LDW       X, #0x1ef
   \   00000C 8D000000              CALLF     ?Subroutine1
   \                     ??CrossCallReturnLabel_6:
   \   000010 B600                  LD        A, S:?b8
   \   000012 48                    SLL       A
   \   000013 905F                  CLRW      Y
   \   000015 9097                  LD        YL, A
   \   000017 93                    LDW       X, Y
   \   000018 1C53E0                ADDW      X, #0x53e0
   \   00001B 72A953E1              ADDW      Y, #0x53e1
   \   00001F F6                    LD        A, (X)
   \   000020 5F                    CLRW      X
   \   000021 97                    LD        XL, A
   \   000022 4F                    CLR       A
   \   000023 02                    RLWA      X, A
   \   000024 720754020B            BTJF      L:0x5402, #0x3, L:??ADC1_GetBufferValue_0
    496          
    497              if ((ADC1->CR2 & ADC1_CR2_ALIGN) != 0) /* Right alignment */
    498              {
    499                  /* Read LSB first */
    500                  templ = *(uint8_t*)(uint16_t)((uint16_t)ADC1_BaseAddress + (uint8_t)(Buffer << 1) + 1);
    501                  /* Then read MSB */
    502                  temph = *(uint8_t*)(uint16_t)((uint16_t)ADC1_BaseAddress + (uint8_t)(Buffer << 1));
    503          
    504                  temph = (uint16_t)(templ | (uint16_t)(temph << (uint8_t)8));
   \   000029 90F6                  LD        A, (Y)
   \   00002B 905F                  CLRW      Y
   \   00002D 9097                  LD        YL, A
   \   00002F BF00                  LDW       S:?w0, X
   \   000031 93                    LDW       X, Y
   \   000032 200A                  JRA       ??ADC1_GetBufferValue_1
    505              }
    506              else /* Left alignment */
    507              {
    508                  /* Read MSB firts*/
    509                  temph = *(uint8_t*)(uint16_t)((uint16_t)ADC1_BaseAddress + (uint8_t)(Buffer << 1));
    510                  /* Then read LSB */
    511                  templ = *(uint8_t*)(uint16_t)((uint16_t)ADC1_BaseAddress + (uint8_t)(Buffer << 1) + 1);
    512          
    513                  temph = (uint16_t)((uint16_t)((uint16_t)templ << 6) | (uint16_t)(temph << 8));
   \                     ??ADC1_GetBufferValue_0:
   \   000034 BF00                  LDW       S:?w0, X
   \   000036 90F6                  LD        A, (Y)
   \   000038 5F                    CLRW      X
   \   000039 97                    LD        XL, A
   \   00003A 8D000000              CALLF     L:?sll16_x_x_6
   \                     ??ADC1_GetBufferValue_1:
   \   00003E 02                    RLWA      X, A
   \   00003F BA00                  OR        A, S:?b0
   \   000041 01                    RRWA      X, A
    514              }
    515          
    516              return ((uint16_t)temph);
   \   000042 320000                POP       S:?b8
   \   000045 87                    RETF
    517          
    518          }
    519          
    520          /**
    521            * @brief  Checks the specified analog watchdog channel status.
    522            * @param   Channel: specify the channel of which to check the analog watchdog
    523            * can be one of the values of @ref ADC1_Channel_TypeDef.
    524            * @retval FlagStatus Status of the analog watchdog.
    525            */

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000 ABF8                  ADD       A, #0xf8
   \   000002                       REQUIRE ??Subroutine10_0
   \   000002                       ;               // Fall through to label ??Subroutine10_0

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine3:
   \   000000 8D000000              CALLF     ?Subroutine7
   \                     ??CrossCallReturnLabel_46:
   \   000004 C4540C                AND       A, L:0x540c
   \   000007 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine2:
   \   000000 8D000000              CALLF     ??Subroutine10_0
   \                     ??CrossCallReturnLabel_44:
   \   000004 C4540D                AND       A, L:0x540d
   \   000007 87                    RETF

   \                                 In section .far_func.text, align 1
    526          FlagStatus ADC1_GetAWDChannelStatus(ADC1_Channel_TypeDef Channel)
    527          {
   \                     ADC1_GetAWDChannelStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    528              uint8_t status = 0;
    529          
    530              /* Check the parameters */
    531              assert_param(IS_ADC1_CHANNEL_OK(Channel));
   \   000005 2731                  JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000007 A101                  CP        A, #0x1
   \   000009 272D                  JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   00000B A102                  CP        A, #0x2
   \   00000D 2729                  JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   00000F A103                  CP        A, #0x3
   \   000011 2725                  JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000013 A104                  CP        A, #0x4
   \   000015 2721                  JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000017 A105                  CP        A, #0x5
   \   000019 271D                  JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   00001B A106                  CP        A, #0x6
   \   00001D 2719                  JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   00001F A107                  CP        A, #0x7
   \   000021 2715                  JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000023 A108                  CP        A, #0x8
   \   000025 2717                  JREQ      L:??ADC1_GetAWDChannelStatus_1
   \   000027 A10C                  CP        A, #0xc
   \   000029 2713                  JREQ      L:??ADC1_GetAWDChannelStatus_1
   \   00002B A109                  CP        A, #0x9
   \   00002D 270F                  JREQ      L:??ADC1_GetAWDChannelStatus_1
   \   00002F AE0213                LDW       X, #0x213
   \   000032 8D000000              CALLF     ?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   000036 2406                  JRNC      L:??ADC1_GetAWDChannelStatus_1
    532          
    533              if (Channel < (uint8_t)8)
    534              {
    535                  status = (uint8_t)(ADC1->AWSRL & (uint8_t)((uint8_t)1 << Channel));
   \                     ??ADC1_GetAWDChannelStatus_0:
   \   000038 8D000000              CALLF     ?Subroutine2
    536              }
   \                     ??CrossCallReturnLabel_31:
   \   00003C 2004                  JRA       L:??CrossCallReturnLabel_34
    537              else /* Channel = 8 | 9 */
    538              {
    539                  status = (uint8_t)(ADC1->AWSRH & (uint8_t)((uint8_t)1 << (Channel - (uint8_t)8)));
   \                     ??ADC1_GetAWDChannelStatus_1:
   \   00003E 8D000000              CALLF     ?Subroutine3
    540              }
    541          
    542              return ((FlagStatus)status);
   \                     ??CrossCallReturnLabel_34:
   \   000042 320000                POP       S:?b8
   \   000045 87                    RETF
    543          }
    544          
    545          /**
    546            * @brief  Checks the specified ADC1 flag status.
    547            * @param   Flag: ADC1 flag.
    548            * can be one of the values of @ref ADC1_Flag_TypeDef.
    549            * @retval FlagStatus Status of the ADC1 flag.
    550            */

   \                                 In section .far_func.text, align 1
    551          FlagStatus ADC1_GetFlagStatus(ADC1_Flag_TypeDef Flag)
    552          {
   \                     ADC1_GetFlagStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    553              uint8_t flagstatus = 0;
    554              uint8_t temp = 0;
    555          
    556              /* Check the parameters */
    557              assert_param(IS_ADC1_FLAG_OK(Flag));
   \   000005 A180                  CP        A, #0x80
   \   000007 2737                  JREQ      L:??CrossCallReturnLabel_5
   \   000009 A141                  CP        A, #0x41
   \   00000B 2733                  JREQ      L:??CrossCallReturnLabel_5
   \   00000D A140                  CP        A, #0x40
   \   00000F 272F                  JREQ      L:??CrossCallReturnLabel_5
   \   000011 A110                  CP        A, #0x10
   \   000013 272B                  JREQ      L:??CrossCallReturnLabel_5
   \   000015 A111                  CP        A, #0x11
   \   000017 2727                  JREQ      L:??CrossCallReturnLabel_5
   \   000019 A112                  CP        A, #0x12
   \   00001B 2723                  JREQ      L:??CrossCallReturnLabel_5
   \   00001D A113                  CP        A, #0x13
   \   00001F 271F                  JREQ      L:??CrossCallReturnLabel_5
   \   000021 A114                  CP        A, #0x14
   \   000023 271B                  JREQ      L:??CrossCallReturnLabel_5
   \   000025 A115                  CP        A, #0x15
   \   000027 2717                  JREQ      L:??CrossCallReturnLabel_5
   \   000029 A116                  CP        A, #0x16
   \   00002B 2713                  JREQ      L:??CrossCallReturnLabel_5
   \   00002D A117                  CP        A, #0x17
   \   00002F 270F                  JREQ      L:??CrossCallReturnLabel_5
   \   000031 A118                  CP        A, #0x18
   \   000033 270B                  JREQ      L:??CrossCallReturnLabel_5
   \   000035 A119                  CP        A, #0x19
   \   000037 2707                  JREQ      L:??CrossCallReturnLabel_5
   \   000039 AE022D                LDW       X, #0x22d
   \   00003C 8D000000              CALLF     ?Subroutine1
    558          
    559              if ((Flag & 0x0F) == 0x01)
   \                     ??CrossCallReturnLabel_5:
   \   000040 B600                  LD        A, S:?b8
   \   000042 A40F                  AND       A, #0xf
   \   000044 B700                  LD        S:?b0, A
   \   000046 A101                  CP        A, #0x1
   \   000048 2607                  JRNE      L:??ADC1_GetFlagStatus_0
    560              {
    561                  /* Get OVR flag status */
    562                  flagstatus = (uint8_t)(ADC1->CR3 & ADC1_CR3_OVR);
   \   00004A C65403                LD        A, L:0x5403
   \   00004D A440                  AND       A, #0x40
   \   00004F 201F                  JRA       L:??ADC1_GetFlagStatus_1
    563              }
    564              else if ((Flag & 0xF0) == 0x10)
   \                     ??ADC1_GetFlagStatus_0:
   \   000051 B600                  LD        A, S:?b8
   \   000053 A4F0                  AND       A, #0xf0
   \   000055 A110                  CP        A, #0x10
   \   000057 2612                  JRNE      L:??ADC1_GetFlagStatus_2
    565              {
    566                  /* Get analog watchdog channel status */
    567                  temp = (uint8_t)(Flag & (uint8_t)0x0F);
    568                  if (temp < 8)
   \   000059 B600                  LD        A, S:?b0
   \   00005B A108                  CP        A, #0x8
   \   00005D 2406                  JRNC      L:??ADC1_GetFlagStatus_3
    569                  {
    570                      flagstatus = (uint8_t)(ADC1->AWSRL & (uint8_t)((uint8_t)1 << temp));
   \   00005F 8D000000              CALLF     ?Subroutine2
    571                  }
   \                     ??CrossCallReturnLabel_30:
   \   000063 200B                  JRA       L:??ADC1_GetFlagStatus_1
    572                  else
    573                  {
    574                      flagstatus = (uint8_t)(ADC1->AWSRH & (uint8_t)((uint8_t)1 << (temp - 8)));
   \                     ??ADC1_GetFlagStatus_3:
   \   000065 8D000000              CALLF     ?Subroutine3
    575                  }
    576              }
   \                     ??CrossCallReturnLabel_33:
   \   000069 2005                  JRA       L:??ADC1_GetFlagStatus_1
    577              else  /* Get EOC | AWD flag status */
    578              {
    579                  flagstatus = (uint8_t)(ADC1->CSR & Flag);
   \                     ??ADC1_GetFlagStatus_2:
   \   00006B B600                  LD        A, S:?b8
   \   00006D C45400                AND       A, L:0x5400
    580              }
    581              return ((FlagStatus)flagstatus);
   \                     ??ADC1_GetFlagStatus_1:
   \   000070 320000                POP       S:?b8
   \   000073 87                    RETF
    582          
    583          }
    584          
    585          /**
    586            * @brief  Clear the specified ADC1 Flag.
    587            * @param   Flag: ADC1 flag.
    588            * can be one of the values of @ref ADC1_Flag_TypeDef.
    589            * @retval None
    590            */

   \                                 In section .far_func.text, align 1
    591          void ADC1_ClearFlag(ADC1_Flag_TypeDef Flag)
    592          {
   \                     ADC1_ClearFlag:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    593              uint8_t temp = 0;
    594          
    595              /* Check the parameters */
    596              assert_param(IS_ADC1_FLAG_OK(Flag));
   \   000005 A180                  CP        A, #0x80
   \   000007 2737                  JREQ      L:??CrossCallReturnLabel_4
   \   000009 A141                  CP        A, #0x41
   \   00000B 2733                  JREQ      L:??CrossCallReturnLabel_4
   \   00000D A140                  CP        A, #0x40
   \   00000F 272F                  JREQ      L:??CrossCallReturnLabel_4
   \   000011 A110                  CP        A, #0x10
   \   000013 272B                  JREQ      L:??CrossCallReturnLabel_4
   \   000015 A111                  CP        A, #0x11
   \   000017 2727                  JREQ      L:??CrossCallReturnLabel_4
   \   000019 A112                  CP        A, #0x12
   \   00001B 2723                  JREQ      L:??CrossCallReturnLabel_4
   \   00001D A113                  CP        A, #0x13
   \   00001F 271F                  JREQ      L:??CrossCallReturnLabel_4
   \   000021 A114                  CP        A, #0x14
   \   000023 271B                  JREQ      L:??CrossCallReturnLabel_4
   \   000025 A115                  CP        A, #0x15
   \   000027 2717                  JREQ      L:??CrossCallReturnLabel_4
   \   000029 A116                  CP        A, #0x16
   \   00002B 2713                  JREQ      L:??CrossCallReturnLabel_4
   \   00002D A117                  CP        A, #0x17
   \   00002F 270F                  JREQ      L:??CrossCallReturnLabel_4
   \   000031 A118                  CP        A, #0x18
   \   000033 270B                  JREQ      L:??CrossCallReturnLabel_4
   \   000035 A119                  CP        A, #0x19
   \   000037 2707                  JREQ      L:??CrossCallReturnLabel_4
   \   000039 AE0254                LDW       X, #0x254
   \   00003C 8D000000              CALLF     ?Subroutine1
    597          
    598              if ((Flag & 0x0F) == 0x01)
   \                     ??CrossCallReturnLabel_4:
   \   000040 B600                  LD        A, S:?b8
   \   000042 A40F                  AND       A, #0xf
   \   000044 B700                  LD        S:?b0, A
   \   000046 A101                  CP        A, #0x1
   \   000048 2606                  JRNE      L:??ADC1_ClearFlag_0
    599              {
    600                  /* Clear OVR flag status */
    601                  ADC1->CR3 &= (uint8_t)(~ADC1_CR3_OVR);
   \   00004A 721D5403              BRES      L:0x5403, #0x6
   \   00004E 2024                  JRA       L:??ADC1_ClearFlag_1
    602              }
    603              else if ((Flag & 0xF0) == 0x10)
   \                     ??ADC1_ClearFlag_0:
   \   000050 B600                  LD        A, S:?b8
   \   000052 A4F0                  AND       A, #0xf0
   \   000054 A110                  CP        A, #0x10
   \   000056 2612                  JRNE      L:??ADC1_ClearFlag_2
    604              {
    605                  /* Clear analog watchdog channel status */
    606                  temp = (uint8_t)(Flag & (uint8_t)0x0F);
    607                  if (temp < 8)
   \   000058 B600                  LD        A, S:?b0
   \   00005A A108                  CP        A, #0x8
   \   00005C 2406                  JRNC      L:??ADC1_ClearFlag_3
    608                  {
    609                      ADC1->AWSRL &= (uint8_t)~(uint8_t)((uint8_t)1 << temp);
   \   00005E 8D000000              CALLF     ?Subroutine4
    610                  }
   \                     ??CrossCallReturnLabel_36:
   \   000062 2010                  JRA       L:??ADC1_ClearFlag_1
    611                  else
    612                  {
    613                      ADC1->AWSRH &= (uint8_t)~(uint8_t)((uint8_t)1 << (temp - 8));
   \                     ??ADC1_ClearFlag_3:
   \   000064 8D000000              CALLF     ?Subroutine5
    614                  }
    615              }
   \                     ??CrossCallReturnLabel_38:
   \   000068 200A                  JRA       L:??ADC1_ClearFlag_1
    616              else  /* Clear EOC | AWD flag status */
    617              {
    618                  ADC1->CSR &= (uint8_t) (~Flag);
   \                     ??ADC1_ClearFlag_2:
   \   00006A 3300                  CPL       S:?b8
   \   00006C B600                  LD        A, S:?b8
   \   00006E C45400                AND       A, L:0x5400
   \   000071 C75400                LD        L:0x5400, A
    619              }
    620          }
   \                     ??ADC1_ClearFlag_1:
   \   000074 320000                POP       S:?b8
   \   000077 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine5:
   \   000000 8D000000              CALLF     ?Subroutine7
   \                     ??CrossCallReturnLabel_47:
   \   000004 43                    CPL       A
   \   000005 C4540C                AND       A, L:0x540c
   \   000008 C7540C                LD        L:0x540c, A
   \   00000B 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine4:
   \   000000 8D000000              CALLF     ??Subroutine10_0
   \                     ??CrossCallReturnLabel_45:
   \   000004 43                    CPL       A
   \   000005 C4540D                AND       A, L:0x540d
   \   000008 C7540D                LD        L:0x540d, A
   \   00000B 87                    RETF
    621          
    622          /**
    623            * @brief  Returns the specified pending bit status
    624            * @param   ITPendingBit : the IT pending bit to check.
    625            * This parameter can be one of the following values:
    626            *    - ADC1_IT_AWD   : Analog WDG IT status
    627            *    - ADC1_IT_AWS0 : Analog channel 0 IT status
    628            *    - ADC1_IT_AWS1 : Analog channel 1 IT status
    629            *    - ADC1_IT_AWS2 : Analog channel 2 IT status
    630            *    - ADC1_IT_AWS3 : Analog channel 3 IT status
    631            *    - ADC1_IT_AWS4 : Analog channel 4 IT status
    632            *    - ADC1_IT_AWS5 : Analog channel 5 IT status
    633            *    - ADC1_IT_AWS6 : Analog channel 6 IT status
    634            *    - ADC1_IT_AWS7 : Analog channel 7 IT status
    635            *    - ADC1_IT_AWS8 : Analog channel 8 IT status
    636            *    - ADC1_IT_AWS9 : Analog channel 9 IT status
    637            *    - ADC1_IT_EOC    : EOC pending bit
    638            * @retval ITStatus: status of the specified pending bit.
    639            */

   \                                 In section .far_func.text, align 1
    640          ITStatus ADC1_GetITStatus(ADC1_IT_TypeDef ITPendingBit)
    641          {
   \                     ADC1_GetITStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    642              ITStatus itstatus = RESET;
    643              uint8_t temp = 0;
    644          
    645              /* Check the parameters */
    646              assert_param(IS_ADC1_ITPENDINGBIT_OK(ITPendingBit));
   \   000006 A30080                CPW       X, #0x80
   \   000009 2743                  JREQ      L:??CrossCallReturnLabel_3
   \   00000B A30140                CPW       X, #0x140
   \   00000E 273E                  JREQ      L:??CrossCallReturnLabel_3
   \   000010 A30110                CPW       X, #0x110
   \   000013 2739                  JREQ      L:??CrossCallReturnLabel_3
   \   000015 A30111                CPW       X, #0x111
   \   000018 2734                  JREQ      L:??CrossCallReturnLabel_3
   \   00001A A30112                CPW       X, #0x112
   \   00001D 272F                  JREQ      L:??CrossCallReturnLabel_3
   \   00001F A30113                CPW       X, #0x113
   \   000022 272A                  JREQ      L:??CrossCallReturnLabel_3
   \   000024 A30114                CPW       X, #0x114
   \   000027 2725                  JREQ      L:??CrossCallReturnLabel_3
   \   000029 A30115                CPW       X, #0x115
   \   00002C 2720                  JREQ      L:??CrossCallReturnLabel_3
   \   00002E A30116                CPW       X, #0x116
   \   000031 271B                  JREQ      L:??CrossCallReturnLabel_3
   \   000033 A30117                CPW       X, #0x117
   \   000036 2716                  JREQ      L:??CrossCallReturnLabel_3
   \   000038 A30118                CPW       X, #0x118
   \   00003B 2711                  JREQ      L:??CrossCallReturnLabel_3
   \   00003D A3011C                CPW       X, #0x11c
   \   000040 270C                  JREQ      L:??CrossCallReturnLabel_3
   \   000042 A30119                CPW       X, #0x119
   \   000045 2707                  JREQ      L:??CrossCallReturnLabel_3
   \   000047 AE0286                LDW       X, #0x286
   \   00004A 8D000000              CALLF     ?Subroutine1
    647          
    648              if (((uint16_t)ITPendingBit & 0xF0) == 0x10)
   \                     ??CrossCallReturnLabel_3:
   \   00004E B600                  LD        A, S:?b9
   \   000050 A4F0                  AND       A, #0xf0
   \   000052 A110                  CP        A, #0x10
   \   000054 2618                  JRNE      L:??ADC1_GetITStatus_0
    649              {
    650                  /* Get analog watchdog channel status */
    651                  temp = (uint8_t)((uint16_t)ITPendingBit & 0x0F);
   \   000056 B600                  LD        A, S:?b9
   \   000058 A40F                  AND       A, #0xf
    652                  if (temp < 8)
   \   00005A A108                  CP        A, #0x8
   \   00005C 2408                  JRNC      L:??ADC1_GetITStatus_1
    653                  {
    654                      itstatus = (ITStatus)(ADC1->AWSRL & (uint8_t)((uint8_t)1 << temp));
   \   00005E 8D000000              CALLF     ?Subroutine2
    655                  }
   \                     ??CrossCallReturnLabel_29:
   \   000062 AC000000              JPF       L:?epilogue_w4
    656                  else
    657                  {
    658                      itstatus = (ITStatus)(ADC1->AWSRH & (uint8_t)((uint8_t)1 << (temp - 8)));
   \                     ??ADC1_GetITStatus_1:
   \   000066 8D000000              CALLF     ?Subroutine3
    659                  }
    660              }
   \                     ??CrossCallReturnLabel_32:
   \   00006A AC000000              JPF       L:?epilogue_w4
    661              else  /* Get EOC | AWD flag status */
    662              {
    663                  itstatus = (ITStatus)(ADC1->CSR & (uint8_t)ITPendingBit);
   \                     ??ADC1_GetITStatus_0:
   \   00006E B600                  LD        A, S:?b9
   \   000070 C45400                AND       A, L:0x5400
    664              }
    665              return ((ITStatus)itstatus);
   \   000073 AC000000              JPF       L:?epilogue_w4
    666          
    667          }
    668          
    669          /**
    670            * @brief  Clear the ADC1 End of Conversion pending bit.
    671            * @param   ITPendingBit : the IT pending bit to clear.
    672            * This parameter can be one of the following values:
    673            *    - ADC1_IT_AWD   : Analog WDG IT status
    674            *    - ADC1_IT_AWS0 : Analog channel 0 IT status
    675            *    - ADC1_IT_AWS1 : Analog channel 1 IT status
    676            *    - ADC1_IT_AWS2 : Analog channel 2 IT status
    677            *    - ADC1_IT_AWS3 : Analog channel 3 IT status
    678            *    - ADC1_IT_AWS4 : Analog channel 4 IT status
    679            *    - ADC1_IT_AWS5 : Analog channel 5 IT status
    680            *    - ADC1_IT_AWS6 : Analog channel 6 IT status
    681            *    - ADC1_IT_AWS7 : Analog channel 7 IT status
    682            *    - ADC1_IT_AWS8 : Analog channel 8 IT status
    683            *    - ADC1_IT_AWS9 : Analog channel 9 IT status
    684            *    - ADC1_IT_EOC  : EOC pending bit
    685            * @retval None
    686            */

   \                                 In section .far_func.text, align 1
    687          void ADC1_ClearITPendingBit(ADC1_IT_TypeDef ITPendingBit)
    688          {
   \                     ADC1_ClearITPendingBit:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    689              uint8_t temp = 0;
    690          
    691              /* Check the parameters */
    692              assert_param(IS_ADC1_ITPENDINGBIT_OK(ITPendingBit));
   \   000006 A30080                CPW       X, #0x80
   \   000009 2743                  JREQ      L:??CrossCallReturnLabel_2
   \   00000B A30140                CPW       X, #0x140
   \   00000E 273E                  JREQ      L:??CrossCallReturnLabel_2
   \   000010 A30110                CPW       X, #0x110
   \   000013 2739                  JREQ      L:??CrossCallReturnLabel_2
   \   000015 A30111                CPW       X, #0x111
   \   000018 2734                  JREQ      L:??CrossCallReturnLabel_2
   \   00001A A30112                CPW       X, #0x112
   \   00001D 272F                  JREQ      L:??CrossCallReturnLabel_2
   \   00001F A30113                CPW       X, #0x113
   \   000022 272A                  JREQ      L:??CrossCallReturnLabel_2
   \   000024 A30114                CPW       X, #0x114
   \   000027 2725                  JREQ      L:??CrossCallReturnLabel_2
   \   000029 A30115                CPW       X, #0x115
   \   00002C 2720                  JREQ      L:??CrossCallReturnLabel_2
   \   00002E A30116                CPW       X, #0x116
   \   000031 271B                  JREQ      L:??CrossCallReturnLabel_2
   \   000033 A30117                CPW       X, #0x117
   \   000036 2716                  JREQ      L:??CrossCallReturnLabel_2
   \   000038 A30118                CPW       X, #0x118
   \   00003B 2711                  JREQ      L:??CrossCallReturnLabel_2
   \   00003D A3011C                CPW       X, #0x11c
   \   000040 270C                  JREQ      L:??CrossCallReturnLabel_2
   \   000042 A30119                CPW       X, #0x119
   \   000045 2707                  JREQ      L:??CrossCallReturnLabel_2
   \   000047 AE02B4                LDW       X, #0x2b4
   \   00004A 8D000000              CALLF     ?Subroutine1
    693          
    694              if (((uint16_t)ITPendingBit & 0xF0) == 0x10)
   \                     ??CrossCallReturnLabel_2:
   \   00004E B600                  LD        A, S:?b9
   \   000050 A4F0                  AND       A, #0xf0
   \   000052 A110                  CP        A, #0x10
   \   000054 2618                  JRNE      L:??ADC1_ClearITPendingBit_0
    695              {
    696                  /* Clear analog watchdog channel status */
    697                  temp = (uint8_t)((uint16_t)ITPendingBit & 0x0F);
   \   000056 B600                  LD        A, S:?b9
   \   000058 A40F                  AND       A, #0xf
    698                  if (temp < 8)
   \   00005A A108                  CP        A, #0x8
   \   00005C 2408                  JRNC      L:??ADC1_ClearITPendingBit_1
    699                  {
    700                      ADC1->AWSRL &= (uint8_t)~(uint8_t)((uint8_t)1 << temp);
   \   00005E 8D000000              CALLF     ?Subroutine4
    701                  }
   \                     ??CrossCallReturnLabel_35:
   \   000062 AC000000              JPF       L:?epilogue_w4
    702                  else
    703                  {
    704                      ADC1->AWSRH &= (uint8_t)~(uint8_t)((uint8_t)1 << (temp - 8));
   \                     ??ADC1_ClearITPendingBit_1:
   \   000066 8D000000              CALLF     ?Subroutine5
    705                  }
    706              }
   \                     ??CrossCallReturnLabel_37:
   \   00006A AC000000              JPF       L:?epilogue_w4
    707              else  /* Clear EOC | AWD flag status */
    708              {
    709                  ADC1->CSR &= (uint8_t)((uint16_t)~(uint16_t)ITPendingBit);
   \                     ??ADC1_ClearITPendingBit_0:
   \   00006E B600                  LD        A, S:?b9
   \   000070 43                    CPL       A
   \   000071 C45400                AND       A, L:0x5400
   \   000074 C75400                LD        L:0x5400, A
    710              }
    711          }
   \   000077 AC000000              JPF       L:?epilogue_w4

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\Users\\\\Administrato...">`:
   \   000000 433A5C557365          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \   000008 5C41646D696E          DC8 5CH, 41H, 64H, 6DH, 69H, 6EH, 69H, 73H
   \   000010 747261746F72          DC8 74H, 72H, 61H, 74H, 6FH, 72H, 5CH, 44H
   \   000018 65736B746F70          DC8 65H, 73H, 6BH, 74H, 6FH, 70H, 5CH, 73H
   \   000020 746D38733130          DC8 74H, 6DH, 38H, 73H, 31H, 30H, 35H, 6BH
   \   000028 2D636F6E7472          DC8 2DH, 63H, 6FH, 6EH, 74H, 72H, 6FH, 6CH
   \   000030 6C65725C4C69          DC8 6CH, 65H, 72H, 5CH, 4CH, 69H, 62H, 72H
   \   000038 61726965735C          DC8 61H, 72H, 69H, 65H, 73H, 5CH, 53H, 54H
   \   000040 4D38535F5374          DC8 4DH, 38H, 53H, 5FH, 53H, 74H, 64H, 50H
   \   000048 65726970685F          DC8 65H, 72H, 69H, 70H, 68H, 5FH, 44H, 72H
   \   000050 697665725C73          DC8 69H, 76H, 65H, 72H, 5CH, 73H, 72H, 63H
   \   000058 5C73746D3873          DC8 5CH, 73H, 74H, 6DH, 38H, 73H, 5FH, 61H
   \   000060 6463312E6300          DC8 64H, 63H, 31H, 2EH, 63H, 0
    712          
    713          /**
    714            * @}
    715            */
    716            
    717          /**
    718            * @}
    719            */
    720            
    721          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     ADC1_DeInit                                49
     ?Subroutine1                                5
     ?Subroutine8                               12
     ADC1_Init                                 307
     ADC1_Cmd                                   24
     ADC1_ScanModeCmd                           24
     ADC1_DataBufferCmd                         24
     ADC1_ITConfig                              68
     ADC1_PrescalerConfig                       62
     ?Subroutine6                                2
     ??Subroutine9_0                             7
     ??Subroutine10_0                            8
     ADC1_SchmittTriggerConfig                 173
     ADC1_ConversionConfig                     149
     ADC1_ExternalTriggerConfig                 73
     ADC1_StartConversion                        5
     ADC1_GetConversionValue                    62
     ADC1_AWDChannelConfig                     132
     ?Subroutine0                                9
     ADC1_SetHighThreshold                      14
     ADC1_SetLowThreshold                       11
     ADC1_GetBufferValue                        70
     ?Subroutine7                                2
     ?Subroutine3                                8
     ?Subroutine2                                8
     ADC1_GetAWDChannelStatus                   70
     ADC1_GetFlagStatus                        116
     ADC1_ClearFlag                            120
     ?Subroutine5                               12
     ?Subroutine4                               12
     ADC1_GetITStatus                          119
     ADC1_ClearITPendingBit                    123
     ?<Constant "C:\\Users\\Administrato...">  102

 
 1 880 bytes in section .far_func.text
   102 bytes in section .near.rodata
 
 1 880 bytes of CODE  memory
   102 bytes of CONST memory

Errors: none
Warnings: none
