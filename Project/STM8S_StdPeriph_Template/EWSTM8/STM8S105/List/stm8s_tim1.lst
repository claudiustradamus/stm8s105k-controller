###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             11/Sep/2013  20:03:39 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s_ #
#                    tim1.c                                                   #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s #
#                    _tim1.c" -e -Ohz --debug --code_model medium             #
#                    --data_model medium -o "C:\Documents and                 #
#                    Settings\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Obj\"       #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\stm8\LIB\dlstm8mmf.h" -D STM8S105 -lC      #
#                    "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\ST #
#                    M8S105\List\" -lA "C:\Documents and                      #
#                    Settings\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\List\" -I   #
#                    "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\.. #
#                    \" -I "C:\Documents and Settings\Administrator\Desktop\s #
#                    tm8s105k-controller\Project\STM8S_StdPeriph_Template\EWS #
#                    TM8\..\..\..\Libraries\STM8S_StdPeriph_Driver\inc\"      #
#                    --vregs 16                                               #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\STM #
#                    8S105\List\stm8s_tim1.lst                                #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\STM #
#                    8S105\Obj\stm8s_tim1.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\stm8s105k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s_tim1.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_tim1.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the TIM1 peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_tim1.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          static void TI1_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
     34                                 uint8_t TIM1_ICFilter);
     35          static void TI2_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
     36                                 uint8_t TIM1_ICFilter);
     37          static void TI3_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
     38                                 uint8_t TIM1_ICFilter);
     39          static void TI4_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
     40                                 uint8_t TIM1_ICFilter);
     41          
     42          /**
     43            * @addtogroup TIM1_Public_Functions
     44            * @{
     45            */
     46          
     47          /**
     48            * @brief  Deinitializes the TIM1 peripheral registers to their default reset values.
     49            * @param  None
     50            * @retval None
     51            */

   \                                 In section .far_func.text, align 1
     52          void TIM1_DeInit(void)
     53          {
     54              TIM1->CR1  = TIM1_CR1_RESET_VALUE;
   \                     TIM1_DeInit:
   \   000000 725F5250              CLR       L:0x5250
     55              TIM1->CR2  = TIM1_CR2_RESET_VALUE;
   \   000004 725F5251              CLR       L:0x5251
     56              TIM1->SMCR = TIM1_SMCR_RESET_VALUE;
   \   000008 725F5252              CLR       L:0x5252
     57              TIM1->ETR  = TIM1_ETR_RESET_VALUE;
   \   00000C 725F5253              CLR       L:0x5253
     58              TIM1->IER  = TIM1_IER_RESET_VALUE;
   \   000010 725F5254              CLR       L:0x5254
     59              TIM1->SR2  = TIM1_SR2_RESET_VALUE;
   \   000014 725F5256              CLR       L:0x5256
     60              /* Disable channels */
     61              TIM1->CCER1 = TIM1_CCER1_RESET_VALUE;
   \   000018 725F525C              CLR       L:0x525c
     62              TIM1->CCER2 = TIM1_CCER2_RESET_VALUE;
   \   00001C 725F525D              CLR       L:0x525d
     63              /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
     64              TIM1->CCMR1 = 0x01;
   \   000020 35015258              MOV       L:0x5258, #0x1
     65              TIM1->CCMR2 = 0x01;
   \   000024 35015259              MOV       L:0x5259, #0x1
     66              TIM1->CCMR3 = 0x01;
   \   000028 3501525A              MOV       L:0x525a, #0x1
     67              TIM1->CCMR4 = 0x01;
   \   00002C 3501525B              MOV       L:0x525b, #0x1
     68              /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
     69              TIM1->CCER1 = TIM1_CCER1_RESET_VALUE;
   \   000030 725F525C              CLR       L:0x525c
     70              TIM1->CCER2 = TIM1_CCER2_RESET_VALUE;
   \   000034 725F525D              CLR       L:0x525d
     71              TIM1->CCMR1 = TIM1_CCMR1_RESET_VALUE;
   \   000038 725F5258              CLR       L:0x5258
     72              TIM1->CCMR2 = TIM1_CCMR2_RESET_VALUE;
   \   00003C 725F5259              CLR       L:0x5259
     73              TIM1->CCMR3 = TIM1_CCMR3_RESET_VALUE;
   \   000040 725F525A              CLR       L:0x525a
     74              TIM1->CCMR4 = TIM1_CCMR4_RESET_VALUE;
   \   000044 725F525B              CLR       L:0x525b
     75              TIM1->CNTRH = TIM1_CNTRH_RESET_VALUE;
   \   000048 725F525E              CLR       L:0x525e
     76              TIM1->CNTRL = TIM1_CNTRL_RESET_VALUE;
   \   00004C 725F525F              CLR       L:0x525f
     77              TIM1->PSCRH = TIM1_PSCRH_RESET_VALUE;
   \   000050 725F5260              CLR       L:0x5260
     78              TIM1->PSCRL = TIM1_PSCRL_RESET_VALUE;
   \   000054 725F5261              CLR       L:0x5261
     79              TIM1->ARRH  = TIM1_ARRH_RESET_VALUE;
   \   000058 35FF5262              MOV       L:0x5262, #0xff
     80              TIM1->ARRL  = TIM1_ARRL_RESET_VALUE;
   \   00005C 35FF5263              MOV       L:0x5263, #0xff
     81              TIM1->CCR1H = TIM1_CCR1H_RESET_VALUE;
   \   000060 725F5265              CLR       L:0x5265
     82              TIM1->CCR1L = TIM1_CCR1L_RESET_VALUE;
   \   000064 725F5266              CLR       L:0x5266
     83              TIM1->CCR2H = TIM1_CCR2H_RESET_VALUE;
   \   000068 725F5267              CLR       L:0x5267
     84              TIM1->CCR2L = TIM1_CCR2L_RESET_VALUE;
   \   00006C 725F5268              CLR       L:0x5268
     85              TIM1->CCR3H = TIM1_CCR3H_RESET_VALUE;
   \   000070 725F5269              CLR       L:0x5269
     86              TIM1->CCR3L = TIM1_CCR3L_RESET_VALUE;
   \   000074 725F526A              CLR       L:0x526a
     87              TIM1->CCR4H = TIM1_CCR4H_RESET_VALUE;
   \   000078 725F526B              CLR       L:0x526b
     88              TIM1->CCR4L = TIM1_CCR4L_RESET_VALUE;
   \   00007C 725F526C              CLR       L:0x526c
     89              TIM1->OISR  = TIM1_OISR_RESET_VALUE;
   \   000080 725F526F              CLR       L:0x526f
     90              TIM1->EGR   = 0x01; /* TIM1_EGR_UG */
   \   000084 35015257              MOV       L:0x5257, #0x1
     91              TIM1->DTR   = TIM1_DTR_RESET_VALUE;
   \   000088 725F526E              CLR       L:0x526e
     92              TIM1->BKR   = TIM1_BKR_RESET_VALUE;
   \   00008C 725F526D              CLR       L:0x526d
     93              TIM1->RCR   = TIM1_RCR_RESET_VALUE;
   \   000090 725F5264              CLR       L:0x5264
     94              TIM1->SR1   = TIM1_SR1_RESET_VALUE;
   \   000094 725F5255              CLR       L:0x5255
     95          }
   \   000098 87                    RETF
     96          
     97          /**
     98            * @brief  Initializes the TIM1 Time Base Unit according to the specified parameters.
     99            * @param  TIM1_Prescaler specifies the Prescaler value.
    100            * @param  TIM1_CounterMode specifies the counter mode  from @ref TIM1_CounterMode_TypeDef .
    101            * @param  TIM1_Period specifies the Period value.
    102            * @param  TIM1_RepetitionCounter specifies the Repetition counter value
    103            * @retval None
    104            */

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 AE0000                LDW       X, #`?<Constant "C:\\\\Documents and Sett...">`
   \   000008 AC000000              JPF       assert_failed

   \                                 In section .far_func.text, align 1
    105          void TIM1_TimeBaseInit(uint16_t TIM1_Prescaler,
    106                                 TIM1_CounterMode_TypeDef TIM1_CounterMode,
    107                                 uint16_t TIM1_Period,
    108                                 uint8_t TIM1_RepetitionCounter)
    109          {
   \                     TIM1_TimeBaseInit:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 BF00                  LDW       S:?w5, X
   \   00000A B700                  LD        S:?b9, A
   \   00000C 90BF00                LDW       S:?w6, Y
   \   00000F 450000                MOV       S:?b8, S:?b0
    110          
    111              /* Check parameters */
    112              assert_param(IS_TIM1_COUNTER_MODE_OK(TIM1_CounterMode));
   \   000012 3D00                  TNZ       S:?b9
   \   000014 2717                  JREQ      L:??CrossCallReturnLabel_24
   \   000016 A110                  CP        A, #0x10
   \   000018 2713                  JREQ      L:??CrossCallReturnLabel_24
   \   00001A A120                  CP        A, #0x20
   \   00001C 270F                  JREQ      L:??CrossCallReturnLabel_24
   \   00001E A140                  CP        A, #0x40
   \   000020 270B                  JREQ      L:??CrossCallReturnLabel_24
   \   000022 A160                  CP        A, #0x60
   \   000024 2707                  JREQ      L:??CrossCallReturnLabel_24
   \   000026 AE0070                LDW       X, #0x70
   \   000029 8D000000              CALLF     ?Subroutine9
    113          
    114              /* Set the Autoreload value */
    115              TIM1->ARRH = (uint8_t)(TIM1_Period >> 8);
   \                     ??CrossCallReturnLabel_24:
   \   00002D BE00                  LDW       X, S:?w6
   \   00002F 4F                    CLR       A
   \   000030 01                    RRWA      X, A
   \   000031 9F                    LD        A, XL
   \   000032 C75262                LD        L:0x5262, A
    116              TIM1->ARRL = (uint8_t)(TIM1_Period);
   \   000035 B600                  LD        A, S:?b13
   \   000037 C75263                LD        L:0x5263, A
    117          
    118              /* Set the Prescaler value */
    119              TIM1->PSCRH = (uint8_t)(TIM1_Prescaler >> 8);
   \   00003A 8D000000              CALLF     ?Subroutine12
    120              TIM1->PSCRL = (uint8_t)(TIM1_Prescaler);
    121          
    122              /* Select the Counter Mode */
    123              TIM1->CR1 = (uint8_t)((uint8_t)(TIM1->CR1 & (uint8_t)(~(TIM1_CR1_CMS | TIM1_CR1_DIR)))
    124                                     | (uint8_t)(TIM1_CounterMode));
   \                     ??CrossCallReturnLabel_131:
   \   00003E C65250                LD        A, L:0x5250
   \   000041 A48F                  AND       A, #0x8f
   \   000043 BA00                  OR        A, S:?b9
   \   000045 C75250                LD        L:0x5250, A
    125          
    126              /* Set the Repetition Counter value */
    127              TIM1->RCR = TIM1_RepetitionCounter;
   \   000048 B600                  LD        A, S:?b8
   \   00004A C75264                LD        L:0x5264, A
    128          
    129          }
   \   00004D AC000000              JPF       L:?epilogue_l2_w6

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine12:
   \   000000 BE00                  LDW       X, S:?w5
   \   000002 4F                    CLR       A
   \   000003 01                    RRWA      X, A
   \   000004 9F                    LD        A, XL
   \   000005 C75260                LD        L:0x5260, A
   \   000008 B600                  LD        A, S:?b11
   \   00000A C75261                LD        L:0x5261, A
   \   00000D 87                    RETF
    130          
    131          /**
    132            * @brief  Initializes the TIM1 Channel1 according to the specified parameters.
    133            * @param  TIM1_OCMode specifies the Output Compare mode from 
    134            *         @ref TIM1_OCMode_TypeDef.
    135            * @param  TIM1_OutputState specifies the Output State from 
    136            *         @ref TIM1_OutputState_TypeDef.
    137            * @param  TIM1_OutputNState specifies the Complementary Output State 
    138            *         from @ref TIM1_OutputNState_TypeDef.
    139            * @param  TIM1_Pulse specifies the Pulse width value.
    140            * @param  TIM1_OCPolarity specifies the Output Compare Polarity from 
    141            *         @ref TIM1_OCPolarity_TypeDef.
    142            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare Polarity
    143            *         from @ref TIM1_OCNPolarity_TypeDef.
    144            * @param  TIM1_OCIdleState specifies the Output Compare Idle State from 
    145            *         @ref TIM1_OCIdleState_TypeDef.
    146            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle 
    147            *         State from @ref TIM1_OCIdleState_TypeDef.
    148            * @retval None
    149            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine13:
   \   000000 BA00                  OR        A, S:?b1
   \   000002 CA526F                OR        A, L:0x526f
   \   000005 C7526F                LD        L:0x526f, A
   \   000008 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine5:
   \   000000 B700                  LD        S:?b8, A
   \   000002 450000                MOV       S:?b14, S:?b0
   \   000005 450000                MOV       S:?b13, S:?b1
   \   000008 450000                MOV       S:?b12, S:?b2
   \   00000B 450000                MOV       S:?b9, S:?b3
   \   00000E 450000                MOV       S:?b10, S:?b4
   \   000011 450000                MOV       S:?b11, S:?b5
   \   000014 87                    RETF

   \                                 In section .far_func.text, align 1
    150          void TIM1_OC1Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    151                            TIM1_OutputState_TypeDef TIM1_OutputState,
    152                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    153                            uint16_t TIM1_Pulse,
    154                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    155                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    156                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    157                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    158          {
   \                     TIM1_OC1Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 3B0000                PUSH      S:?b14
   \   00000B 89                    PUSHW     X
   \   00000C 8D000000              CALLF     ?Subroutine5
    159              /* Check the parameters */
    160              assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
   \                     ??CrossCallReturnLabel_16:
   \   000010 271B                  JREQ      L:??CrossCallReturnLabel_31
   \   000012 A110                  CP        A, #0x10
   \   000014 2717                  JREQ      L:??CrossCallReturnLabel_31
   \   000016 A120                  CP        A, #0x20
   \   000018 2713                  JREQ      L:??CrossCallReturnLabel_31
   \   00001A A130                  CP        A, #0x30
   \   00001C 270F                  JREQ      L:??CrossCallReturnLabel_31
   \   00001E A160                  CP        A, #0x60
   \   000020 270B                  JREQ      L:??CrossCallReturnLabel_31
   \   000022 A170                  CP        A, #0x70
   \   000024 2707                  JREQ      L:??CrossCallReturnLabel_31
   \   000026 AE00A0                LDW       X, #0xa0
   \   000029 8D000000              CALLF     ?Subroutine9
    161              assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
   \                     ??CrossCallReturnLabel_31:
   \   00002D 3D00                  TNZ       S:?b14
   \   00002F 270D                  JREQ      L:??CrossCallReturnLabel_30
   \   000031 B600                  LD        A, S:?b14
   \   000033 A111                  CP        A, #0x11
   \   000035 2707                  JREQ      L:??CrossCallReturnLabel_30
   \   000037 AE00A1                LDW       X, #0xa1
   \   00003A 8D000000              CALLF     ?Subroutine9
    162              assert_param(IS_TIM1_OUTPUTN_STATE_OK(TIM1_OutputNState));
   \                     ??CrossCallReturnLabel_30:
   \   00003E 3D00                  TNZ       S:?b13
   \   000040 270D                  JREQ      L:??CrossCallReturnLabel_29
   \   000042 B600                  LD        A, S:?b13
   \   000044 A144                  CP        A, #0x44
   \   000046 2707                  JREQ      L:??CrossCallReturnLabel_29
   \   000048 AE00A2                LDW       X, #0xa2
   \   00004B 8D000000              CALLF     ?Subroutine9
    163              assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     ??CrossCallReturnLabel_29:
   \   00004F 3D00                  TNZ       S:?b12
   \   000051 270D                  JREQ      L:??CrossCallReturnLabel_28
   \   000053 B600                  LD        A, S:?b12
   \   000055 A122                  CP        A, #0x22
   \   000057 2707                  JREQ      L:??CrossCallReturnLabel_28
   \   000059 AE00A3                LDW       X, #0xa3
   \   00005C 8D000000              CALLF     ?Subroutine9
    164              assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     ??CrossCallReturnLabel_28:
   \   000060 3D00                  TNZ       S:?b9
   \   000062 270D                  JREQ      L:??CrossCallReturnLabel_27
   \   000064 B600                  LD        A, S:?b9
   \   000066 A188                  CP        A, #0x88
   \   000068 2707                  JREQ      L:??CrossCallReturnLabel_27
   \   00006A AE00A4                LDW       X, #0xa4
   \   00006D 8D000000              CALLF     ?Subroutine9
    165              assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
   \                     ??CrossCallReturnLabel_27:
   \   000071 B600                  LD        A, S:?b10
   \   000073 A155                  CP        A, #0x55
   \   000075 270B                  JREQ      L:??CrossCallReturnLabel_26
   \   000077 3D00                  TNZ       S:?b10
   \   000079 2707                  JREQ      L:??CrossCallReturnLabel_26
   \   00007B AE00A5                LDW       X, #0xa5
   \   00007E 8D000000              CALLF     ?Subroutine9
    166              assert_param(IS_TIM1_OCNIDLE_STATE_OK(TIM1_OCNIdleState));
   \                     ??CrossCallReturnLabel_26:
   \   000082 B600                  LD        A, S:?b11
   \   000084 A12A                  CP        A, #0x2a
   \   000086 270B                  JREQ      L:??CrossCallReturnLabel_25
   \   000088 3D00                  TNZ       S:?b11
   \   00008A 2707                  JREQ      L:??CrossCallReturnLabel_25
   \   00008C AE00A6                LDW       X, #0xa6
   \   00008F 8D000000              CALLF     ?Subroutine9
    167          
    168              /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , 
    169                 the Output N State, the Output Polarity & the Output N Polarity*/
    170              TIM1->CCER1 &= (uint8_t)(~( TIM1_CCER1_CC1E | TIM1_CCER1_CC1NE 
    171                                         | TIM1_CCER1_CC1P | TIM1_CCER1_CC1NP));
   \                     ??CrossCallReturnLabel_25:
   \   000093 C6525C                LD        A, L:0x525c
   \   000096 A4F0                  AND       A, #0xf0
   \   000098 C7525C                LD        L:0x525c, A
    172              /* Set the Output State & Set the Output N State & Set the Output Polarity &
    173                 Set the Output N Polarity */
    174            TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC1E)
    175                                               | (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC1NE))
    176                                     | (uint8_t)( (uint8_t)(TIM1_OCPolarity  & TIM1_CCER1_CC1P)
    177                                                  | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC1NP)));
   \   00009B 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_9:
   \   00009F CA525C                OR        A, L:0x525c
   \   0000A2 C7525C                LD        L:0x525c, A
    178          
    179              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    180              TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) | 
    181                                      (uint8_t)TIM1_OCMode);
   \   0000A5 8D000000              CALLF     ?Subroutine8
    182          
    183              /* Reset the Output Idle state & the Output N Idle state bits */
    184              TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS1 | TIM1_OISR_OIS1N));
   \                     ??CrossCallReturnLabel_23:
   \   0000A9 C6526F                LD        A, L:0x526f
   \   0000AC A4FC                  AND       A, #0xfc
   \   0000AE C7526F                LD        L:0x526f, A
    185              /* Set the Output Idle state & the Output N Idle state configuration */
    186              TIM1->OISR |= (uint8_t)((uint8_t)( TIM1_OCIdleState & TIM1_OISR_OIS1 ) | 
    187                                      (uint8_t)( TIM1_OCNIdleState & TIM1_OISR_OIS1N ));
   \   0000B1 B600                  LD        A, S:?b11
   \   0000B3 A402                  AND       A, #0x2
   \   0000B5 88                    PUSH      A
   \   0000B6 B600                  LD        A, S:?b10
   \   0000B8 A401                  AND       A, #0x1
   \   0000BA B700                  LD        S:?b1, A
   \   0000BC 84                    POP       A
   \   0000BD 8D000000              CALLF     ?Subroutine13
    188          
    189              /* Set the Pulse value */
    190              TIM1->CCR1H = (uint8_t)(TIM1_Pulse >> 8);
   \                     ??CrossCallReturnLabel_134:
   \   0000C1 1E01                  LDW       X, (0x1,SP)
   \   0000C3 4F                    CLR       A
   \   0000C4 01                    RRWA      X, A
   \   0000C5 9F                    LD        A, XL
   \   0000C6 C75265                LD        L:0x5265, A
    191              TIM1->CCR1L = (uint8_t)(TIM1_Pulse);
   \   0000C9 7B02                  LD        A, (0x2,SP)
   \   0000CB C75266                LD        L:0x5266, A
    192          }
   \   0000CE 5B02                  ADD       SP, #0x2
   \   0000D0 320000                POP       S:?b14
   \   0000D3 AC000000              JPF       L:?epilogue_l2_w6

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine8:
   \   000000 C65258                LD        A, L:0x5258
   \   000003 A48F                  AND       A, #0x8f
   \   000005 BA00                  OR        A, S:?b8
   \   000007 C75258                LD        L:0x5258, A
   \   00000A 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine2:
   \   000000 B600                  LD        A, S:?b13
   \   000002 A404                  AND       A, #0x4
   \   000004 88                    PUSH      A
   \   000005 B600                  LD        A, S:?b14
   \   000007 A401                  AND       A, #0x1
   \   000009 B700                  LD        S:?b1, A
   \   00000B 84                    POP       A
   \   00000C BA00                  OR        A, S:?b1
   \   00000E B700                  LD        S:?b0, A
   \   000010 B600                  LD        A, S:?b12
   \   000012 A402                  AND       A, #0x2
   \   000014 BA00                  OR        A, S:?b0
   \   000016 B700                  LD        S:?b0, A
   \   000018 B600                  LD        A, S:?b9
   \   00001A A408                  AND       A, #0x8
   \   00001C BA00                  OR        A, S:?b0
   \   00001E 87                    RETF
    193          
    194          /**
    195            * @brief  Initializes the TIM1 Channel2 according to the specified parameters.
    196            * @param  TIM1_OCMode specifies the Output Compare mode from
    197            *         @ref TIM1_OCMode_TypeDef.
    198            * @param  TIM1_OutputState specifies the Output State from 
    199            *         @ref TIM1_OutputState_TypeDef.
    200            * @param  TIM1_OutputNState specifies the Complementary Output State from 
    201            *         @ref TIM1_OutputNState_TypeDef.
    202            * @param  TIM1_Pulse specifies the Pulse width value.
    203            * @param  TIM1_OCPolarity specifies the Output Compare Polarity from 
    204            *         @ref TIM1_OCPolarity_TypeDef.
    205            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare Polarity
    206            *         from @ref TIM1_OCNPolarity_TypeDef.
    207            * @param  TIM1_OCIdleState specifies the Output Compare Idle State from 
    208            *         @ref TIM1_OCIdleState_TypeDef.
    209            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle 
    210            *         State from @ref TIM1_OCIdleState_TypeDef.
    211            * @retval None
    212            */

   \                                 In section .far_func.text, align 1
    213          void TIM1_OC2Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    214                            TIM1_OutputState_TypeDef TIM1_OutputState,
    215                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    216                            uint16_t TIM1_Pulse,
    217                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    218                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    219                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    220                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    221          {
   \                     TIM1_OC2Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 3B0000                PUSH      S:?b14
   \   00000B 89                    PUSHW     X
   \   00000C 8D000000              CALLF     ?Subroutine5
    222              /* Check the parameters */
    223              assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
   \                     ??CrossCallReturnLabel_15:
   \   000010 271B                  JREQ      L:??CrossCallReturnLabel_38
   \   000012 A110                  CP        A, #0x10
   \   000014 2717                  JREQ      L:??CrossCallReturnLabel_38
   \   000016 A120                  CP        A, #0x20
   \   000018 2713                  JREQ      L:??CrossCallReturnLabel_38
   \   00001A A130                  CP        A, #0x30
   \   00001C 270F                  JREQ      L:??CrossCallReturnLabel_38
   \   00001E A160                  CP        A, #0x60
   \   000020 270B                  JREQ      L:??CrossCallReturnLabel_38
   \   000022 A170                  CP        A, #0x70
   \   000024 2707                  JREQ      L:??CrossCallReturnLabel_38
   \   000026 AE00DF                LDW       X, #0xdf
   \   000029 8D000000              CALLF     ?Subroutine9
    224              assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
   \                     ??CrossCallReturnLabel_38:
   \   00002D 3D00                  TNZ       S:?b14
   \   00002F 270D                  JREQ      L:??CrossCallReturnLabel_37
   \   000031 B600                  LD        A, S:?b14
   \   000033 A111                  CP        A, #0x11
   \   000035 2707                  JREQ      L:??CrossCallReturnLabel_37
   \   000037 AE00E0                LDW       X, #0xe0
   \   00003A 8D000000              CALLF     ?Subroutine9
    225              assert_param(IS_TIM1_OUTPUTN_STATE_OK(TIM1_OutputNState));
   \                     ??CrossCallReturnLabel_37:
   \   00003E 3D00                  TNZ       S:?b13
   \   000040 270D                  JREQ      L:??CrossCallReturnLabel_36
   \   000042 B600                  LD        A, S:?b13
   \   000044 A144                  CP        A, #0x44
   \   000046 2707                  JREQ      L:??CrossCallReturnLabel_36
   \   000048 AE00E1                LDW       X, #0xe1
   \   00004B 8D000000              CALLF     ?Subroutine9
    226              assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     ??CrossCallReturnLabel_36:
   \   00004F 3D00                  TNZ       S:?b12
   \   000051 270D                  JREQ      L:??CrossCallReturnLabel_35
   \   000053 B600                  LD        A, S:?b12
   \   000055 A122                  CP        A, #0x22
   \   000057 2707                  JREQ      L:??CrossCallReturnLabel_35
   \   000059 AE00E2                LDW       X, #0xe2
   \   00005C 8D000000              CALLF     ?Subroutine9
    227              assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     ??CrossCallReturnLabel_35:
   \   000060 3D00                  TNZ       S:?b9
   \   000062 270D                  JREQ      L:??CrossCallReturnLabel_34
   \   000064 B600                  LD        A, S:?b9
   \   000066 A188                  CP        A, #0x88
   \   000068 2707                  JREQ      L:??CrossCallReturnLabel_34
   \   00006A AE00E3                LDW       X, #0xe3
   \   00006D 8D000000              CALLF     ?Subroutine9
    228              assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
   \                     ??CrossCallReturnLabel_34:
   \   000071 B600                  LD        A, S:?b10
   \   000073 A155                  CP        A, #0x55
   \   000075 270B                  JREQ      L:??CrossCallReturnLabel_33
   \   000077 3D00                  TNZ       S:?b10
   \   000079 2707                  JREQ      L:??CrossCallReturnLabel_33
   \   00007B AE00E4                LDW       X, #0xe4
   \   00007E 8D000000              CALLF     ?Subroutine9
    229              assert_param(IS_TIM1_OCNIDLE_STATE_OK(TIM1_OCNIdleState));
   \                     ??CrossCallReturnLabel_33:
   \   000082 B600                  LD        A, S:?b11
   \   000084 A12A                  CP        A, #0x2a
   \   000086 270B                  JREQ      L:??CrossCallReturnLabel_32
   \   000088 3D00                  TNZ       S:?b11
   \   00008A 2707                  JREQ      L:??CrossCallReturnLabel_32
   \   00008C AE00E5                LDW       X, #0xe5
   \   00008F 8D000000              CALLF     ?Subroutine9
    230          
    231              /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , 
    232                 the Output N State, the Output Polarity & the Output N Polarity*/
    233              TIM1->CCER1 &= (uint8_t)(~( TIM1_CCER1_CC2E | TIM1_CCER1_CC2NE | 
    234                                          TIM1_CCER1_CC2P | TIM1_CCER1_CC2NP));
   \                     ??CrossCallReturnLabel_32:
   \   000093 C6525C                LD        A, L:0x525c
   \   000096 A40F                  AND       A, #0xf
   \   000098 C7525C                LD        L:0x525c, A
    235          
    236              /* Set the Output State & Set the Output N State & Set the Output Polarity &
    237                 Set the Output N Polarity */
    238              TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC2E  ) | 
    239                                       (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC2NE )) | 
    240                                       (uint8_t)((uint8_t)(TIM1_OCPolarity  & TIM1_CCER1_CC2P  ) | 
    241                                       (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC2NP )));
   \   00009B B600                  LD        A, S:?b13
   \   00009D A440                  AND       A, #0x40
   \   00009F 88                    PUSH      A
   \   0000A0 B600                  LD        A, S:?b14
   \   0000A2 A410                  AND       A, #0x10
   \   0000A4 B700                  LD        S:?b1, A
   \   0000A6 84                    POP       A
   \   0000A7 BA00                  OR        A, S:?b1
   \   0000A9 B700                  LD        S:?b0, A
   \   0000AB B600                  LD        A, S:?b12
   \   0000AD A420                  AND       A, #0x20
   \   0000AF BA00                  OR        A, S:?b0
   \   0000B1 B700                  LD        S:?b0, A
   \   0000B3 B600                  LD        A, S:?b9
   \   0000B5 A480                  AND       A, #0x80
   \   0000B7 BA00                  OR        A, S:?b0
   \   0000B9 CA525C                OR        A, L:0x525c
   \   0000BC C7525C                LD        L:0x525c, A
    242          
    243              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    244              TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | 
    245                                       (uint8_t)TIM1_OCMode);
   \   0000BF 8D000000              CALLF     ?Subroutine7
    246          
    247              /* Reset the Output Idle state & the Output N Idle state bits */
    248              TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS2 | TIM1_OISR_OIS2N));
   \                     ??CrossCallReturnLabel_21:
   \   0000C3 C6526F                LD        A, L:0x526f
   \   0000C6 A4F3                  AND       A, #0xf3
   \   0000C8 C7526F                LD        L:0x526f, A
    249              /* Set the Output Idle state & the Output N Idle state configuration */
    250              TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS2 & TIM1_OCIdleState) | 
    251                                      (uint8_t)(TIM1_OISR_OIS2N & TIM1_OCNIdleState));
   \   0000CB B600                  LD        A, S:?b11
   \   0000CD A408                  AND       A, #0x8
   \   0000CF 88                    PUSH      A
   \   0000D0 B600                  LD        A, S:?b10
   \   0000D2 A404                  AND       A, #0x4
   \   0000D4 B700                  LD        S:?b1, A
   \   0000D6 84                    POP       A
   \   0000D7 8D000000              CALLF     ?Subroutine13
    252          
    253              /* Set the Pulse value */
    254              TIM1->CCR2H = (uint8_t)(TIM1_Pulse >> 8);
   \                     ??CrossCallReturnLabel_133:
   \   0000DB 1E01                  LDW       X, (0x1,SP)
   \   0000DD 4F                    CLR       A
   \   0000DE 01                    RRWA      X, A
   \   0000DF 9F                    LD        A, XL
   \   0000E0 C75267                LD        L:0x5267, A
    255              TIM1->CCR2L = (uint8_t)(TIM1_Pulse);
   \   0000E3 7B02                  LD        A, (0x2,SP)
   \   0000E5 C75268                LD        L:0x5268, A
    256          
    257          }
   \   0000E8 5B02                  ADD       SP, #0x2
   \   0000EA 320000                POP       S:?b14
   \   0000ED AC000000              JPF       L:?epilogue_l2_w6

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine7:
   \   000000 C65259                LD        A, L:0x5259
   \   000003 A48F                  AND       A, #0x8f
   \   000005 BA00                  OR        A, S:?b8
   \   000007 C75259                LD        L:0x5259, A
   \   00000A 87                    RETF
    258          
    259          /**
    260            * @brief  Initializes the TIM1 Channel3 according to the specified parameters.
    261            * @param  TIM1_OCMode specifies the Output Compare mode  from 
    262            *         @ref TIM1_OCMode_TypeDef.
    263            * @param  TIM1_OutputState specifies the Output State  
    264            *         from @ref TIM1_OutputState_TypeDef.
    265            * @param  TIM1_OutputNState specifies the Complementary Output State
    266            *         from @ref TIM1_OutputNState_TypeDef.
    267            * @param  TIM1_Pulse specifies the Pulse width value.
    268            * @param  TIM1_OCPolarity specifies the Output Compare Polarity  from 
    269            *         @ref TIM1_OCPolarity_TypeDef.
    270            * @param  TIM1_OCNPolarity specifies the Complementary  Output Compare 
    271            *         Polarity from @ref TIM1_OCNPolarity_TypeDef.
    272            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    273            *         from @ref TIM1_OCIdleState_TypeDef.
    274            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare 
    275            *         Idle State  from @ref TIM1_OCIdleState_TypeDef.
    276            * @retval None
    277            */

   \                                 In section .far_func.text, align 1
    278          void TIM1_OC3Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    279                            TIM1_OutputState_TypeDef TIM1_OutputState,
    280                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    281                            uint16_t TIM1_Pulse,
    282                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    283                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    284                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    285                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    286          {
   \                     TIM1_OC3Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 3B0000                PUSH      S:?b14
   \   00000B 89                    PUSHW     X
   \   00000C 8D000000              CALLF     ?Subroutine5
    287              /* Check the parameters */
    288              assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
   \                     ??CrossCallReturnLabel_14:
   \   000010 271B                  JREQ      L:??CrossCallReturnLabel_45
   \   000012 A110                  CP        A, #0x10
   \   000014 2717                  JREQ      L:??CrossCallReturnLabel_45
   \   000016 A120                  CP        A, #0x20
   \   000018 2713                  JREQ      L:??CrossCallReturnLabel_45
   \   00001A A130                  CP        A, #0x30
   \   00001C 270F                  JREQ      L:??CrossCallReturnLabel_45
   \   00001E A160                  CP        A, #0x60
   \   000020 270B                  JREQ      L:??CrossCallReturnLabel_45
   \   000022 A170                  CP        A, #0x70
   \   000024 2707                  JREQ      L:??CrossCallReturnLabel_45
   \   000026 AE0120                LDW       X, #0x120
   \   000029 8D000000              CALLF     ?Subroutine9
    289              assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
   \                     ??CrossCallReturnLabel_45:
   \   00002D 3D00                  TNZ       S:?b14
   \   00002F 270D                  JREQ      L:??CrossCallReturnLabel_44
   \   000031 B600                  LD        A, S:?b14
   \   000033 A111                  CP        A, #0x11
   \   000035 2707                  JREQ      L:??CrossCallReturnLabel_44
   \   000037 AE0121                LDW       X, #0x121
   \   00003A 8D000000              CALLF     ?Subroutine9
    290              assert_param(IS_TIM1_OUTPUTN_STATE_OK(TIM1_OutputNState));
   \                     ??CrossCallReturnLabel_44:
   \   00003E 3D00                  TNZ       S:?b13
   \   000040 270D                  JREQ      L:??CrossCallReturnLabel_43
   \   000042 B600                  LD        A, S:?b13
   \   000044 A144                  CP        A, #0x44
   \   000046 2707                  JREQ      L:??CrossCallReturnLabel_43
   \   000048 AE0122                LDW       X, #0x122
   \   00004B 8D000000              CALLF     ?Subroutine9
    291              assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     ??CrossCallReturnLabel_43:
   \   00004F 3D00                  TNZ       S:?b12
   \   000051 270D                  JREQ      L:??CrossCallReturnLabel_42
   \   000053 B600                  LD        A, S:?b12
   \   000055 A122                  CP        A, #0x22
   \   000057 2707                  JREQ      L:??CrossCallReturnLabel_42
   \   000059 AE0123                LDW       X, #0x123
   \   00005C 8D000000              CALLF     ?Subroutine9
    292              assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     ??CrossCallReturnLabel_42:
   \   000060 3D00                  TNZ       S:?b9
   \   000062 270D                  JREQ      L:??CrossCallReturnLabel_41
   \   000064 B600                  LD        A, S:?b9
   \   000066 A188                  CP        A, #0x88
   \   000068 2707                  JREQ      L:??CrossCallReturnLabel_41
   \   00006A AE0124                LDW       X, #0x124
   \   00006D 8D000000              CALLF     ?Subroutine9
    293              assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
   \                     ??CrossCallReturnLabel_41:
   \   000071 B600                  LD        A, S:?b10
   \   000073 A155                  CP        A, #0x55
   \   000075 270B                  JREQ      L:??CrossCallReturnLabel_40
   \   000077 3D00                  TNZ       S:?b10
   \   000079 2707                  JREQ      L:??CrossCallReturnLabel_40
   \   00007B AE0125                LDW       X, #0x125
   \   00007E 8D000000              CALLF     ?Subroutine9
    294              assert_param(IS_TIM1_OCNIDLE_STATE_OK(TIM1_OCNIdleState));
   \                     ??CrossCallReturnLabel_40:
   \   000082 B600                  LD        A, S:?b11
   \   000084 A12A                  CP        A, #0x2a
   \   000086 270B                  JREQ      L:??CrossCallReturnLabel_39
   \   000088 3D00                  TNZ       S:?b11
   \   00008A 2707                  JREQ      L:??CrossCallReturnLabel_39
   \   00008C AE0126                LDW       X, #0x126
   \   00008F 8D000000              CALLF     ?Subroutine9
    295          
    296              /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , 
    297                 the Output N State, the Output Polarity & the Output N Polarity*/
    298              TIM1->CCER2 &= (uint8_t)(~( TIM1_CCER2_CC3E | TIM1_CCER2_CC3NE | 
    299                                          TIM1_CCER2_CC3P | TIM1_CCER2_CC3NP));
   \                     ??CrossCallReturnLabel_39:
   \   000093 C6525D                LD        A, L:0x525d
   \   000096 A4F0                  AND       A, #0xf0
   \   000098 C7525D                LD        L:0x525d, A
    300              /* Set the Output State & Set the Output N State & Set the Output Polarity &
    301                 Set the Output N Polarity */
    302              TIM1->CCER2 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState  & TIM1_CCER2_CC3E   ) |
    303                                       (uint8_t)(TIM1_OutputNState & TIM1_CCER2_CC3NE  )) | 
    304                                       (uint8_t)((uint8_t)(TIM1_OCPolarity   & TIM1_CCER2_CC3P   ) | 
    305                                       (uint8_t)(TIM1_OCNPolarity  & TIM1_CCER2_CC3NP  )));
   \   00009B 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_8:
   \   00009F CA525D                OR        A, L:0x525d
   \   0000A2 C7525D                LD        L:0x525d, A
    306          
    307              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    308              TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) | 
    309                                       (uint8_t)TIM1_OCMode);
   \   0000A5 8D000000              CALLF     ?Subroutine4
    310          
    311              /* Reset the Output Idle state & the Output N Idle state bits */
    312              TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS3 | TIM1_OISR_OIS3N));
   \                     ??CrossCallReturnLabel_13:
   \   0000A9 C6526F                LD        A, L:0x526f
   \   0000AC A4CF                  AND       A, #0xcf
   \   0000AE C7526F                LD        L:0x526f, A
    313              /* Set the Output Idle state & the Output N Idle state configuration */
    314              TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS3 & TIM1_OCIdleState) | 
    315                                      (uint8_t)(TIM1_OISR_OIS3N & TIM1_OCNIdleState));
   \   0000B1 B600                  LD        A, S:?b11
   \   0000B3 A420                  AND       A, #0x20
   \   0000B5 88                    PUSH      A
   \   0000B6 B600                  LD        A, S:?b10
   \   0000B8 A410                  AND       A, #0x10
   \   0000BA B700                  LD        S:?b1, A
   \   0000BC 84                    POP       A
   \   0000BD 8D000000              CALLF     ?Subroutine13
    316          
    317              /* Set the Pulse value */
    318              TIM1->CCR3H = (uint8_t)(TIM1_Pulse >> 8);
   \                     ??CrossCallReturnLabel_132:
   \   0000C1 1E01                  LDW       X, (0x1,SP)
   \   0000C3 4F                    CLR       A
   \   0000C4 01                    RRWA      X, A
   \   0000C5 9F                    LD        A, XL
   \   0000C6 C75269                LD        L:0x5269, A
    319              TIM1->CCR3L = (uint8_t)(TIM1_Pulse);
   \   0000C9 7B02                  LD        A, (0x2,SP)
   \   0000CB C7526A                LD        L:0x526a, A
    320          
    321          }
   \   0000CE 5B02                  ADD       SP, #0x2
   \   0000D0 320000                POP       S:?b14
   \   0000D3 AC000000              JPF       L:?epilogue_l2_w6

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine4:
   \   000000 C6525A                LD        A, L:0x525a
   \   000003 A48F                  AND       A, #0x8f
   \   000005 BA00                  OR        A, S:?b8
   \   000007 C7525A                LD        L:0x525a, A
   \   00000A 87                    RETF
    322          
    323          /**
    324            * @brief  Initializes the TIM1 Channel4 according to the specified parameters.
    325            * @param  TIM1_OCMode specifies the Output Compare mode  from 
    326            *         @ref TIM1_OCMode_TypeDef.
    327            * @param  TIM1_OutputState specifies the Output State
    328            *         from @ref TIM1_OutputState_TypeDef.
    329            * @param  TIM1_Pulse specifies the Pulse width  value.
    330            * @param  TIM1_OCPolarity specifies the Output Compare Polarity
    331            *         from @ref TIM1_OCPolarity_TypeDef.
    332            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    333            *         from @ref TIM1_OCIdleState_TypeDef.
    334            * @retval None
    335            */

   \                                 In section .far_func.text, align 1
    336          void TIM1_OC4Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    337                            TIM1_OutputState_TypeDef TIM1_OutputState,
    338                            uint16_t TIM1_Pulse,
    339                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    340                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState)
    341          {
   \                     TIM1_OC4Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 B700                  LD        S:?b8, A
   \   00000A 450000                MOV       S:?b9, S:?b0
   \   00000D BF00                  LDW       S:?w6, X
   \   00000F 450000                MOV       S:?b10, S:?b1
   \   000012 450000                MOV       S:?b11, S:?b2
    342              /* Check the parameters */
    343              assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
   \   000015 3D00                  TNZ       S:?b8
   \   000017 271B                  JREQ      L:??CrossCallReturnLabel_49
   \   000019 A110                  CP        A, #0x10
   \   00001B 2717                  JREQ      L:??CrossCallReturnLabel_49
   \   00001D A120                  CP        A, #0x20
   \   00001F 2713                  JREQ      L:??CrossCallReturnLabel_49
   \   000021 A130                  CP        A, #0x30
   \   000023 270F                  JREQ      L:??CrossCallReturnLabel_49
   \   000025 A160                  CP        A, #0x60
   \   000027 270B                  JREQ      L:??CrossCallReturnLabel_49
   \   000029 A170                  CP        A, #0x70
   \   00002B 2707                  JREQ      L:??CrossCallReturnLabel_49
   \   00002D AE0157                LDW       X, #0x157
   \   000030 8D000000              CALLF     ?Subroutine9
    344              assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
   \                     ??CrossCallReturnLabel_49:
   \   000034 3D00                  TNZ       S:?b9
   \   000036 270D                  JREQ      L:??CrossCallReturnLabel_48
   \   000038 B600                  LD        A, S:?b9
   \   00003A A111                  CP        A, #0x11
   \   00003C 2707                  JREQ      L:??CrossCallReturnLabel_48
   \   00003E AE0158                LDW       X, #0x158
   \   000041 8D000000              CALLF     ?Subroutine9
    345              assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     ??CrossCallReturnLabel_48:
   \   000045 3D00                  TNZ       S:?b10
   \   000047 270D                  JREQ      L:??CrossCallReturnLabel_47
   \   000049 B600                  LD        A, S:?b10
   \   00004B A122                  CP        A, #0x22
   \   00004D 2707                  JREQ      L:??CrossCallReturnLabel_47
   \   00004F AE0159                LDW       X, #0x159
   \   000052 8D000000              CALLF     ?Subroutine9
    346              assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
   \                     ??CrossCallReturnLabel_47:
   \   000056 B600                  LD        A, S:?b11
   \   000058 A155                  CP        A, #0x55
   \   00005A 270B                  JREQ      L:??CrossCallReturnLabel_46
   \   00005C 3D00                  TNZ       S:?b11
   \   00005E 2707                  JREQ      L:??CrossCallReturnLabel_46
   \   000060 AE015A                LDW       X, #0x15a
   \   000063 8D000000              CALLF     ?Subroutine9
    347          
    348              /* Disable the Channel 4: Reset the CCE Bit */
    349              TIM1->CCER2 &= (uint8_t)(~(TIM1_CCER2_CC4E | TIM1_CCER2_CC4P));
   \                     ??CrossCallReturnLabel_46:
   \   000067 C6525D                LD        A, L:0x525d
   \   00006A A4CF                  AND       A, #0xcf
   \   00006C C7525D                LD        L:0x525d, A
    350              /* Set the Output State  &  the Output Polarity */
    351              TIM1->CCER2 |= (uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER2_CC4E ) |  
    352                                       (uint8_t)(TIM1_OCPolarity  & TIM1_CCER2_CC4P ));
   \   00006F B600                  LD        A, S:?b10
   \   000071 A420                  AND       A, #0x20
   \   000073 88                    PUSH      A
   \   000074 B600                  LD        A, S:?b9
   \   000076 A410                  AND       A, #0x10
   \   000078 B700                  LD        S:?b1, A
   \   00007A 84                    POP       A
   \   00007B BA00                  OR        A, S:?b1
   \   00007D CA525D                OR        A, L:0x525d
   \   000080 C7525D                LD        L:0x525d, A
    353          
    354              /* Reset the Output Compare Bit  and Set the Output Compare Mode */
    355              TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_OCM)) | 
    356                                      TIM1_OCMode);
   \   000083 8D000000              CALLF     ?Subroutine3
    357          
    358              /* Set the Output Idle state */
    359              if (TIM1_OCIdleState != TIM1_OCIDLESTATE_RESET)
   \                     ??CrossCallReturnLabel_11:
   \   000087 3D00                  TNZ       S:?b11
   \   000089 270A                  JREQ      L:??TIM1_OC4Init_0
    360              {
    361                  TIM1->OISR |= (uint8_t)(~TIM1_CCER2_CC4P);
   \   00008B C6526F                LD        A, L:0x526f
   \   00008E AADF                  OR        A, #0xdf
   \   000090 C7526F                LD        L:0x526f, A
   \   000093 2004                  JRA       L:??TIM1_OC4Init_1
    362              }
    363              else
    364              {
    365                  TIM1->OISR &= (uint8_t)(~TIM1_OISR_OIS4);
   \                     ??TIM1_OC4Init_0:
   \   000095 721D526F              BRES      L:0x526f, #0x6
    366              }
    367          
    368              /* Set the Pulse value */
    369              TIM1->CCR4H = (uint8_t)(TIM1_Pulse >> 8);
   \                     ??TIM1_OC4Init_1:
   \   000099 BE00                  LDW       X, S:?w6
   \   00009B 4F                    CLR       A
   \   00009C 01                    RRWA      X, A
   \   00009D 9F                    LD        A, XL
   \   00009E C7526B                LD        L:0x526b, A
    370              TIM1->CCR4L = (uint8_t)(TIM1_Pulse);
   \   0000A1 B600                  LD        A, S:?b13
   \   0000A3 C7526C                LD        L:0x526c, A
    371          
    372          }
   \   0000A6 AC000000              JPF       L:?epilogue_l2_w6

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine3:
   \   000000 C6525B                LD        A, L:0x525b
   \   000003 A48F                  AND       A, #0x8f
   \   000005 BA00                  OR        A, S:?b8
   \   000007 C7525B                LD        L:0x525b, A
   \   00000A 87                    RETF
    373          
    374          /**
    375            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    376            *         and the AOE(automatic output enable).
    377            * @param  TIM1_OSSIState specifies the OSSIS State from @ref TIM1_OSSIState_TypeDef.
    378            * @param  TIM1_LockLevel specifies the lock level from @ref TIM1_LockLevel_TypeDef.
    379            * @param  TIM1_DeadTime specifies the dead time value.
    380            * @param  TIM1_Break specifies the Break state @ref TIM1_BreakState_TypeDef.
    381            * @param  TIM1_BreakPolarity specifies the Break polarity from 
    382            *         @ref TIM1_BreakPolarity_TypeDef.
    383            * @param  TIM1_AutomaticOutput specifies the Automatic Output configuration 
    384            *         from @ref TIM1_AutomaticOutput_TypeDef.
    385            * @retval None
    386            */

   \                                 In section .far_func.text, align 1
    387          void TIM1_BDTRConfig(TIM1_OSSIState_TypeDef TIM1_OSSIState,
    388                               TIM1_LockLevel_TypeDef TIM1_LockLevel,
    389                               uint8_t TIM1_DeadTime,
    390                               TIM1_BreakState_TypeDef TIM1_Break,
    391                               TIM1_BreakPolarity_TypeDef TIM1_BreakPolarity,
    392                               TIM1_AutomaticOutput_TypeDef TIM1_AutomaticOutput)
    393          {
   \                     TIM1_BDTRConfig:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 B700                  LD        S:?b13, A
   \   00000A 450000                MOV       S:?b8, S:?b0
   \   00000D 450000                MOV       S:?b9, S:?b1
   \   000010 450000                MOV       S:?b12, S:?b2
   \   000013 450000                MOV       S:?b10, S:?b3
   \   000016 450000                MOV       S:?b11, S:?b4
    394              /* Check the parameters */
    395              assert_param(IS_TIM1_OSSI_STATE_OK(TIM1_OSSIState));
   \   000019 A104                  CP        A, #0x4
   \   00001B 270B                  JREQ      L:??CrossCallReturnLabel_54
   \   00001D 3D00                  TNZ       S:?b13
   \   00001F 2707                  JREQ      L:??CrossCallReturnLabel_54
   \   000021 AE018B                LDW       X, #0x18b
   \   000024 8D000000              CALLF     ?Subroutine9
    396              assert_param(IS_TIM1_LOCK_LEVEL_OK(TIM1_LockLevel));
   \                     ??CrossCallReturnLabel_54:
   \   000028 3D00                  TNZ       S:?b8
   \   00002A 2715                  JREQ      L:??CrossCallReturnLabel_53
   \   00002C B600                  LD        A, S:?b8
   \   00002E A101                  CP        A, #0x1
   \   000030 270F                  JREQ      L:??CrossCallReturnLabel_53
   \   000032 A102                  CP        A, #0x2
   \   000034 270B                  JREQ      L:??CrossCallReturnLabel_53
   \   000036 A103                  CP        A, #0x3
   \   000038 2707                  JREQ      L:??CrossCallReturnLabel_53
   \   00003A AE018C                LDW       X, #0x18c
   \   00003D 8D000000              CALLF     ?Subroutine9
    397              assert_param(IS_TIM1_BREAK_STATE_OK(TIM1_Break));
   \                     ??CrossCallReturnLabel_53:
   \   000041 B600                  LD        A, S:?b12
   \   000043 A110                  CP        A, #0x10
   \   000045 270B                  JREQ      L:??CrossCallReturnLabel_52
   \   000047 3D00                  TNZ       S:?b12
   \   000049 2707                  JREQ      L:??CrossCallReturnLabel_52
   \   00004B AE018D                LDW       X, #0x18d
   \   00004E 8D000000              CALLF     ?Subroutine9
    398              assert_param(IS_TIM1_BREAK_POLARITY_OK(TIM1_BreakPolarity));
   \                     ??CrossCallReturnLabel_52:
   \   000052 3D00                  TNZ       S:?b10
   \   000054 270D                  JREQ      L:??CrossCallReturnLabel_51
   \   000056 B600                  LD        A, S:?b10
   \   000058 A120                  CP        A, #0x20
   \   00005A 2707                  JREQ      L:??CrossCallReturnLabel_51
   \   00005C AE018E                LDW       X, #0x18e
   \   00005F 8D000000              CALLF     ?Subroutine9
    399              assert_param(IS_TIM1_AUTOMATIC_OUTPUT_STATE_OK(TIM1_AutomaticOutput));
   \                     ??CrossCallReturnLabel_51:
   \   000063 B600                  LD        A, S:?b11
   \   000065 A140                  CP        A, #0x40
   \   000067 270B                  JREQ      L:??CrossCallReturnLabel_50
   \   000069 3D00                  TNZ       S:?b11
   \   00006B 2707                  JREQ      L:??CrossCallReturnLabel_50
   \   00006D AE018F                LDW       X, #0x18f
   \   000070 8D000000              CALLF     ?Subroutine9
    400          
    401              TIM1->DTR = (uint8_t)(TIM1_DeadTime);
   \                     ??CrossCallReturnLabel_50:
   \   000074 B600                  LD        A, S:?b9
   \   000076 C7526E                LD        L:0x526e, A
    402              /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
    403                        the dead time value  and the Automatic Output Enable Bit */
    404          
    405              TIM1->BKR  =  (uint8_t)((uint8_t)(TIM1_OSSIState | (uint8_t)TIM1_LockLevel)  | 
    406                                      (uint8_t)((uint8_t)(TIM1_Break | (uint8_t)TIM1_BreakPolarity)  | 
    407                                      (uint8_t)TIM1_AutomaticOutput));
   \   000079 B600                  LD        A, S:?b8
   \   00007B BA00                  OR        A, S:?b13
   \   00007D BA00                  OR        A, S:?b12
   \   00007F BA00                  OR        A, S:?b10
   \   000081 BA00                  OR        A, S:?b11
   \   000083 C7526D                LD        L:0x526d, A
    408          
    409          }
   \   000086 AC000000              JPF       L:?epilogue_l2_w6
    410          
    411          /**
    412            * @brief  Initializes the TIM1 peripheral according to the specified parameters.
    413            * @param  TIM1_Channel specifies the input capture channel from TIM1_Channel_TypeDef.
    414            * @param  TIM1_ICPolarity specifies the Input capture polarity from  
    415            *         TIM1_ICPolarity_TypeDef .
    416            * @param  TIM1_ICSelection specifies the Input capture source selection from 
    417            *         TIM1_ICSelection_TypeDef.
    418            * @param  TIM1_ICPrescaler specifies the Input capture Prescaler from
    419            *         TIM1_ICPSC_TypeDef.
    420            * @param  TIM1_ICFilter specifies the Input capture filter value.
    421            * @retval None
    422            */

   \                                 In section .far_func.text, align 1, keep-with-next
    423          void TIM1_ICInit(TIM1_Channel_TypeDef TIM1_Channel,
    424                           TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
    425                           TIM1_ICSelection_TypeDef TIM1_ICSelection,
    426                           TIM1_ICPSC_TypeDef TIM1_ICPrescaler,
    427                           uint8_t TIM1_ICFilter)
    428          {
   \                     TIM1_ICInit:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 3B0000                PUSH      S:?b12
   \   000007 8D000000              CALLF     ?Subroutine15
    429          
    430              /* Check the parameters */
    431              assert_param(IS_TIM1_CHANNEL_OK(TIM1_Channel));
   \                     ??CrossCallReturnLabel_138:
   \   00000B 2713                  JREQ      L:??CrossCallReturnLabel_59
   \   00000D A101                  CP        A, #0x1
   \   00000F 270F                  JREQ      L:??CrossCallReturnLabel_59
   \   000011 A102                  CP        A, #0x2
   \   000013 270B                  JREQ      L:??CrossCallReturnLabel_59
   \   000015 A103                  CP        A, #0x3
   \   000017 2707                  JREQ      L:??CrossCallReturnLabel_59
   \   000019 AE01AF                LDW       X, #0x1af
   \   00001C 8D000000              CALLF     ?Subroutine9
    432              assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_ICPolarity));
   \                     ??CrossCallReturnLabel_59:
   \   000020 3D00                  TNZ       S:?b8
   \   000022 270D                  JREQ      L:??CrossCallReturnLabel_58
   \   000024 B600                  LD        A, S:?b8
   \   000026 A101                  CP        A, #0x1
   \   000028 2707                  JREQ      L:??CrossCallReturnLabel_58
   \   00002A AE01B0                LDW       X, #0x1b0
   \   00002D 8D000000              CALLF     ?Subroutine9
    433              assert_param(IS_TIM1_IC_SELECTION_OK(TIM1_ICSelection));
   \                     ??CrossCallReturnLabel_58:
   \   000031 B600                  LD        A, S:?b9
   \   000033 A101                  CP        A, #0x1
   \   000035 270F                  JREQ      L:??CrossCallReturnLabel_57
   \   000037 A102                  CP        A, #0x2
   \   000039 270B                  JREQ      L:??CrossCallReturnLabel_57
   \   00003B A103                  CP        A, #0x3
   \   00003D 2707                  JREQ      L:??CrossCallReturnLabel_57
   \   00003F AE01B1                LDW       X, #0x1b1
   \   000042 8D000000              CALLF     ?Subroutine9
    434              assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_ICPrescaler));
   \                     ??CrossCallReturnLabel_57:
   \   000046 3D00                  TNZ       S:?b10
   \   000048 2715                  JREQ      L:??CrossCallReturnLabel_56
   \   00004A B600                  LD        A, S:?b10
   \   00004C A104                  CP        A, #0x4
   \   00004E 270F                  JREQ      L:??CrossCallReturnLabel_56
   \   000050 A108                  CP        A, #0x8
   \   000052 270B                  JREQ      L:??CrossCallReturnLabel_56
   \   000054 A10C                  CP        A, #0xc
   \   000056 2707                  JREQ      L:??CrossCallReturnLabel_56
   \   000058 AE01B2                LDW       X, #0x1b2
   \   00005B 8D000000              CALLF     ?Subroutine9
    435              assert_param(IS_TIM1_IC_FILTER_OK(TIM1_ICFilter));
   \                     ??CrossCallReturnLabel_56:
   \   00005F B600                  LD        A, S:?b11
   \   000061 A110                  CP        A, #0x10
   \   000063 2507                  JRC       L:??CrossCallReturnLabel_55
   \   000065 AE01B3                LDW       X, #0x1b3
   \   000068 8D000000              CALLF     ?Subroutine9
    436          
    437              if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??CrossCallReturnLabel_55:
   \   00006C 3D00                  TNZ       S:?b12
   \   00006E 260A                  JRNE      L:??TIM1_ICInit_0
    438              {
    439                  /* TI1 Configuration */
    440                  TI1_Config((uint8_t)TIM1_ICPolarity,
    441                             (uint8_t)TIM1_ICSelection,
    442                             (uint8_t)TIM1_ICFilter);
   \   000070 8D000000              CALLF     ?Subroutine17
    443                  /* Set the Input Capture Prescaler value */
    444                  TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
    445              }
   \                     ??CrossCallReturnLabel_142:
   \   000074 8D000000              CALLF     ?Subroutine10
   \                     ??CrossCallReturnLabel_127:
   \   000078 2032                  JRA       L:??TIM1_ICInit_1
    446              else if (TIM1_Channel == TIM1_CHANNEL_2)
   \                     ??TIM1_ICInit_0:
   \   00007A B600                  LD        A, S:?b12
   \   00007C A101                  CP        A, #0x1
   \   00007E 260A                  JRNE      L:??TIM1_ICInit_2
    447              {
    448                  /* TI2 Configuration */
    449                  TI2_Config((uint8_t)TIM1_ICPolarity,
    450                             (uint8_t)TIM1_ICSelection,
    451                             (uint8_t)TIM1_ICFilter);
   \   000080 8D000000              CALLF     ?Subroutine17
    452                  /* Set the Input Capture Prescaler value */
    453                  TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
    454              }
   \                     ??CrossCallReturnLabel_143:
   \   000084 8D000000              CALLF     ?Subroutine11
   \                     ??CrossCallReturnLabel_129:
   \   000088 2022                  JRA       L:??TIM1_ICInit_1
    455              else if (TIM1_Channel == TIM1_CHANNEL_3)
   \                     ??TIM1_ICInit_2:
   \   00008A A102                  CP        A, #0x2
   \   00008C 8D000000              CALLF     ?Subroutine17
   \                     ??CrossCallReturnLabel_144:
   \   000090 260E                  JRNE      L:??TIM1_ICInit_3
    456              {
    457                  /* TI3 Configuration */
    458                  TI3_Config((uint8_t)TIM1_ICPolarity,
    459                             (uint8_t)TIM1_ICSelection,
    460                             (uint8_t)TIM1_ICFilter);
   \   000092 B600                  LD        A, S:?b8
   \   000094 8D000000              CALLF     TI3_Config
    461                  /* Set the Input Capture Prescaler value */
    462                  TIM1_SetIC3Prescaler(TIM1_ICPrescaler);
   \   000098 B600                  LD        A, S:?b10
   \   00009A 8D000000              CALLF     TIM1_SetIC3Prescaler
   \   00009E 200C                  JRA       L:??TIM1_ICInit_1
    463              }
    464              else
    465              {
    466                  /* TI4 Configuration */
    467                  TI4_Config((uint8_t)TIM1_ICPolarity,
    468                             (uint8_t)TIM1_ICSelection,
    469                             (uint8_t)TIM1_ICFilter);
   \                     ??TIM1_ICInit_3:
   \   0000A0 B600                  LD        A, S:?b8
   \   0000A2 8D000000              CALLF     TI4_Config
    470                  /* Set the Input Capture Prescaler value */
    471                  TIM1_SetIC4Prescaler(TIM1_ICPrescaler);
   \   0000A6 B600                  LD        A, S:?b10
   \   0000A8 8D000000              CALLF     TIM1_SetIC4Prescaler
    472              }
    473          
    474          }
   \                     ??TIM1_ICInit_1:
   \   0000AC 320000                POP       S:?b12
   \   0000AF AC000000              JPF       L:?epilogue_l2

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000 450000                MOV       S:?b1, S:?b11
   \   000003 450000                MOV       S:?b0, S:?b9
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000 B700                  LD        S:?b12, A
   \   000002 450000                MOV       S:?b8, S:?b0
   \   000005 450000                MOV       S:?b9, S:?b1
   \   000008 450000                MOV       S:?b10, S:?b2
   \   00000B 450000                MOV       S:?b11, S:?b3
   \   00000E 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000 B600                  LD        A, S:?b8
   \   000002 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_145:
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000 8D000000              CALLF     TI2_Config
   \   000004 B600                  LD        A, S:?b10
   \   000006 AC000000              JPF       TIM1_SetIC2Prescaler

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000 B600                  LD        A, S:?b8
   \   000002 8D000000              CALLF     ?Subroutine19
   \                     ??CrossCallReturnLabel_147:
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine19:
   \   000000 8D000000              CALLF     TI1_Config
   \   000004 B600                  LD        A, S:?b10
   \   000006 AC000000              JPF       TIM1_SetIC1Prescaler
    475          
    476          /**
    477            * @brief  Configures the TIM1 peripheral in PWM Input Mode according to the 
    478            *         specified parameters.
    479            * @param  TIM1_Channel specifies the input capture channel from 
    480            *         @ref TIM1_Channel_TypeDef.
    481            * @param  TIM1_ICPolarity specifies the Input capture polarity from  
    482            *         @ref TIM1_ICPolarity_TypeDef .
    483            * @param  TIM1_ICSelection specifies the Input capture source selection  from
    484            *         @ref TIM1_ICSelection_TypeDef.
    485            * @param  TIM1_ICPrescaler specifies the Input capture Prescaler from  
    486            *         @ref TIM1_ICPSC_TypeDef.
    487            * @param  TIM1_ICFilter specifies the Input capture filter value.
    488            * @retval None
    489            */

   \                                 In section .far_func.text, align 1, keep-with-next
    490          void TIM1_PWMIConfig(TIM1_Channel_TypeDef TIM1_Channel,
    491                               TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
    492                               TIM1_ICSelection_TypeDef TIM1_ICSelection,
    493                               TIM1_ICPSC_TypeDef TIM1_ICPrescaler,
    494                               uint8_t TIM1_ICFilter)
    495          {
   \                     TIM1_PWMIConfig:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_w6
   \   000008 3B0000                PUSH      S:?b14
   \   00000B 8D000000              CALLF     ?Subroutine15
    496              uint8_t icpolarity = TIM1_ICPOLARITY_RISING;
    497              uint8_t icselection = TIM1_ICSELECTION_DIRECTTI;
    498          
    499              /* Check the parameters */
    500              assert_param(IS_TIM1_PWMI_CHANNEL_OK(TIM1_Channel));
   \                     ??CrossCallReturnLabel_137:
   \   00000F 270B                  JREQ      L:??CrossCallReturnLabel_63
   \   000011 A101                  CP        A, #0x1
   \   000013 2707                  JREQ      L:??CrossCallReturnLabel_63
   \   000015 AE01F4                LDW       X, #0x1f4
   \   000018 8D000000              CALLF     ?Subroutine9
    501              assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_ICPolarity));
   \                     ??CrossCallReturnLabel_63:
   \   00001C 3D00                  TNZ       S:?b8
   \   00001E 270D                  JREQ      L:??CrossCallReturnLabel_62
   \   000020 B600                  LD        A, S:?b8
   \   000022 A101                  CP        A, #0x1
   \   000024 2707                  JREQ      L:??CrossCallReturnLabel_62
   \   000026 AE01F5                LDW       X, #0x1f5
   \   000029 8D000000              CALLF     ?Subroutine9
    502              assert_param(IS_TIM1_IC_SELECTION_OK(TIM1_ICSelection));
   \                     ??CrossCallReturnLabel_62:
   \   00002D B600                  LD        A, S:?b9
   \   00002F A101                  CP        A, #0x1
   \   000031 270F                  JREQ      L:??CrossCallReturnLabel_61
   \   000033 A102                  CP        A, #0x2
   \   000035 270B                  JREQ      L:??CrossCallReturnLabel_61
   \   000037 A103                  CP        A, #0x3
   \   000039 2707                  JREQ      L:??CrossCallReturnLabel_61
   \   00003B AE01F6                LDW       X, #0x1f6
   \   00003E 8D000000              CALLF     ?Subroutine9
    503              assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_ICPrescaler));
   \                     ??CrossCallReturnLabel_61:
   \   000042 3D00                  TNZ       S:?b10
   \   000044 2715                  JREQ      L:??CrossCallReturnLabel_60
   \   000046 B600                  LD        A, S:?b10
   \   000048 A104                  CP        A, #0x4
   \   00004A 270F                  JREQ      L:??CrossCallReturnLabel_60
   \   00004C A108                  CP        A, #0x8
   \   00004E 270B                  JREQ      L:??CrossCallReturnLabel_60
   \   000050 A10C                  CP        A, #0xc
   \   000052 2707                  JREQ      L:??CrossCallReturnLabel_60
   \   000054 AE01F7                LDW       X, #0x1f7
   \   000057 8D000000              CALLF     ?Subroutine9
    504          
    505              /* Select the Opposite Input Polarity */
    506              if (TIM1_ICPolarity != TIM1_ICPOLARITY_FALLING)
   \                     ??CrossCallReturnLabel_60:
   \   00005B B600                  LD        A, S:?b8
   \   00005D A101                  CP        A, #0x1
   \   00005F 2706                  JREQ      L:??TIM1_PWMIConfig_0
    507              {
    508                  icpolarity = TIM1_ICPOLARITY_FALLING;
   \   000061 35010000              MOV       S:?b14, #0x1
   \   000065 2002                  JRA       L:??TIM1_PWMIConfig_1
    509              }
    510              else
    511              {
    512                  icpolarity = TIM1_ICPOLARITY_RISING;
   \                     ??TIM1_PWMIConfig_0:
   \   000067 3F00                  CLR       S:?b14
    513              }
    514          
    515              /* Select the Opposite Input */
    516              if (TIM1_ICSelection == TIM1_ICSELECTION_DIRECTTI)
   \                     ??TIM1_PWMIConfig_1:
   \   000069 B600                  LD        A, S:?b9
   \   00006B A101                  CP        A, #0x1
   \   00006D 2606                  JRNE      L:??TIM1_PWMIConfig_2
    517              {
    518                  icselection = TIM1_ICSELECTION_INDIRECTTI;
   \   00006F 35020000              MOV       S:?b13, #0x2
   \   000073 2004                  JRA       L:??TIM1_PWMIConfig_3
    519              }
    520              else
    521              {
    522                  icselection = TIM1_ICSELECTION_DIRECTTI;
   \                     ??TIM1_PWMIConfig_2:
   \   000075 35010000              MOV       S:?b13, #0x1
    523              }
    524          
    525              if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??TIM1_PWMIConfig_3:
   \   000079 3D00                  TNZ       S:?b12
   \   00007B 8D000000              CALLF     ?Subroutine17
   \                     ??CrossCallReturnLabel_141:
   \   00007F 2612                  JRNE      L:??TIM1_PWMIConfig_4
    526              {
    527                  /* TI1 Configuration */
    528                  TI1_Config((uint8_t)TIM1_ICPolarity, (uint8_t)TIM1_ICSelection,
    529                             (uint8_t)TIM1_ICFilter);
   \   000081 8D000000              CALLF     ?Subroutine10
    530          
    531                  /* Set the Input Capture Prescaler value */
    532                  TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
    533          
    534                  /* TI2 Configuration */
    535                  TI2_Config(icpolarity, icselection, TIM1_ICFilter);
   \                     ??CrossCallReturnLabel_126:
   \   000085 450000                MOV       S:?b1, S:?b11
   \   000088 450000                MOV       S:?b0, S:?b13
   \   00008B B600                  LD        A, S:?b14
   \   00008D 8D000000              CALLF     ?Subroutine18
    536          
    537                  /* Set the Input Capture Prescaler value */
    538                  TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
    539              }
   \                     ??CrossCallReturnLabel_146:
   \   000091 2010                  JRA       L:??CrossCallReturnLabel_148
    540              else
    541              {
    542                  /* TI2 Configuration */
    543                  TI2_Config((uint8_t)TIM1_ICPolarity, (uint8_t)TIM1_ICSelection,
    544                             (uint8_t)TIM1_ICFilter);
   \                     ??TIM1_PWMIConfig_4:
   \   000093 8D000000              CALLF     ?Subroutine11
    545          
    546                  /* Set the Input Capture Prescaler value */
    547                  TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
    548          
    549                  /* TI1 Configuration */
    550                  TI1_Config(icpolarity, icselection, TIM1_ICFilter);
   \                     ??CrossCallReturnLabel_128:
   \   000097 450000                MOV       S:?b1, S:?b11
   \   00009A 450000                MOV       S:?b0, S:?b13
   \   00009D B600                  LD        A, S:?b14
   \   00009F 8D000000              CALLF     ?Subroutine19
    551          
    552                  /* Set the Input Capture Prescaler value */
    553                  TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
    554              }
    555          }
   \                     ??CrossCallReturnLabel_148:
   \   0000A3 320000                POP       S:?b14
   \   0000A6 AC000000              JPF       L:?epilogue_l2_w6
    556          
    557          /**
    558            * @brief  Enables or disables the TIM1 peripheral.
    559            * @param  NewState new state of the TIM1 peripheral.
    560          	*         This parameter can be ENABLE or DISABLE.
    561            * @retval None
    562            */

   \                                 In section .far_func.text, align 1, keep-with-next
    563          void TIM1_Cmd(FunctionalState NewState)
    564          {
    565              /* Check the parameters */
    566              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_Cmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_64
   \   000007 AE0236                LDW       X, #0x236
   \   00000A 8D000000              CALLF     ?Subroutine9
    567          
    568              /* set or Reset the CEN Bit */
    569              if (NewState != DISABLE)
    570              {
    571                  TIM1->CR1 |= TIM1_CR1_CEN;
   \                     ??CrossCallReturnLabel_64:
   \   00000E 72105250              BSET      L:0x5250, #0x0
   \   000012 87                    RETF
    572              }
    573              else
    574              {
    575                  TIM1->CR1 &= (uint8_t)(~TIM1_CR1_CEN);
   \                     ??TIM1_Cmd_0:
   \   000013 72115250              BRES      L:0x5250, #0x0
    576              }
    577          }
   \   000017 87                    RETF
    578          
    579          /**
    580            * @brief  Enables or disables the TIM1 peripheral Main Outputs.
    581            * @param  NewState new state of the TIM1 peripheral.
    582          	*         This parameter can be ENABLE or DISABLE.
    583            * @retval None
    584            */

   \                                 In section .far_func.text, align 1, keep-with-next
    585          void TIM1_CtrlPWMOutputs(FunctionalState NewState)
    586          {
    587              /* Check the parameters */
    588              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_CtrlPWMOutputs:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_CtrlPWMOutputs_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_65
   \   000007 AE024C                LDW       X, #0x24c
   \   00000A 8D000000              CALLF     ?Subroutine9
    589          
    590              /* Set or Reset the MOE Bit */
    591          
    592              if (NewState != DISABLE)
    593              {
    594                  TIM1->BKR |= TIM1_BKR_MOE;
   \                     ??CrossCallReturnLabel_65:
   \   00000E 721E526D              BSET      L:0x526d, #0x7
   \   000012 87                    RETF
    595              }
    596              else
    597              {
    598                  TIM1->BKR &= (uint8_t)(~TIM1_BKR_MOE);
   \                     ??TIM1_CtrlPWMOutputs_0:
   \   000013 721F526D              BRES      L:0x526d, #0x7
    599              }
    600          }
   \   000017 87                    RETF
    601          
    602          /**
    603            * @brief  Enables or disables the specified TIM1 interrupts.
    604            * @param  NewState new state of the TIM1 peripheral.
    605            *         This parameter can be: ENABLE or DISABLE.
    606            * @param  TIM1_IT specifies the TIM1 interrupts sources to be enabled or disabled.
    607            *         This parameter can be any combination of the following values:
    608            *           - TIM1_IT_UPDATE: TIM1 update Interrupt source
    609            *           - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
    610            *           - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
    611            *           - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
    612            *           - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
    613            *           - TIM1_IT_CCUpdate: TIM1 Capture Compare Update Interrupt source
    614            *           - TIM1_IT_TRIGGER: TIM1 Trigger Interrupt source
    615            *           - TIM1_IT_BREAK: TIM1 Break Interrupt source
    616            * @param  NewState new state of the TIM1 peripheral.
    617            * @retval None
    618            */

   \                                 In section .far_func.text, align 1, keep-with-next
    619          void TIM1_ITConfig(TIM1_IT_TypeDef  TIM1_IT, FunctionalState NewState)
    620          {
   \                     TIM1_ITConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    621              /* Check the parameters */
    622              assert_param(IS_TIM1_IT_OK(TIM1_IT));
   \   000009 2607                  JRNE      L:??CrossCallReturnLabel_67
   \   00000B AE026E                LDW       X, #0x26e
   \   00000E 8D000000              CALLF     ?Subroutine9
    623              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_67:
   \   000012 3D00                  TNZ       S:?b9
   \   000014 2714                  JREQ      L:??TIM1_ITConfig_0
   \   000016 B600                  LD        A, S:?b9
   \   000018 A101                  CP        A, #0x1
   \   00001A 2707                  JREQ      L:??CrossCallReturnLabel_66
   \   00001C AE026F                LDW       X, #0x26f
   \   00001F 8D000000              CALLF     ?Subroutine9
    624          
    625              if (NewState != DISABLE)
    626              {
    627                  /* Enable the Interrupt sources */
    628                  TIM1->IER |= (uint8_t)TIM1_IT;
   \                     ??CrossCallReturnLabel_66:
   \   000023 B600                  LD        A, S:?b8
   \   000025 CA5254                OR        A, L:0x5254
   \   000028 2007                  JRA       ??TIM1_ITConfig_1
    629              }
    630              else
    631              {
    632                  /* Disable the Interrupt sources */
    633                  TIM1->IER &= (uint8_t)(~(uint8_t)TIM1_IT);
   \                     ??TIM1_ITConfig_0:
   \   00002A 3300                  CPL       S:?b8
   \   00002C B600                  LD        A, S:?b8
   \   00002E C45254                AND       A, L:0x5254
   \                     ??TIM1_ITConfig_1:
   \   000031 C75254                LD        L:0x5254, A
    634              }
    635          }
   \   000034 AC000000              JPF       L:?epilogue_w4
    636          
    637          /**
    638            * @brief  Configures the TIM1 internal Clock.
    639            * @param  None
    640            * @retval None
    641            */

   \                                 In section .far_func.text, align 1, keep-with-next
    642          void TIM1_InternalClockConfig(void)
    643          {
    644              /* Disable slave mode to clock the prescaler directly with the internal clock */
    645              TIM1->SMCR &= (uint8_t)(~TIM1_SMCR_SMS);
   \                     TIM1_InternalClockConfig:
   \   000000 C65252                LD        A, L:0x5252
   \   000003 A4F8                  AND       A, #0xf8
   \   000005 C75252                LD        L:0x5252, A
    646          }
   \   000008 87                    RETF
    647          
    648          /**
    649            * @brief  Configures the TIM1 External clock Mode1.
    650            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
    651            *         This parameter can be one of the following values:
    652            *                       - TIM1_EXTTRGPSC_OFF
    653            *                       - TIM1_EXTTRGPSC_DIV2
    654            *                       - TIM1_EXTTRGPSC_DIV4
    655            *                       - TIM1_EXTTRGPSC_DIV8.
    656            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
    657            *         This parameter can be one of the following values:
    658            *                       - TIM1_EXTTRGPOLARITY_INVERTED
    659            *                       - TIM1_EXTTRGPOLARITY_NONINVERTED
    660            * @param  ExtTRGFilter specifies the External Trigger Filter.
    661            *         This parameter must be a value between 0x00 and 0x0F
    662            * @retval None
    663            */

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000 B700                  LD        S:?b8, A
   \   000002 450000                MOV       S:?b9, S:?b0
   \   000005 450000                MOV       S:?b10, S:?b1
   \   000008 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
    664          void TIM1_ETRClockMode1Config(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
    665                                        TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
    666                                        uint8_t ExtTRGFilter)
    667          {
   \                     TIM1_ETRClockMode1Config:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 8D000000              CALLF     ?Subroutine6
    668              /* Check the parameters */
    669              assert_param(IS_TIM1_EXT_PRESCALER_OK(TIM1_ExtTRGPrescaler));
   \                     ??CrossCallReturnLabel_19:
   \   00000B 2713                  JREQ      L:??CrossCallReturnLabel_69
   \   00000D A110                  CP        A, #0x10
   \   00000F 270F                  JREQ      L:??CrossCallReturnLabel_69
   \   000011 A120                  CP        A, #0x20
   \   000013 270B                  JREQ      L:??CrossCallReturnLabel_69
   \   000015 A130                  CP        A, #0x30
   \   000017 2707                  JREQ      L:??CrossCallReturnLabel_69
   \   000019 AE029D                LDW       X, #0x29d
   \   00001C 8D000000              CALLF     ?Subroutine9
    670              assert_param(IS_TIM1_EXT_POLARITY_OK(TIM1_ExtTRGPolarity));
   \                     ??CrossCallReturnLabel_69:
   \   000020 B600                  LD        A, S:?b9
   \   000022 A180                  CP        A, #0x80
   \   000024 270B                  JREQ      L:??CrossCallReturnLabel_68
   \   000026 3D00                  TNZ       S:?b9
   \   000028 2707                  JREQ      L:??CrossCallReturnLabel_68
   \   00002A AE029E                LDW       X, #0x29e
   \   00002D 8D000000              CALLF     ?Subroutine9
    671          
    672              /* Configure the ETR Clock source */
    673              TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
   \                     ??CrossCallReturnLabel_68:
   \   000031 8D000000              CALLF     ?Subroutine16
    674          
    675              /* Select the External clock mode1 & Select the Trigger selection : ETRF */
    676              TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~(uint8_t)(TIM1_SMCR_SMS | TIM1_SMCR_TS )))
    677                                     | (uint8_t)((uint8_t)TIM1_SLAVEMODE_EXTERNAL1 | TIM1_TS_ETRF ));
   \                     ??CrossCallReturnLabel_139:
   \   000035 C65252                LD        A, L:0x5252
   \   000038 AA77                  OR        A, #0x77
   \   00003A C75252                LD        L:0x5252, A
    678          }
   \   00003D 320000                POP       S:?b10
   \   000040 AC000000              JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000 450000                MOV       S:?b1, S:?b10
   \   000003 450000                MOV       S:?b0, S:?b9
   \   000006 B600                  LD        A, S:?b8
   \   000008 AC000000              JPF       TIM1_ETRConfig
    679          
    680          /**
    681            * @brief  Configures the TIM1 External clock Mode2.
    682            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
    683            *         This parameter can be one of the following values:
    684            *                       - TIM1_EXTTRGPSC_OFF
    685            *                       - TIM1_EXTTRGPSC_DIV2
    686            *                       - TIM1_EXTTRGPSC_DIV4
    687            *                       - TIM1_EXTTRGPSC_DIV8.
    688            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
    689            *         This parameter can be one of the following values:
    690            *                       - TIM1_EXTTRGPOLARITY_INVERTED
    691            *                       - TIM1_EXTTRGPOLARITY_NONINVERTED
    692            * @param  ExtTRGFilter specifies the External Trigger Filter.
    693            *         This parameter must be a value between 0x00 and 0x0F
    694            * @retval None
    695            */

   \                                 In section .far_func.text, align 1, keep-with-next
    696          void TIM1_ETRClockMode2Config(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
    697                                        TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
    698                                        uint8_t ExtTRGFilter)
    699          {
   \                     TIM1_ETRClockMode2Config:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 8D000000              CALLF     ?Subroutine6
    700              /* Check the parameters */
    701              assert_param(IS_TIM1_EXT_PRESCALER_OK(TIM1_ExtTRGPrescaler));
   \                     ??CrossCallReturnLabel_18:
   \   00000B 2713                  JREQ      L:??CrossCallReturnLabel_71
   \   00000D A110                  CP        A, #0x10
   \   00000F 270F                  JREQ      L:??CrossCallReturnLabel_71
   \   000011 A120                  CP        A, #0x20
   \   000013 270B                  JREQ      L:??CrossCallReturnLabel_71
   \   000015 A130                  CP        A, #0x30
   \   000017 2707                  JREQ      L:??CrossCallReturnLabel_71
   \   000019 AE02BD                LDW       X, #0x2bd
   \   00001C 8D000000              CALLF     ?Subroutine9
    702              assert_param(IS_TIM1_EXT_POLARITY_OK(TIM1_ExtTRGPolarity));
   \                     ??CrossCallReturnLabel_71:
   \   000020 B600                  LD        A, S:?b9
   \   000022 A180                  CP        A, #0x80
   \   000024 270B                  JREQ      L:??CrossCallReturnLabel_70
   \   000026 3D00                  TNZ       S:?b9
   \   000028 2707                  JREQ      L:??CrossCallReturnLabel_70
   \   00002A AE02BE                LDW       X, #0x2be
   \   00002D 8D000000              CALLF     ?Subroutine9
    703          
    704              /* Configure the ETR Clock source */
    705              TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
   \                     ??CrossCallReturnLabel_70:
   \   000031 8D000000              CALLF     ?Subroutine16
    706          
    707              /* Enable the External clock mode2 */
    708              TIM1->ETR |= TIM1_ETR_ECE;
   \                     ??CrossCallReturnLabel_140:
   \   000035 721C5253              BSET      L:0x5253, #0x6
    709          }
   \   000039 320000                POP       S:?b10
   \   00003C AC000000              JPF       L:?epilogue_w4
    710          
    711          /**
    712            * @brief  Configures the TIM1 External Trigger.
    713            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
    714            *         This parameter can be one of the following values:
    715            *                       - TIM1_EXTTRGPSC_OFF
    716            *                       - TIM1_EXTTRGPSC_DIV2
    717            *                       - TIM1_EXTTRGPSC_DIV4
    718            *                       - TIM1_EXTTRGPSC_DIV8.
    719            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
    720            *         This parameter can be one of the following values:
    721            *                       - TIM1_EXTTRGPOLARITY_INVERTED
    722            *                       - TIM1_EXTTRGPOLARITY_NONINVERTED
    723            * @param  ExtTRGFilter specifies the External Trigger Filter.
    724            *         This parameter must be a value between 0x00 and 0x0F
    725            * @retval None
    726            */

   \                                 In section .far_func.text, align 1, keep-with-next
    727          void TIM1_ETRConfig(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
    728                              TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
    729                              uint8_t ExtTRGFilter)
    730          {
   \                     TIM1_ETRConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 B700                  LD        S:?b9, A
   \   000009 450000                MOV       S:?b8, S:?b0
   \   00000C 450000                MOV       S:?b10, S:?b1
    731              /* Check the parameters */
    732              assert_param(IS_TIM1_EXT_TRG_FILTER_OK(ExtTRGFilter));
   \   00000F B600                  LD        A, S:?b10
   \   000011 A110                  CP        A, #0x10
   \   000013 2507                  JRC       L:??CrossCallReturnLabel_72
   \   000015 AE02DC                LDW       X, #0x2dc
   \   000018 8D000000              CALLF     ?Subroutine9
    733              /* Set the Prescaler, the Filter value and the Polarity */
    734              TIM1->ETR |= (uint8_t)((uint8_t)(TIM1_ExtTRGPrescaler | (uint8_t)TIM1_ExtTRGPolarity )|
    735                                (uint8_t)ExtTRGFilter );
   \                     ??CrossCallReturnLabel_72:
   \   00001C B600                  LD        A, S:?b8
   \   00001E BA00                  OR        A, S:?b9
   \   000020 BA00                  OR        A, S:?b10
   \   000022 CA5253                OR        A, L:0x5253
   \   000025 C75253                LD        L:0x5253, A
    736          }
   \   000028 320000                POP       S:?b10
   \   00002B AC000000              JPF       L:?epilogue_w4
    737          
    738          /**
    739            * @brief  Configures the TIM1 Trigger as External Clock.
    740            * @param  TIM1_TIxExternalCLKSource specifies Trigger source.
    741            *         This parameter can be one of the following values:
    742            *                     - TIM1_TIXEXTERNALCLK1SOURCE_TI1: TI1 Edge Detector
    743            *                     - TIM1_TIXEXTERNALCLK1SOURCE_TI2: Filtered TIM1 Input 1
    744            *                     - TIM1_TIXEXTERNALCLK1SOURCE_TI1ED: Filtered TIM1 Input 2
    745            * @param  TIM1_ICPolarity specifies the TIx Polarity.
    746            *         This parameter can be:
    747            *                     - TIM1_ICPOLARITY_RISING
    748            *                     - TIM1_ICPOLARITY_FALLING
    749            * @param  ICFilter specifies the filter value.
    750            *         This parameter must be a value between 0x00 and 0x0F
    751            * @retval None
    752            */

   \                                 In section .far_func.text, align 1, keep-with-next
    753          void TIM1_TIxExternalClockConfig(TIM1_TIxExternalCLK1Source_TypeDef TIM1_TIxExternalCLKSource,
    754                                           TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
    755                                           uint8_t ICFilter)
    756          {
   \                     TIM1_TIxExternalClockConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 8D000000              CALLF     ?Subroutine6
    757              /* Check the parameters */
    758              assert_param(IS_TIM1_TIXCLK_SOURCE_OK(TIM1_TIxExternalCLKSource));
   \                     ??CrossCallReturnLabel_17:
   \   00000B A140                  CP        A, #0x40
   \   00000D 270F                  JREQ      L:??CrossCallReturnLabel_75
   \   00000F A160                  CP        A, #0x60
   \   000011 270B                  JREQ      L:??CrossCallReturnLabel_75
   \   000013 A150                  CP        A, #0x50
   \   000015 2707                  JREQ      L:??CrossCallReturnLabel_75
   \   000017 AE02F6                LDW       X, #0x2f6
   \   00001A 8D000000              CALLF     ?Subroutine9
    759              assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_ICPolarity));
   \                     ??CrossCallReturnLabel_75:
   \   00001E 3D00                  TNZ       S:?b9
   \   000020 270D                  JREQ      L:??CrossCallReturnLabel_74
   \   000022 B600                  LD        A, S:?b9
   \   000024 A101                  CP        A, #0x1
   \   000026 2707                  JREQ      L:??CrossCallReturnLabel_74
   \   000028 AE02F7                LDW       X, #0x2f7
   \   00002B 8D000000              CALLF     ?Subroutine9
    760              assert_param(IS_TIM1_IC_FILTER_OK(ICFilter));
   \                     ??CrossCallReturnLabel_74:
   \   00002F B600                  LD        A, S:?b10
   \   000031 A110                  CP        A, #0x10
   \   000033 2507                  JRC       L:??CrossCallReturnLabel_73
   \   000035 AE02F8                LDW       X, #0x2f8
   \   000038 8D000000              CALLF     ?Subroutine9
    761          
    762              /* Configure the TIM1 Input Clock Source */
    763              if (TIM1_TIxExternalCLKSource == TIM1_TIXEXTERNALCLK1SOURCE_TI2)
   \                     ??CrossCallReturnLabel_73:
   \   00003C B600                  LD        A, S:?b8
   \   00003E A160                  CP        A, #0x60
   \   000040 450000                MOV       S:?b1, S:?b10
   \   000043 35010000              MOV       S:?b0, #0x1
   \   000047 2608                  JRNE      L:??TIM1_TIxExternalClockConfig_0
    764              {
    765                  TI2_Config((uint8_t)TIM1_ICPolarity, (uint8_t)TIM1_ICSELECTION_DIRECTTI, (uint8_t)ICFilter);
   \   000049 B600                  LD        A, S:?b9
   \   00004B 8D000000              CALLF     TI2_Config
   \   00004F 2006                  JRA       L:??TIM1_TIxExternalClockConfig_1
    766              }
    767              else
    768              {
    769                  TI1_Config((uint8_t)TIM1_ICPolarity, (uint8_t)TIM1_ICSELECTION_DIRECTTI, (uint8_t)ICFilter);
   \                     ??TIM1_TIxExternalClockConfig_0:
   \   000051 B600                  LD        A, S:?b9
   \   000053 8D000000              CALLF     TI1_Config
    770              }
    771          
    772              /* Select the Trigger source */
    773              TIM1_SelectInputTrigger((TIM1_TS_TypeDef)TIM1_TIxExternalCLKSource);
   \                     ??TIM1_TIxExternalClockConfig_1:
   \   000057 B600                  LD        A, S:?b8
   \   000059 8D000000              CALLF     TIM1_SelectInputTrigger
    774          
    775              /* Select the External clock mode1 */
    776              TIM1->SMCR |= (uint8_t)(TIM1_SLAVEMODE_EXTERNAL1);
   \   00005D C65252                LD        A, L:0x5252
   \   000060 AA07                  OR        A, #0x7
   \   000062 C75252                LD        L:0x5252, A
    777          }
   \   000065 320000                POP       S:?b10
   \   000068 AC000000              JPF       L:?epilogue_w4
    778          
    779          /**
    780            * @brief  Selects the TIM1 Input Trigger source.
    781            * @param   TIM1_InputTriggerSource specifies Input Trigger source.
    782            * This parameter can be one of the following values:
    783            *                       - TIM1_TS_TI1F_ED: TI1 Edge Detector
    784            *                       - TIM1_TS_TI1FP1: Filtered Timer Input 1
    785            *                       - TIM1_TS_TI2FP2: Filtered Timer Input 2
    786            *                       - TIM1_TS_ETRF: External Trigger input
    787            * @retval None
    788            */

   \                                 In section .far_func.text, align 1, keep-with-next
    789          void TIM1_SelectInputTrigger(TIM1_TS_TypeDef TIM1_InputTriggerSource)
    790          {
   \                     TIM1_SelectInputTrigger:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    791              /* Check the parameters */
    792              assert_param(IS_TIM1_TRIGGER_SELECTION_OK(TIM1_InputTriggerSource));
   \   000005 A140                  CP        A, #0x40
   \   000007 271B                  JREQ      L:??CrossCallReturnLabel_76
   \   000009 A150                  CP        A, #0x50
   \   00000B 2717                  JREQ      L:??CrossCallReturnLabel_76
   \   00000D A160                  CP        A, #0x60
   \   00000F 2713                  JREQ      L:??CrossCallReturnLabel_76
   \   000011 A170                  CP        A, #0x70
   \   000013 270F                  JREQ      L:??CrossCallReturnLabel_76
   \   000015 A130                  CP        A, #0x30
   \   000017 270B                  JREQ      L:??CrossCallReturnLabel_76
   \   000019 3D00                  TNZ       S:?b8
   \   00001B 2707                  JREQ      L:??CrossCallReturnLabel_76
   \   00001D AE0318                LDW       X, #0x318
   \   000020 8D000000              CALLF     ?Subroutine9
    793          
    794              /* Select the Tgigger Source */
    795              TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~TIM1_SMCR_TS)) | (uint8_t)TIM1_InputTriggerSource);
   \                     ??CrossCallReturnLabel_76:
   \   000024 C65252                LD        A, L:0x5252
   \   000027 A48F                  AND       A, #0x8f
   \   000029 BA00                  OR        A, S:?b8
   \   00002B C75252                LD        L:0x5252, A
    796          }
   \   00002E 320000                POP       S:?b8
   \   000031 87                    RETF
    797          
    798          
    799          /**
    800            * @brief  Enables or Disables the TIM1 Update event.
    801            * @param   NewState new state of the TIM1 peripheral Preload register. This parameter can
    802            * be ENABLE or DISABLE.
    803            * @retval None
    804            */
    805          

   \                                 In section .far_func.text, align 1, keep-with-next
    806          void TIM1_UpdateDisableConfig(FunctionalState NewState)
    807          {
    808              /* Check the parameters */
    809              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_UpdateDisableConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_UpdateDisableConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_77
   \   000007 AE0329                LDW       X, #0x329
   \   00000A 8D000000              CALLF     ?Subroutine9
    810          
    811              /* Set or Reset the UDIS Bit */
    812              if (NewState != DISABLE)
    813              {
    814                  TIM1->CR1 |= TIM1_CR1_UDIS;
   \                     ??CrossCallReturnLabel_77:
   \   00000E 72125250              BSET      L:0x5250, #0x1
   \   000012 87                    RETF
    815              }
    816              else
    817              {
    818                  TIM1->CR1 &= (uint8_t)(~TIM1_CR1_UDIS);
   \                     ??TIM1_UpdateDisableConfig_0:
   \   000013 72135250              BRES      L:0x5250, #0x1
    819              }
    820          }
   \   000017 87                    RETF
    821          
    822          /**
    823            * @brief  Selects the TIM1 Update Request Interrupt source.
    824            * @param   TIM1_UpdateSource specifies the Update source.
    825            * This parameter can be one of the following values
    826            *                       - TIM1_UPDATESOURCE_REGULAR
    827            *                       - TIM1_UPDATESOURCE_GLOBAL
    828            * @retval None
    829            */

   \                                 In section .far_func.text, align 1, keep-with-next
    830          void TIM1_UpdateRequestConfig(TIM1_UpdateSource_TypeDef TIM1_UpdateSource)
    831          {
    832              /* Check the parameters */
    833              assert_param(IS_TIM1_UPDATE_SOURCE_OK(TIM1_UpdateSource));
   \                     TIM1_UpdateRequestConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_UpdateRequestConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_78
   \   000007 AE0341                LDW       X, #0x341
   \   00000A 8D000000              CALLF     ?Subroutine9
    834          
    835              /* Set or Reset the URS Bit */
    836              if (TIM1_UpdateSource != TIM1_UPDATESOURCE_GLOBAL)
    837              {
    838                  TIM1->CR1 |= TIM1_CR1_URS;
   \                     ??CrossCallReturnLabel_78:
   \   00000E 72145250              BSET      L:0x5250, #0x2
   \   000012 87                    RETF
    839              }
    840              else
    841              {
    842                  TIM1->CR1 &= (uint8_t)(~TIM1_CR1_URS);
   \                     ??TIM1_UpdateRequestConfig_0:
   \   000013 72155250              BRES      L:0x5250, #0x2
    843              }
    844          }
   \   000017 87                    RETF
    845          
    846          
    847          /**
    848            * @brief  Enables or Disables the TIM1s Hall sensor interface.
    849            * @param   NewState new state of the TIM1 Hall sensor interface.This parameter can
    850            * be ENABLE or DISABLE.
    851            * @retval None
    852            */

   \                                 In section .far_func.text, align 1, keep-with-next
    853          void TIM1_SelectHallSensor(FunctionalState NewState)
    854          {
    855              /* Check the parameters */
    856              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_SelectHallSensor:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_SelectHallSensor_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_79
   \   000007 AE0358                LDW       X, #0x358
   \   00000A 8D000000              CALLF     ?Subroutine9
    857          
    858              /* Set or Reset the TI1S Bit */
    859              if (NewState != DISABLE)
    860              {
    861                  TIM1->CR2 |= TIM1_CR2_TI1S;
   \                     ??CrossCallReturnLabel_79:
   \   00000E 721E5251              BSET      L:0x5251, #0x7
   \   000012 87                    RETF
    862              }
    863              else
    864              {
    865                  TIM1->CR2 &= (uint8_t)(~TIM1_CR2_TI1S);
   \                     ??TIM1_SelectHallSensor_0:
   \   000013 721F5251              BRES      L:0x5251, #0x7
    866              }
    867          }
   \   000017 87                    RETF
    868          
    869          
    870          /**
    871            * @brief  Selects the TIM1s One Pulse Mode.
    872            * @param   TIM1_OPMode specifies the OPM Mode to be used.
    873            * This parameter can be one of the following values
    874            *                    - TIM1_OPMODE_SINGLE
    875            *                    - TIM1_OPMODE_REPETITIVE
    876            * @retval None
    877            */

   \                                 In section .far_func.text, align 1, keep-with-next
    878          void TIM1_SelectOnePulseMode(TIM1_OPMode_TypeDef TIM1_OPMode)
    879          {
    880              /* Check the parameters */
    881              assert_param(IS_TIM1_OPM_MODE_OK(TIM1_OPMode));
   \                     TIM1_SelectOnePulseMode:
   \   000000 A101                  CP        A, #0x1
   \   000002 270A                  JREQ      L:??CrossCallReturnLabel_80
   \   000004 4D                    TNZ       A
   \   000005 270C                  JREQ      L:??TIM1_SelectOnePulseMode_0
   \   000007 AE0371                LDW       X, #0x371
   \   00000A 8D000000              CALLF     ?Subroutine9
    882          
    883              /* Set or Reset the OPM Bit */
    884              if (TIM1_OPMode != TIM1_OPMODE_REPETITIVE)
    885              {
    886                  TIM1->CR1 |= TIM1_CR1_OPM;
   \                     ??CrossCallReturnLabel_80:
   \   00000E 72165250              BSET      L:0x5250, #0x3
   \   000012 87                    RETF
    887              }
    888              else
    889              {
    890                  TIM1->CR1 &= (uint8_t)(~TIM1_CR1_OPM);
   \                     ??TIM1_SelectOnePulseMode_0:
   \   000013 72175250              BRES      L:0x5250, #0x3
    891              }
    892          
    893          }
   \   000017 87                    RETF
    894          
    895          
    896          /**
    897            * @brief  Selects the TIM1 Trigger Output Mode.
    898            * @param   TIM1_TRGOSource specifies the Trigger Output source.
    899            * This parameter can be one of the following values
    900            *                       - TIM1_TRGOSOURCE_RESET
    901            *                       - TIM1_TRGOSOURCE_ENABLE
    902            *                       - TIM1_TRGOSOURCE_UPDATE
    903            *                       - TIM1_TRGOSource_OC1
    904            *                       - TIM1_TRGOSOURCE_OC1REF
    905            *                       - TIM1_TRGOSOURCE_OC2REF
    906            *                       - TIM1_TRGOSOURCE_OC3REF
    907            * @retval None
    908            */

   \                                 In section .far_func.text, align 1, keep-with-next
    909          void TIM1_SelectOutputTrigger(TIM1_TRGOSource_TypeDef TIM1_TRGOSource)
    910          {
   \                     TIM1_SelectOutputTrigger:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    911              /* Check the parameters */
    912              assert_param(IS_TIM1_TRGO_SOURCE_OK(TIM1_TRGOSource));
   \   000005 271F                  JREQ      L:??CrossCallReturnLabel_81
   \   000007 A110                  CP        A, #0x10
   \   000009 271B                  JREQ      L:??CrossCallReturnLabel_81
   \   00000B A120                  CP        A, #0x20
   \   00000D 2717                  JREQ      L:??CrossCallReturnLabel_81
   \   00000F A130                  CP        A, #0x30
   \   000011 2713                  JREQ      L:??CrossCallReturnLabel_81
   \   000013 A140                  CP        A, #0x40
   \   000015 270F                  JREQ      L:??CrossCallReturnLabel_81
   \   000017 A150                  CP        A, #0x50
   \   000019 270B                  JREQ      L:??CrossCallReturnLabel_81
   \   00001B A160                  CP        A, #0x60
   \   00001D 2707                  JREQ      L:??CrossCallReturnLabel_81
   \   00001F AE0390                LDW       X, #0x390
   \   000022 8D000000              CALLF     ?Subroutine9
    913              
    914              /* Reset the MMS Bits & Select the TRGO source */
    915              TIM1->CR2 = (uint8_t)((uint8_t)(TIM1->CR2 & (uint8_t)(~TIM1_CR2_MMS)) | 
    916                                    (uint8_t) TIM1_TRGOSource);
   \                     ??CrossCallReturnLabel_81:
   \   000026 C65251                LD        A, L:0x5251
   \   000029 A48F                  AND       A, #0x8f
   \   00002B BA00                  OR        A, S:?b8
   \   00002D C75251                LD        L:0x5251, A
    917          }
   \   000030 320000                POP       S:?b8
   \   000033 87                    RETF
    918          
    919          /**
    920            * @brief  Selects the TIM1 Slave Mode.
    921            * @param   TIM1_SlaveMode specifies the TIM1 Slave Mode.
    922            * This parameter can be one of the following values
    923            *                       - TIM1_SLAVEMODE_RESET
    924            *                       - TIM1_SLAVEMODE_GATED
    925            *                       - TIM1_SLAVEMODE_TRIGGER
    926            *                       - TIM1_SLAVEMODE_EXTERNAL1
    927            * @retval None
    928            */

   \                                 In section .far_func.text, align 1, keep-with-next
    929          void TIM1_SelectSlaveMode(TIM1_SlaveMode_TypeDef TIM1_SlaveMode)
    930          {
   \                     TIM1_SelectSlaveMode:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    931          
    932              /* Check the parameters */
    933              assert_param(IS_TIM1_SLAVE_MODE_OK(TIM1_SlaveMode));
   \   000005 A104                  CP        A, #0x4
   \   000007 2713                  JREQ      L:??CrossCallReturnLabel_82
   \   000009 A105                  CP        A, #0x5
   \   00000B 270F                  JREQ      L:??CrossCallReturnLabel_82
   \   00000D A106                  CP        A, #0x6
   \   00000F 270B                  JREQ      L:??CrossCallReturnLabel_82
   \   000011 A107                  CP        A, #0x7
   \   000013 2707                  JREQ      L:??CrossCallReturnLabel_82
   \   000015 AE03A5                LDW       X, #0x3a5
   \   000018 8D000000              CALLF     ?Subroutine9
    934          
    935              /* Reset the SMS Bits */ /* Select the Slave Mode */
    936              TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~TIM1_SMCR_SMS)) |
    937                                     (uint8_t)TIM1_SlaveMode);
   \                     ??CrossCallReturnLabel_82:
   \   00001C C65252                LD        A, L:0x5252
   \   00001F A4F8                  AND       A, #0xf8
   \   000021 BA00                  OR        A, S:?b8
   \   000023 C75252                LD        L:0x5252, A
    938          
    939          }
   \   000026 320000                POP       S:?b8
   \   000029 87                    RETF
    940          
    941          /**
    942            * @brief  Sets or Resets the TIM1 Master/Slave Mode.
    943            * @param   NewState new state of the synchronization between TIM1 and its slaves
    944            *  (through TRGO). This parameter can be ENABLE or DISABLE.
    945            * @retval None
    946            */

   \                                 In section .far_func.text, align 1, keep-with-next
    947          void TIM1_SelectMasterSlaveMode(FunctionalState NewState)
    948          {
    949              /* Check the parameters */
    950              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_SelectMasterSlaveMode:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_SelectMasterSlaveMode_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_83
   \   000007 AE03B6                LDW       X, #0x3b6
   \   00000A 8D000000              CALLF     ?Subroutine9
    951          
    952              /* Set or Reset the MSM Bit */
    953              if (NewState != DISABLE)
    954              {
    955                  TIM1->SMCR |= TIM1_SMCR_MSM;
   \                     ??CrossCallReturnLabel_83:
   \   00000E 721E5252              BSET      L:0x5252, #0x7
   \   000012 87                    RETF
    956              }
    957              else
    958              {
    959                  TIM1->SMCR &= (uint8_t)(~TIM1_SMCR_MSM);
   \                     ??TIM1_SelectMasterSlaveMode_0:
   \   000013 721F5252              BRES      L:0x5252, #0x7
    960              }
    961          }
   \   000017 87                    RETF
    962          
    963          /**
    964            * @brief  Configures the TIM1 Encoder Interface.
    965            * @param   TIM1_EncoderMode specifies the TIM1 Encoder Mode.
    966            * This parameter can be one of the following values
    967            * - TIM1_ENCODERMODE_TI1: Counter counts on TI1FP1 edge
    968          	* depending on TI2FP2 level.
    969            * - TIM1_ENCODERMODE_TI2: Counter counts on TI2FP2 edge
    970            *	depending on TI1FP1 level.
    971            * - TIM1_ENCODERMODE_TI12: Counter counts on both TI1FP1 and
    972            * TI2FP2 edges depending on the level of the other input.
    973            * @param   TIM1_IC1Polarity specifies the IC1 Polarity.
    974            * This parameter can be one of the following values
    975            *                       - TIM1_ICPOLARITY_FALLING
    976            *                       - TIM1_ICPOLARITY_RISING
    977            * @param   TIM1_IC2Polarity specifies the IC2 Polarity.
    978            * This parameter can be one of the following values
    979            *                       - TIM1_ICPOLARITY_FALLING
    980            *                       - TIM1_ICPOLARITY_RISING
    981            * @retval None
    982            */

   \                                 In section .far_func.text, align 1, keep-with-next
    983          void TIM1_EncoderInterfaceConfig(TIM1_EncoderMode_TypeDef TIM1_EncoderMode,
    984                                           TIM1_ICPolarity_TypeDef TIM1_IC1Polarity,
    985                                           TIM1_ICPolarity_TypeDef TIM1_IC2Polarity)
    986          {
   \                     TIM1_EncoderInterfaceConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 B700                  LD        S:?b10, A
   \   000009 450000                MOV       S:?b8, S:?b0
   \   00000C 450000                MOV       S:?b9, S:?b1
    987          
    988          
    989              /* Check the parameters */
    990              assert_param(IS_TIM1_ENCODER_MODE_OK(TIM1_EncoderMode));
   \   00000F A101                  CP        A, #0x1
   \   000011 270F                  JREQ      L:??CrossCallReturnLabel_86
   \   000013 A102                  CP        A, #0x2
   \   000015 270B                  JREQ      L:??CrossCallReturnLabel_86
   \   000017 A103                  CP        A, #0x3
   \   000019 2707                  JREQ      L:??CrossCallReturnLabel_86
   \   00001B AE03DE                LDW       X, #0x3de
   \   00001E 8D000000              CALLF     ?Subroutine9
    991              assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_IC1Polarity));
   \                     ??CrossCallReturnLabel_86:
   \   000022 3D00                  TNZ       S:?b8
   \   000024 270D                  JREQ      L:??CrossCallReturnLabel_85
   \   000026 B600                  LD        A, S:?b8
   \   000028 A101                  CP        A, #0x1
   \   00002A 2707                  JREQ      L:??CrossCallReturnLabel_85
   \   00002C AE03DF                LDW       X, #0x3df
   \   00002F 8D000000              CALLF     ?Subroutine9
    992              assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_IC2Polarity));
   \                     ??CrossCallReturnLabel_85:
   \   000033 3D00                  TNZ       S:?b9
   \   000035 270D                  JREQ      L:??CrossCallReturnLabel_84
   \   000037 B600                  LD        A, S:?b9
   \   000039 A101                  CP        A, #0x1
   \   00003B 2707                  JREQ      L:??CrossCallReturnLabel_84
   \   00003D AE03E0                LDW       X, #0x3e0
   \   000040 8D000000              CALLF     ?Subroutine9
    993          
    994              /* Set the TI1 and the TI2 Polarities */
    995              if (TIM1_IC1Polarity != TIM1_ICPOLARITY_RISING)
   \                     ??CrossCallReturnLabel_84:
   \   000044 3D00                  TNZ       S:?b8
   \   000046 2706                  JREQ      L:??TIM1_EncoderInterfaceConfig_0
    996              {
    997                  TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \   000048 7212525C              BSET      L:0x525c, #0x1
   \   00004C 2004                  JRA       L:??TIM1_EncoderInterfaceConfig_1
    998              }
    999              else
   1000              {
   1001                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TIM1_EncoderInterfaceConfig_0:
   \   00004E 7213525C              BRES      L:0x525c, #0x1
   1002              }
   1003          
   1004              if (TIM1_IC2Polarity != TIM1_ICPOLARITY_RISING)
   \                     ??TIM1_EncoderInterfaceConfig_1:
   \   000052 3D00                  TNZ       S:?b9
   \   000054 2706                  JREQ      L:??TIM1_EncoderInterfaceConfig_2
   1005              {
   1006                  TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \   000056 721A525C              BSET      L:0x525c, #0x5
   \   00005A 2004                  JRA       L:??TIM1_EncoderInterfaceConfig_3
   1007              }
   1008              else
   1009              {
   1010                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TIM1_EncoderInterfaceConfig_2:
   \   00005C 721B525C              BRES      L:0x525c, #0x5
   1011              }
   1012              /* Set the encoder Mode */
   1013              TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(TIM1_SMCR_MSM | TIM1_SMCR_TS))
   1014                                     | (uint8_t) TIM1_EncoderMode);
   \                     ??TIM1_EncoderInterfaceConfig_3:
   \   000060 C65252                LD        A, L:0x5252
   \   000063 A4F0                  AND       A, #0xf0
   \   000065 BA00                  OR        A, S:?b10
   \   000067 C75252                LD        L:0x5252, A
   1015          
   1016              /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1017              TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_CCxS)) 
   1018                                      | (uint8_t) CCMR_TIxDirect_Set);
   \   00006A C65258                LD        A, L:0x5258
   \   00006D A4FC                  AND       A, #0xfc
   \   00006F AA01                  OR        A, #0x1
   \   000071 C75258                LD        L:0x5258, A
   1019              TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_CCxS))
   1020                                      | (uint8_t) CCMR_TIxDirect_Set);
   \   000074 C65259                LD        A, L:0x5259
   \   000077 A4FC                  AND       A, #0xfc
   \   000079 AA01                  OR        A, #0x1
   \   00007B C75259                LD        L:0x5259, A
   1021          
   1022          }
   \   00007E 320000                POP       S:?b10
   \   000081 AC000000              JPF       L:?epilogue_w4
   1023          
   1024          /**
   1025            * @brief  Configures the TIM1 Prescaler.
   1026            * @param   Prescaler specifies the Prescaler Register value
   1027            * This parameter must be a value between 0x0000 and 0xFFFF
   1028            * @param   TIM1_PSCReloadMode specifies the TIM1 Prescaler Reload mode.
   1029            * This parameter can be one of the following values
   1030            * - TIM1_PSCRELOADMODE_IMMEDIATE: The Prescaler is loaded immediately.
   1031            * - TIM1_PSCRELOADMODE_UPDATE: The Prescaler is loaded at the update event.
   1032            * @retval None
   1033            */
   1034          

   \                                 In section .far_func.text, align 1, keep-with-next
   1035          void TIM1_PrescalerConfig(uint16_t Prescaler,
   1036                                    TIM1_PSCReloadMode_TypeDef TIM1_PSCReloadMode)
   1037          {
   \                     TIM1_PrescalerConfig:
   \   000000 8D000000              CALLF     L:?push_w5
   \   000004 3B0000                PUSH      S:?b8
   \   000007 BF00                  LDW       S:?w5, X
   \   000009 B700                  LD        S:?b8, A
   1038              /* Check the parameters */
   1039              assert_param(IS_TIM1_PRESCALER_RELOAD_OK(TIM1_PSCReloadMode));
   \   00000B 270B                  JREQ      L:??CrossCallReturnLabel_87
   \   00000D A101                  CP        A, #0x1
   \   00000F 2707                  JREQ      L:??CrossCallReturnLabel_87
   \   000011 AE040F                LDW       X, #0x40f
   \   000014 8D000000              CALLF     ?Subroutine9
   1040          
   1041              /* Set the Prescaler value */
   1042              TIM1->PSCRH = (uint8_t)(Prescaler >> 8);
   \                     ??CrossCallReturnLabel_87:
   \   000018 8D000000              CALLF     ?Subroutine12
   1043              TIM1->PSCRL = (uint8_t)(Prescaler);
   1044          
   1045              /* Set or reset the UG Bit */
   1046              TIM1->EGR = (uint8_t)TIM1_PSCReloadMode;
   \                     ??CrossCallReturnLabel_130:
   \   00001C B600                  LD        A, S:?b8
   \   00001E C75257                LD        L:0x5257, A
   1047          
   1048          }
   \   000021 320000                POP       S:?b8
   \   000024 8D000000              CALLF     L:?pop_w5
   \   000028 87                    RETF
   1049          
   1050          /**
   1051            * @brief  Specifies the TIM1 Counter Mode to be used.
   1052            * @param   TIM1_CounterMode specifies the Counter Mode to be used
   1053            * This parameter can be one of the following values:
   1054            * - TIM1_COUNTERMODE_UP: TIM1 Up Counting Mode
   1055            * - TIM1_COUNTERMODE_DOWN: TIM1 Down Counting Mode
   1056            * - TIM1_COUNTERMODE_CENTERALIGNED1: TIM1 Center Aligned Mode1
   1057            * - TIM1_CounterMode_CenterAligned2: TIM1 Center Aligned Mode2
   1058            * - TIM1_COUNTERMODE_CENTERALIGNED3: TIM1 Center Aligned Mode3
   1059            * @retval None
   1060            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1061          void TIM1_CounterModeConfig(TIM1_CounterMode_TypeDef TIM1_CounterMode)
   1062          {
   \                     TIM1_CounterModeConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1063              /* Check the parameters */
   1064              assert_param(IS_TIM1_COUNTER_MODE_OK(TIM1_CounterMode));
   \   000005 2717                  JREQ      L:??CrossCallReturnLabel_88
   \   000007 A110                  CP        A, #0x10
   \   000009 2713                  JREQ      L:??CrossCallReturnLabel_88
   \   00000B A120                  CP        A, #0x20
   \   00000D 270F                  JREQ      L:??CrossCallReturnLabel_88
   \   00000F A140                  CP        A, #0x40
   \   000011 270B                  JREQ      L:??CrossCallReturnLabel_88
   \   000013 A160                  CP        A, #0x60
   \   000015 2707                  JREQ      L:??CrossCallReturnLabel_88
   \   000017 AE0428                LDW       X, #0x428
   \   00001A 8D000000              CALLF     ?Subroutine9
   1065          
   1066          
   1067              /* Reset the CMS and DIR Bits & Set the Counter Mode */
   1068              TIM1->CR1 = (uint8_t)((uint8_t)(TIM1->CR1 & (uint8_t)((uint8_t)(~TIM1_CR1_CMS) & (uint8_t)(~TIM1_CR1_DIR)))
   1069                                    | (uint8_t)TIM1_CounterMode);
   \                     ??CrossCallReturnLabel_88:
   \   00001E C65250                LD        A, L:0x5250
   \   000021 A48F                  AND       A, #0x8f
   \   000023 BA00                  OR        A, S:?b8
   \   000025 C75250                LD        L:0x5250, A
   1070          }
   \   000028 320000                POP       S:?b8
   \   00002B 87                    RETF
   1071          
   1072          
   1073          /**
   1074            * @brief  Forces the TIM1 Channel1 output waveform to active or inactive level.
   1075            * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1076            * This parameter can be one of the following values:
   1077            * - TIM1_FORCEDACTION_ACTIVE: Force active level on OC1REF
   1078            * - TIM1_FORCEDACTION_INACTIVE: Force inactive level on OC1REF.
   1079            * @retval None
   1080            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1081          void TIM1_ForcedOC1Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1082          {
   \                     TIM1_ForcedOC1Config:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1083              /* Check the parameters */
   1084              assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
   \   000005 A150                  CP        A, #0x50
   \   000007 270B                  JREQ      L:??CrossCallReturnLabel_89
   \   000009 A140                  CP        A, #0x40
   \   00000B 2707                  JREQ      L:??CrossCallReturnLabel_89
   \   00000D AE043C                LDW       X, #0x43c
   \   000010 8D000000              CALLF     ?Subroutine9
   1085          
   1086              /* Reset the OCM Bits & Configure the Forced output Mode */
   1087              TIM1->CCMR1 =  (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM))|
   1088                                       (uint8_t)TIM1_ForcedAction);
   \                     ??CrossCallReturnLabel_89:
   \   000014 8D000000              CALLF     ?Subroutine8
   1089          }
   \                     ??CrossCallReturnLabel_22:
   \   000018 320000                POP       S:?b8
   \   00001B 87                    RETF
   1090          
   1091          
   1092          /**
   1093            * @brief  Forces the TIM1 Channel2 output waveform to active or inactive level.
   1094            * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1095            * This parameter can be one of the following values:
   1096            * - TIM1_FORCEDACTION_ACTIVE: Force active level on OC2REF
   1097            * - TIM1_FORCEDACTION_INACTIVE: Force inactive level on OC2REF.
   1098            * @retval None
   1099            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1100          void TIM1_ForcedOC2Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1101          {
   \                     TIM1_ForcedOC2Config:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1102              /* Check the parameters */
   1103              assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
   \   000005 A150                  CP        A, #0x50
   \   000007 270B                  JREQ      L:??CrossCallReturnLabel_90
   \   000009 A140                  CP        A, #0x40
   \   00000B 2707                  JREQ      L:??CrossCallReturnLabel_90
   \   00000D AE044F                LDW       X, #0x44f
   \   000010 8D000000              CALLF     ?Subroutine9
   1104          
   1105              /* Reset the OCM Bits & Configure the Forced output Mode */
   1106              TIM1->CCMR2  =  (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM))
   1107                                        | (uint8_t)TIM1_ForcedAction);
   \                     ??CrossCallReturnLabel_90:
   \   000014 8D000000              CALLF     ?Subroutine7
   1108          }
   \                     ??CrossCallReturnLabel_20:
   \   000018 320000                POP       S:?b8
   \   00001B 87                    RETF
   1109          
   1110          
   1111          /**
   1112            * @brief  Forces the TIM1 Channel3 output waveform to active or inactive level.
   1113            * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1114            * This parameter can be one of the following values:
   1115            *                       - TIM1_FORCEDACTION_ACTIVE: Force active level on OC3REF
   1116            *                       - TIM1_FORCEDACTION_INACTIVE: Force inactive level on
   1117            *                         OC3REF.
   1118            * @retval None
   1119            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1120          void TIM1_ForcedOC3Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1121          {
   \                     TIM1_ForcedOC3Config:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1122              /* Check the parameters */
   1123              assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
   \   000005 A150                  CP        A, #0x50
   \   000007 270B                  JREQ      L:??CrossCallReturnLabel_91
   \   000009 A140                  CP        A, #0x40
   \   00000B 2707                  JREQ      L:??CrossCallReturnLabel_91
   \   00000D AE0463                LDW       X, #0x463
   \   000010 8D000000              CALLF     ?Subroutine9
   1124          
   1125              /* Reset the OCM Bits */ /* Configure The Forced output Mode */
   1126              TIM1->CCMR3  =  (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM))  
   1127                                        | (uint8_t)TIM1_ForcedAction);
   \                     ??CrossCallReturnLabel_91:
   \   000014 8D000000              CALLF     ?Subroutine4
   1128          }
   \                     ??CrossCallReturnLabel_12:
   \   000018 320000                POP       S:?b8
   \   00001B 87                    RETF
   1129          
   1130          
   1131          /**
   1132            * @brief  Forces the TIM1 Channel4 output waveform to active or inactive level.
   1133            * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1134            * This parameter can be one of the following values:
   1135            *                       - TIM1_FORCEDACTION_ACTIVE: Force active level on OC4REF
   1136            *                       - TIM1_FORCEDACTION_INACTIVE: Force inactive level on
   1137            *                         OC4REF.
   1138            * @retval None
   1139            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1140          void TIM1_ForcedOC4Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1141          {
   \                     TIM1_ForcedOC4Config:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1142              /* Check the parameters */
   1143              assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
   \   000005 A150                  CP        A, #0x50
   \   000007 270B                  JREQ      L:??CrossCallReturnLabel_92
   \   000009 A140                  CP        A, #0x40
   \   00000B 2707                  JREQ      L:??CrossCallReturnLabel_92
   \   00000D AE0477                LDW       X, #0x477
   \   000010 8D000000              CALLF     ?Subroutine9
   1144          
   1145              /* Reset the OCM Bits & Configure the Forced output Mode */
   1146              TIM1->CCMR4  =  (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_OCM)) 
   1147                                        | (uint8_t)TIM1_ForcedAction);
   \                     ??CrossCallReturnLabel_92:
   \   000014 8D000000              CALLF     ?Subroutine3
   1148          }
   \                     ??CrossCallReturnLabel_10:
   \   000018 320000                POP       S:?b8
   \   00001B 87                    RETF
   1149          
   1150          
   1151          /**
   1152            * @brief  Enables or disables TIM1 peripheral Preload register on ARR.
   1153            * @param   NewState new state of the TIM1 peripheral Preload register.
   1154            * This parameter can be ENABLE or DISABLE.
   1155            * @retval None
   1156            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1157          void TIM1_ARRPreloadConfig(FunctionalState NewState)
   1158          {
   1159              /* Check the parameters */
   1160              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_ARRPreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_ARRPreloadConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_93
   \   000007 AE0488                LDW       X, #0x488
   \   00000A 8D000000              CALLF     ?Subroutine9
   1161          
   1162              /* Set or Reset the ARPE Bit */
   1163              if (NewState != DISABLE)
   1164              {
   1165                  TIM1->CR1 |= TIM1_CR1_ARPE;
   \                     ??CrossCallReturnLabel_93:
   \   00000E 721E5250              BSET      L:0x5250, #0x7
   \   000012 87                    RETF
   1166              }
   1167              else
   1168              {
   1169                  TIM1->CR1 &= (uint8_t)(~TIM1_CR1_ARPE);
   \                     ??TIM1_ARRPreloadConfig_0:
   \   000013 721F5250              BRES      L:0x5250, #0x7
   1170              }
   1171          }
   \   000017 87                    RETF
   1172          
   1173          
   1174          /**
   1175            * @brief  Selects the TIM1 peripheral Commutation event.
   1176            * @param   NewState new state of the Commutation event.
   1177            * This parameter can be ENABLE or DISABLE.
   1178            * @retval None
   1179            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1180          void TIM1_SelectCOM(FunctionalState NewState)
   1181          {
   1182              /* Check the parameters */
   1183              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_SelectCOM:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_SelectCOM_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_94
   \   000007 AE049F                LDW       X, #0x49f
   \   00000A 8D000000              CALLF     ?Subroutine9
   1184          
   1185              /* Set or Reset the COMS Bit */
   1186              if (NewState != DISABLE)
   1187              {
   1188                  TIM1->CR2 |= TIM1_CR2_COMS;
   \                     ??CrossCallReturnLabel_94:
   \   00000E 72145251              BSET      L:0x5251, #0x2
   \   000012 87                    RETF
   1189              }
   1190              else
   1191              {
   1192                  TIM1->CR2 &= (uint8_t)(~TIM1_CR2_COMS);
   \                     ??TIM1_SelectCOM_0:
   \   000013 72155251              BRES      L:0x5251, #0x2
   1193              }
   1194          }
   \   000017 87                    RETF
   1195          
   1196          /**
   1197            * @brief  Sets or Resets the TIM1 peripheral Capture Compare Preload Control bit.
   1198            * @param   NewState new state of the Capture Compare Preload Control bit.
   1199            * This parameter can be ENABLE or DISABLE.
   1200            * @retval None
   1201            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1202          void TIM1_CCPreloadControl(FunctionalState NewState)
   1203          {
   1204              /* Check the parameters */
   1205              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_CCPreloadControl:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_CCPreloadControl_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_95
   \   000007 AE04B5                LDW       X, #0x4b5
   \   00000A 8D000000              CALLF     ?Subroutine9
   1206          
   1207              /* Set or Reset the CCPC Bit */
   1208              if (NewState != DISABLE)
   1209              {
   1210                  TIM1->CR2 |= TIM1_CR2_CCPC;
   \                     ??CrossCallReturnLabel_95:
   \   00000E 72105251              BSET      L:0x5251, #0x0
   \   000012 87                    RETF
   1211              }
   1212              else
   1213              {
   1214                  TIM1->CR2 &= (uint8_t)(~TIM1_CR2_CCPC);
   \                     ??TIM1_CCPreloadControl_0:
   \   000013 72115251              BRES      L:0x5251, #0x0
   1215              }
   1216          }
   \   000017 87                    RETF
   1217          
   1218          
   1219          /**
   1220            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR1.
   1221            * @param   NewState new state of the Capture Compare Preload register.
   1222            * This parameter can be ENABLE or DISABLE.
   1223            * @retval None
   1224            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1225          void TIM1_OC1PreloadConfig(FunctionalState NewState)
   1226          {
   1227              /* Check the parameters */
   1228              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_OC1PreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC1PreloadConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_96
   \   000007 AE04CC                LDW       X, #0x4cc
   \   00000A 8D000000              CALLF     ?Subroutine9
   1229          
   1230              /* Set or Reset the OC1PE Bit */
   1231              if (NewState != DISABLE)
   1232              {
   1233                  TIM1->CCMR1 |= TIM1_CCMR_OCxPE;
   \                     ??CrossCallReturnLabel_96:
   \   00000E 72165258              BSET      L:0x5258, #0x3
   \   000012 87                    RETF
   1234              }
   1235              else
   1236              {
   1237                  TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC1PreloadConfig_0:
   \   000013 72175258              BRES      L:0x5258, #0x3
   1238              }
   1239          }
   \   000017 87                    RETF
   1240          
   1241          
   1242          /**
   1243            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR2.
   1244            * @param   NewState new state of the Capture Compare Preload register.
   1245            * This parameter can be ENABLE or DISABLE.
   1246            * @retval None
   1247            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1248          void TIM1_OC2PreloadConfig(FunctionalState NewState)
   1249          {
   1250              /* Check the parameters */
   1251              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_OC2PreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC2PreloadConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_97
   \   000007 AE04E3                LDW       X, #0x4e3
   \   00000A 8D000000              CALLF     ?Subroutine9
   1252          
   1253              /* Set or Reset the OC2PE Bit */
   1254              if (NewState != DISABLE)
   1255              {
   1256                  TIM1->CCMR2 |= TIM1_CCMR_OCxPE;
   \                     ??CrossCallReturnLabel_97:
   \   00000E 72165259              BSET      L:0x5259, #0x3
   \   000012 87                    RETF
   1257              }
   1258              else
   1259              {
   1260                  TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC2PreloadConfig_0:
   \   000013 72175259              BRES      L:0x5259, #0x3
   1261              }
   1262          }
   \   000017 87                    RETF
   1263          
   1264          
   1265          /**
   1266            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR3.
   1267            * @param   NewState new state of the Capture Compare Preload register.
   1268            * This parameter can be ENABLE or DISABLE.
   1269            * @retval None
   1270            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1271          void TIM1_OC3PreloadConfig(FunctionalState NewState)
   1272          {
   1273              /* Check the parameters */
   1274              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_OC3PreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC3PreloadConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_98
   \   000007 AE04FA                LDW       X, #0x4fa
   \   00000A 8D000000              CALLF     ?Subroutine9
   1275          
   1276              /* Set or Reset the OC3PE Bit */
   1277              if (NewState != DISABLE)
   1278              {
   1279                  TIM1->CCMR3 |= TIM1_CCMR_OCxPE;
   \                     ??CrossCallReturnLabel_98:
   \   00000E 7216525A              BSET      L:0x525a, #0x3
   \   000012 87                    RETF
   1280              }
   1281              else
   1282              {
   1283                  TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC3PreloadConfig_0:
   \   000013 7217525A              BRES      L:0x525a, #0x3
   1284              }
   1285          }
   \   000017 87                    RETF
   1286          
   1287          
   1288          /**
   1289            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR4.
   1290            * @param   NewState new state of the Capture Compare Preload register.
   1291            * This parameter can be ENABLE or DISABLE.
   1292            * @retval None
   1293            */
   1294          

   \                                 In section .far_func.text, align 1, keep-with-next
   1295          void TIM1_OC4PreloadConfig(FunctionalState NewState)
   1296          {
   1297              /* Check the parameters */
   1298              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_OC4PreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC4PreloadConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_99
   \   000007 AE0512                LDW       X, #0x512
   \   00000A 8D000000              CALLF     ?Subroutine9
   1299          
   1300              /* Set or Reset the OC4PE Bit */
   1301              if (NewState != DISABLE)
   1302              {
   1303                  TIM1->CCMR4 |= TIM1_CCMR_OCxPE;
   \                     ??CrossCallReturnLabel_99:
   \   00000E 7216525B              BSET      L:0x525b, #0x3
   \   000012 87                    RETF
   1304              }
   1305              else
   1306              {
   1307                  TIM1->CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC4PreloadConfig_0:
   \   000013 7217525B              BRES      L:0x525b, #0x3
   1308              }
   1309          }
   \   000017 87                    RETF
   1310          
   1311          /**
   1312            * @brief  Configures the TIM1 Capture Compare 1 Fast feature.
   1313            * @param   NewState new state of the Output Compare Fast Enable bit.
   1314            * This parameter can be ENABLE or DISABLE.
   1315            * @retval None
   1316            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1317          void TIM1_OC1FastConfig(FunctionalState NewState)
   1318          {
   1319              /* Check the parameters */
   1320              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_OC1FastConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC1FastConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_100
   \   000007 AE0528                LDW       X, #0x528
   \   00000A 8D000000              CALLF     ?Subroutine9
   1321          
   1322              /* Set or Reset the OC1FE Bit */
   1323              if (NewState != DISABLE)
   1324              {
   1325                  TIM1->CCMR1 |= TIM1_CCMR_OCxFE;
   \                     ??CrossCallReturnLabel_100:
   \   00000E 72145258              BSET      L:0x5258, #0x2
   \   000012 87                    RETF
   1326              }
   1327              else
   1328              {
   1329                  TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC1FastConfig_0:
   \   000013 72155258              BRES      L:0x5258, #0x2
   1330              }
   1331          }
   \   000017 87                    RETF
   1332          
   1333          
   1334          /**
   1335            * @brief  Configures the TIM1 Capture Compare 2 Fast feature.
   1336            * @param   NewState new state of the Output Compare Fast Enable bit.
   1337            * This parameter can be ENABLE or DISABLE.
   1338            * @retval None
   1339            */
   1340          

   \                                 In section .far_func.text, align 1, keep-with-next
   1341          void TIM1_OC2FastConfig(FunctionalState NewState)
   1342          {
   1343              /* Check the parameters */
   1344              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_OC2FastConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC2FastConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_101
   \   000007 AE0540                LDW       X, #0x540
   \   00000A 8D000000              CALLF     ?Subroutine9
   1345          
   1346              /* Set or Reset the OC2FE Bit */
   1347              if (NewState != DISABLE)
   1348              {
   1349                  TIM1->CCMR2 |= TIM1_CCMR_OCxFE;
   \                     ??CrossCallReturnLabel_101:
   \   00000E 72145259              BSET      L:0x5259, #0x2
   \   000012 87                    RETF
   1350              }
   1351              else
   1352              {
   1353                  TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC2FastConfig_0:
   \   000013 72155259              BRES      L:0x5259, #0x2
   1354              }
   1355          }
   \   000017 87                    RETF
   1356          
   1357          
   1358          /**
   1359            * @brief  Configures the TIM1 Capture Compare 3 Fast feature.
   1360            * @param   NewState new state of the Output Compare Fast Enable bit.
   1361            * This parameter can be ENABLE or DISABLE.
   1362            * @retval None
   1363            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1364          void TIM1_OC3FastConfig(FunctionalState NewState)
   1365          {
   1366              /* Check the parameters */
   1367              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_OC3FastConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC3FastConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_102
   \   000007 AE0557                LDW       X, #0x557
   \   00000A 8D000000              CALLF     ?Subroutine9
   1368          
   1369              /* Set or Reset the OC3FE Bit */
   1370              if (NewState != DISABLE)
   1371              {
   1372                  TIM1->CCMR3 |= TIM1_CCMR_OCxFE;
   \                     ??CrossCallReturnLabel_102:
   \   00000E 7214525A              BSET      L:0x525a, #0x2
   \   000012 87                    RETF
   1373              }
   1374              else
   1375              {
   1376                  TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC3FastConfig_0:
   \   000013 7215525A              BRES      L:0x525a, #0x2
   1377              }
   1378          }
   \   000017 87                    RETF
   1379          
   1380          
   1381          /**
   1382            * @brief  Configures the TIM1 Capture Compare 4 Fast feature.
   1383            * @param   NewState new state of the Output Compare Fast Enable bit.
   1384            * This parameter can be ENABLE or DISABLE.
   1385            * @retval None
   1386            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1387          void TIM1_OC4FastConfig(FunctionalState NewState)
   1388          {
   1389              /* Check the parameters */
   1390              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     TIM1_OC4FastConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC4FastConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_103
   \   000007 AE056E                LDW       X, #0x56e
   \   00000A 8D000000              CALLF     ?Subroutine9
   1391          
   1392              /* Set or Reset the OC4FE Bit */
   1393              if (NewState != DISABLE)
   1394              {
   1395                  TIM1->CCMR4 |= TIM1_CCMR_OCxFE;
   \                     ??CrossCallReturnLabel_103:
   \   00000E 7214525B              BSET      L:0x525b, #0x2
   \   000012 87                    RETF
   1396              }
   1397              else
   1398              {
   1399                  TIM1->CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC4FastConfig_0:
   \   000013 7215525B              BRES      L:0x525b, #0x2
   1400              }
   1401          }
   \   000017 87                    RETF
   1402          
   1403          
   1404          /**
   1405            * @brief  Configures the TIM1 event to be generated by software.
   1406            * @param   TIM1_EventSource specifies the event source.
   1407            * This parameter can be one of the following values:
   1408            *                       - TIM1_EVENTSOURCE_UPDATE: TIM1 update Event source
   1409            *                       - TIM1_EVENTSOURCE_CC1: TIM1 Capture Compare 1 Event source
   1410            *                       - TIM1_EVENTSOURCE_CC2: TIM1 Capture Compare 2 Event source
   1411            *                       - TIM1_EVENTSOURCE_CC3: TIM1 Capture Compare 3 Event source
   1412            *                       - TIM1_EVENTSOURCE_CC4: TIM1 Capture Compare 4 Event source
   1413            *                       - TIM1_EVENTSOURCE_COM: TIM1 COM Event source
   1414            *                       - TIM1_EVENTSOURCE_TRIGGER: TIM1 Trigger Event source
   1415            *                       - TIM1_EventSourceBreak: TIM1 Break Event source
   1416            * @retval None
   1417            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1418          void TIM1_GenerateEvent(TIM1_EventSource_TypeDef TIM1_EventSource)
   1419          {
   \                     TIM1_GenerateEvent:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1420              /* Check the parameters */
   1421              assert_param(IS_TIM1_EVENT_SOURCE_OK(TIM1_EventSource));
   \   000005 2607                  JRNE      L:??CrossCallReturnLabel_104
   \   000007 AE058D                LDW       X, #0x58d
   \   00000A 8D000000              CALLF     ?Subroutine9
   1422          
   1423              /* Set the event sources */
   1424              TIM1->EGR = (uint8_t)TIM1_EventSource;
   \                     ??CrossCallReturnLabel_104:
   \   00000E B600                  LD        A, S:?b8
   \   000010 C75257                LD        L:0x5257, A
   1425          }
   \   000013 320000                POP       S:?b8
   \   000016 87                    RETF
   1426          
   1427          
   1428          /**
   1429            * @brief  Configures the TIM1 Channel 1 polarity.
   1430            * @param   TIM1_OCPolarity specifies the OC1 Polarity.
   1431            * This parameter can be one of the following values:
   1432            *                       - TIM1_OCPOLARITY_LOW: Output Compare active low
   1433            *                       - TIM1_OCPOLARITY_HIGH: Output Compare active high
   1434            * @retval None
   1435            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1436          void TIM1_OC1PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1437          {
   1438              /* Check the parameters */
   1439              assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     TIM1_OC1PolarityConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC1PolarityConfig_0
   \   000003 A122                  CP        A, #0x22
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_105
   \   000007 AE059F                LDW       X, #0x59f
   \   00000A 8D000000              CALLF     ?Subroutine9
   1440          
   1441              /* Set or Reset the CC1P Bit */
   1442              if (TIM1_OCPolarity != TIM1_OCPOLARITY_HIGH)
   1443              {
   1444                  TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \                     ??CrossCallReturnLabel_105:
   \   00000E 7212525C              BSET      L:0x525c, #0x1
   \   000012 87                    RETF
   1445              }
   1446              else
   1447              {
   1448                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TIM1_OC1PolarityConfig_0:
   \   000013 7213525C              BRES      L:0x525c, #0x1
   1449              }
   1450          }
   \   000017 87                    RETF
   1451          
   1452          
   1453          /**
   1454            * @brief  Configures the TIM1 Channel 1N polarity.
   1455            * @param   TIM1_OCNPolarity specifies the OC1N Polarity.
   1456            * This parameter can be one of the following values:
   1457            *                       - TIM1_OCNPOLARITY_LOW: Output Compare active low
   1458            *                       - TIM1_OCNPOLARITY_HIGH: Output Compare active high
   1459            * @retval None
   1460            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1461          void TIM1_OC1NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1462          {
   1463              /* Check the parameters */
   1464              assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     TIM1_OC1NPolarityConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC1NPolarityConfig_0
   \   000003 A188                  CP        A, #0x88
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_106
   \   000007 AE05B8                LDW       X, #0x5b8
   \   00000A 8D000000              CALLF     ?Subroutine9
   1465          
   1466              /* Set or Reset the CC3P Bit */
   1467              if (TIM1_OCNPolarity != TIM1_OCNPOLARITY_HIGH)
   1468              {
   1469                  TIM1->CCER1 |= TIM1_CCER1_CC1NP;
   \                     ??CrossCallReturnLabel_106:
   \   00000E 7216525C              BSET      L:0x525c, #0x3
   \   000012 87                    RETF
   1470              }
   1471              else
   1472              {
   1473                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1NP);
   \                     ??TIM1_OC1NPolarityConfig_0:
   \   000013 7217525C              BRES      L:0x525c, #0x3
   1474              }
   1475          }
   \   000017 87                    RETF
   1476          
   1477          
   1478          /**
   1479            * @brief  Configures the TIM1 Channel 2 polarity.
   1480            * @param   TIM1_OCPolarity specifies the OC2 Polarity.
   1481            * This parameter can be one of the following values:
   1482            *                       - TIM1_OCPOLARITY_LOW: Output Compare active low
   1483            *                       - TIM1_OCPOLARITY_HIGH: Output Compare active high
   1484            * @retval None
   1485            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1486          void TIM1_OC2PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1487          {
   1488              /* Check the parameters */
   1489              assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     TIM1_OC2PolarityConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC2PolarityConfig_0
   \   000003 A122                  CP        A, #0x22
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_107
   \   000007 AE05D1                LDW       X, #0x5d1
   \   00000A 8D000000              CALLF     ?Subroutine9
   1490          
   1491              /* Set or Reset the CC2P Bit */
   1492              if (TIM1_OCPolarity != TIM1_OCPOLARITY_HIGH)
   1493              {
   1494                  TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \                     ??CrossCallReturnLabel_107:
   \   00000E 721A525C              BSET      L:0x525c, #0x5
   \   000012 87                    RETF
   1495              }
   1496              else
   1497              {
   1498                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TIM1_OC2PolarityConfig_0:
   \   000013 721B525C              BRES      L:0x525c, #0x5
   1499              }
   1500          }
   \   000017 87                    RETF
   1501          
   1502          /**
   1503            * @brief  Configures the TIM1 Channel 2N polarity.
   1504            * @param   TIM1_OCNPolarity specifies the OC2N Polarity.
   1505            * This parameter can be one of the following values:
   1506            *                       - TIM1_OCNPOLARITY_LOW: Output Compare active low
   1507            *                       - TIM1_OCNPOLARITY_HIGH: Output Compare active high
   1508            * @retval None
   1509            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1510          void TIM1_OC2NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1511          {
   1512              /* Check the parameters */
   1513              assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     TIM1_OC2NPolarityConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC2NPolarityConfig_0
   \   000003 A188                  CP        A, #0x88
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_108
   \   000007 AE05E9                LDW       X, #0x5e9
   \   00000A 8D000000              CALLF     ?Subroutine9
   1514          
   1515              /* Set or Reset the CC3P Bit */
   1516              if (TIM1_OCNPolarity != TIM1_OCNPOLARITY_HIGH)
   1517              {
   1518                  TIM1->CCER1 |= TIM1_CCER1_CC2NP;
   \                     ??CrossCallReturnLabel_108:
   \   00000E 721E525C              BSET      L:0x525c, #0x7
   \   000012 87                    RETF
   1519              }
   1520              else
   1521              {
   1522                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2NP);
   \                     ??TIM1_OC2NPolarityConfig_0:
   \   000013 721F525C              BRES      L:0x525c, #0x7
   1523              }
   1524          }
   \   000017 87                    RETF
   1525          
   1526          
   1527          /**
   1528            * @brief  Configures the TIM1 Channel 3 polarity.
   1529            * @param   TIM1_OCPolarity specifies the OC3 Polarity.
   1530            * This parameter can be one of the following values:
   1531            *                       - TIM1_OCPOLARITY_LOW: Output Compare active low
   1532            *                       - TIM1_OCPOLARITY_HIGH: Output Compare active high
   1533            * @retval None
   1534            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1535          void TIM1_OC3PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1536          {
   1537              /* Check the parameters */
   1538              assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     TIM1_OC3PolarityConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC3PolarityConfig_0
   \   000003 A122                  CP        A, #0x22
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_109
   \   000007 AE0602                LDW       X, #0x602
   \   00000A 8D000000              CALLF     ?Subroutine9
   1539          
   1540              /* Set or Reset the CC3P Bit */
   1541              if (TIM1_OCPolarity != TIM1_OCPOLARITY_HIGH)
   1542              {
   1543                  TIM1->CCER2 |= TIM1_CCER2_CC3P;
   \                     ??CrossCallReturnLabel_109:
   \   00000E 7212525D              BSET      L:0x525d, #0x1
   \   000012 87                    RETF
   1544              }
   1545              else
   1546              {
   1547                  TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3P);
   \                     ??TIM1_OC3PolarityConfig_0:
   \   000013 7213525D              BRES      L:0x525d, #0x1
   1548              }
   1549          }
   \   000017 87                    RETF
   1550          
   1551          
   1552          /**
   1553            * @brief  Configures the TIM1 Channel 3N polarity.
   1554            * @param   TIM1_OCNPolarity specifies the OC3N Polarity.
   1555            * This parameter can be one of the following values:
   1556            *                       - TIM1_OCNPOLARITY_LOW: Output Compare active low
   1557            *                       - TIM1_OCNPOLARITY_HIGH: Output Compare active high
   1558            * @retval None
   1559            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1560          void TIM1_OC3NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1561          {
   1562              /* Check the parameters */
   1563              assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     TIM1_OC3NPolarityConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC3NPolarityConfig_0
   \   000003 A188                  CP        A, #0x88
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_110
   \   000007 AE061B                LDW       X, #0x61b
   \   00000A 8D000000              CALLF     ?Subroutine9
   1564          
   1565              /* Set or Reset the CC3P Bit */
   1566              if (TIM1_OCNPolarity != TIM1_OCNPOLARITY_HIGH)
   1567              {
   1568                  TIM1->CCER2 |= TIM1_CCER2_CC3NP;
   \                     ??CrossCallReturnLabel_110:
   \   00000E 7216525D              BSET      L:0x525d, #0x3
   \   000012 87                    RETF
   1569              }
   1570              else
   1571              {
   1572                  TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3NP);
   \                     ??TIM1_OC3NPolarityConfig_0:
   \   000013 7217525D              BRES      L:0x525d, #0x3
   1573              }
   1574          }
   \   000017 87                    RETF
   1575          
   1576          /**
   1577            * @brief  Configures the TIM1 Channel 4 polarity.
   1578            * @param   TIM1_OCPolarity specifies the OC4 Polarity.
   1579            * This parameter can be one of the following values:
   1580            *                       - TIM1_OCPOLARITY_LOW: Output Compare active low
   1581            *                       - TIM1_OCPOLARITY_HIGH: Output Compare active high
   1582            * @retval None
   1583            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1584          void TIM1_OC4PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1585          {
   1586              /* Check the parameters */
   1587              assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     TIM1_OC4PolarityConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??TIM1_OC4PolarityConfig_0
   \   000003 A122                  CP        A, #0x22
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_111
   \   000007 AE0633                LDW       X, #0x633
   \   00000A 8D000000              CALLF     ?Subroutine9
   1588          
   1589              /* Set or Reset the CC4P Bit */
   1590              if (TIM1_OCPolarity != TIM1_OCPOLARITY_HIGH)
   1591              {
   1592                  TIM1->CCER2 |= TIM1_CCER2_CC4P;
   \                     ??CrossCallReturnLabel_111:
   \   00000E 721A525D              BSET      L:0x525d, #0x5
   \   000012 87                    RETF
   1593              }
   1594              else
   1595              {
   1596                  TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4P);
   \                     ??TIM1_OC4PolarityConfig_0:
   \   000013 721B525D              BRES      L:0x525d, #0x5
   1597              }
   1598          }
   \   000017 87                    RETF
   1599          
   1600          
   1601          /**
   1602            * @brief  Enables or disables the TIM1 Capture Compare Channel x (x=1,..,4).
   1603            * @param   TIM1_Channel specifies the TIM1 Channel.
   1604            * This parameter can be one of the following values:
   1605            *                       - TIM1_CHANNEL_1: TIM1 Channel1
   1606            *                       - TIM1_CHANNEL_2: TIM1 Channel2
   1607            *                       - TIM1_CHANNEL_3: TIM1 Channel3
   1608            *                       - TIM1_CHANNEL_4: TIM1 Channel4
   1609            * @param   NewState specifies the TIM1 Channel CCxE bit new state.
   1610            * This parameter can be: ENABLE or DISABLE.
   1611            * @retval None
   1612            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1613          void TIM1_CCxCmd(TIM1_Channel_TypeDef TIM1_Channel, FunctionalState NewState)
   1614          {
   \                     TIM1_CCxCmd:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
   1615              /* Check the parameters */
   1616              assert_param(IS_TIM1_CHANNEL_OK(TIM1_Channel));
   \   000009 2713                  JREQ      L:??CrossCallReturnLabel_113
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CrossCallReturnLabel_113
   \   00000F A102                  CP        A, #0x2
   \   000011 270B                  JREQ      L:??CrossCallReturnLabel_113
   \   000013 A103                  CP        A, #0x3
   \   000015 2707                  JREQ      L:??CrossCallReturnLabel_113
   \   000017 AE0650                LDW       X, #0x650
   \   00001A 8D000000              CALLF     ?Subroutine9
   1617              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_113:
   \   00001E 3D00                  TNZ       S:?b9
   \   000020 270D                  JREQ      L:??CrossCallReturnLabel_112
   \   000022 B600                  LD        A, S:?b9
   \   000024 A101                  CP        A, #0x1
   \   000026 2707                  JREQ      L:??CrossCallReturnLabel_112
   \   000028 AE0651                LDW       X, #0x651
   \   00002B 8D000000              CALLF     ?Subroutine9
   1618          
   1619              if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??CrossCallReturnLabel_112:
   \   00002F 3D00                  TNZ       S:?b8
   \   000031 2614                  JRNE      L:??TIM1_CCxCmd_0
   1620              {
   1621                  /* Set or Reset the CC1E Bit */
   1622                  if (NewState != DISABLE)
   \   000033 3D00                  TNZ       S:?b9
   \   000035 2708                  JREQ      L:??TIM1_CCxCmd_1
   1623                  {
   1624                      TIM1->CCER1 |= TIM1_CCER1_CC1E;
   \   000037 7210525C              BSET      L:0x525c, #0x0
   \   00003B AC000000              JPF       L:?epilogue_w4
   1625                  }
   1626                  else
   1627                  {
   1628                      TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \                     ??TIM1_CCxCmd_1:
   \   00003F 7211525C              BRES      L:0x525c, #0x0
   \   000043 AC000000              JPF       L:?epilogue_w4
   1629                  }
   1630          
   1631              }
   1632              else if (TIM1_Channel == TIM1_CHANNEL_2)
   \                     ??TIM1_CCxCmd_0:
   \   000047 B600                  LD        A, S:?b8
   \   000049 A101                  CP        A, #0x1
   \   00004B 2614                  JRNE      L:??TIM1_CCxCmd_2
   1633              {
   1634                  /* Set or Reset the CC2E Bit */
   1635                  if (NewState != DISABLE)
   \   00004D 3D00                  TNZ       S:?b9
   \   00004F 2708                  JREQ      L:??TIM1_CCxCmd_3
   1636                  {
   1637                      TIM1->CCER1 |= TIM1_CCER1_CC2E;
   \   000051 7218525C              BSET      L:0x525c, #0x4
   \   000055 AC000000              JPF       L:?epilogue_w4
   1638                  }
   1639                  else
   1640                  {
   1641                      TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2E);
   \                     ??TIM1_CCxCmd_3:
   \   000059 7219525C              BRES      L:0x525c, #0x4
   \   00005D AC000000              JPF       L:?epilogue_w4
   1642                  }
   1643              }
   1644              else if (TIM1_Channel == TIM1_CHANNEL_3)
   \                     ??TIM1_CCxCmd_2:
   \   000061 A102                  CP        A, #0x2
   \   000063 2614                  JRNE      L:??TIM1_CCxCmd_4
   1645              {
   1646                  /* Set or Reset the CC3E Bit */
   1647                  if (NewState != DISABLE)
   \   000065 3D00                  TNZ       S:?b9
   \   000067 2708                  JREQ      L:??TIM1_CCxCmd_5
   1648                  {
   1649                      TIM1->CCER2 |= TIM1_CCER2_CC3E;
   \   000069 7210525D              BSET      L:0x525d, #0x0
   \   00006D AC000000              JPF       L:?epilogue_w4
   1650                  }
   1651                  else
   1652                  {
   1653                      TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3E);
   \                     ??TIM1_CCxCmd_5:
   \   000071 7211525D              BRES      L:0x525d, #0x0
   \   000075 AC000000              JPF       L:?epilogue_w4
   1654                  }
   1655              }
   1656              else
   1657              {
   1658                  /* Set or Reset the CC4E Bit */
   1659                  if (NewState != DISABLE)
   \                     ??TIM1_CCxCmd_4:
   \   000079 3D00                  TNZ       S:?b9
   \   00007B 2708                  JREQ      L:??TIM1_CCxCmd_6
   1660                  {
   1661                      TIM1->CCER2 |= TIM1_CCER2_CC4E;
   \   00007D 7218525D              BSET      L:0x525d, #0x4
   \   000081 AC000000              JPF       L:?epilogue_w4
   1662                  }
   1663                  else
   1664                  {
   1665                      TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4E);
   \                     ??TIM1_CCxCmd_6:
   \   000085 7219525D              BRES      L:0x525d, #0x4
   1666                  }
   1667              }
   1668          }
   \   000089 AC000000              JPF       L:?epilogue_w4
   1669          
   1670          /**
   1671            * @brief  Enables or disables the TIM1 Capture Compare Channel xN (xN=1,..,3).
   1672            * @param   TIM1_Channel specifies the TIM1 Channel.
   1673            * This parameter can be one of the following values:
   1674            *                       - TIM1_CHANNEL_1: TIM1 Channel1
   1675            *                       - TIM1_CHANNEL_2: TIM1 Channel2
   1676            *                       - TIM1_CHANNEL_3: TIM1 Channel3
   1677            * @param   NewState specifies the TIM1 Channel CCxNE bit new state.
   1678            * This parameter can be: ENABLE or DISABLE.
   1679            * @retval None
   1680            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1681          void TIM1_CCxNCmd(TIM1_Channel_TypeDef TIM1_Channel, FunctionalState NewState)
   1682          {
   \                     TIM1_CCxNCmd:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
   1683              /* Check the parameters */
   1684              assert_param(IS_TIM1_COMPLEMENTARY_CHANNEL_OK(TIM1_Channel));
   \   000009 270F                  JREQ      L:??CrossCallReturnLabel_115
   \   00000B A101                  CP        A, #0x1
   \   00000D 270B                  JREQ      L:??CrossCallReturnLabel_115
   \   00000F A102                  CP        A, #0x2
   \   000011 2707                  JREQ      L:??CrossCallReturnLabel_115
   \   000013 AE0694                LDW       X, #0x694
   \   000016 8D000000              CALLF     ?Subroutine9
   1685              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_115:
   \   00001A 3D00                  TNZ       S:?b9
   \   00001C 270D                  JREQ      L:??CrossCallReturnLabel_114
   \   00001E B600                  LD        A, S:?b9
   \   000020 A101                  CP        A, #0x1
   \   000022 2707                  JREQ      L:??CrossCallReturnLabel_114
   \   000024 AE0695                LDW       X, #0x695
   \   000027 8D000000              CALLF     ?Subroutine9
   1686          
   1687              if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??CrossCallReturnLabel_114:
   \   00002B 3D00                  TNZ       S:?b8
   \   00002D 2614                  JRNE      L:??TIM1_CCxNCmd_0
   1688              {
   1689                  /* Set or Reset the CC1NE Bit */
   1690                  if (NewState != DISABLE)
   \   00002F 3D00                  TNZ       S:?b9
   \   000031 2708                  JREQ      L:??TIM1_CCxNCmd_1
   1691                  {
   1692                      TIM1->CCER1 |= TIM1_CCER1_CC1NE;
   \   000033 7214525C              BSET      L:0x525c, #0x2
   \   000037 AC000000              JPF       L:?epilogue_w4
   1693                  }
   1694                  else
   1695                  {
   1696                      TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1NE);
   \                     ??TIM1_CCxNCmd_1:
   \   00003B 7215525C              BRES      L:0x525c, #0x2
   \   00003F AC000000              JPF       L:?epilogue_w4
   1697                  }
   1698              }
   1699              else if (TIM1_Channel == TIM1_CHANNEL_2)
   \                     ??TIM1_CCxNCmd_0:
   \   000043 B600                  LD        A, S:?b8
   \   000045 A101                  CP        A, #0x1
   \   000047 2614                  JRNE      L:??TIM1_CCxNCmd_2
   1700              {
   1701                  /* Set or Reset the CC2NE Bit */
   1702                  if (NewState != DISABLE)
   \   000049 3D00                  TNZ       S:?b9
   \   00004B 2708                  JREQ      L:??TIM1_CCxNCmd_3
   1703                  {
   1704                      TIM1->CCER1 |= TIM1_CCER1_CC2NE;
   \   00004D 721C525C              BSET      L:0x525c, #0x6
   \   000051 AC000000              JPF       L:?epilogue_w4
   1705                  }
   1706                  else
   1707                  {
   1708                      TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2NE);
   \                     ??TIM1_CCxNCmd_3:
   \   000055 721D525C              BRES      L:0x525c, #0x6
   \   000059 AC000000              JPF       L:?epilogue_w4
   1709                  }
   1710              }
   1711              else
   1712              {
   1713                  /* Set or Reset the CC3NE Bit */
   1714                  if (NewState != DISABLE)
   \                     ??TIM1_CCxNCmd_2:
   \   00005D 3D00                  TNZ       S:?b9
   \   00005F 2708                  JREQ      L:??TIM1_CCxNCmd_4
   1715                  {
   1716                      TIM1->CCER2 |= TIM1_CCER2_CC3NE;
   \   000061 7214525D              BSET      L:0x525d, #0x2
   \   000065 AC000000              JPF       L:?epilogue_w4
   1717                  }
   1718                  else
   1719                  {
   1720                      TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3NE);
   \                     ??TIM1_CCxNCmd_4:
   \   000069 7215525D              BRES      L:0x525d, #0x2
   1721                  }
   1722              }
   1723          }
   \   00006D AC000000              JPF       L:?epilogue_w4
   1724          
   1725          
   1726          /**
   1727            * @brief  Selects the TIM1 Output Compare Mode. This function disables the
   1728            * selected channel before changing the Output Compare Mode. User has to
   1729            * enable this channel using TIM1_CCxCmd and TIM1_CCxNCmd functions.
   1730            * @param   TIM1_Channel specifies the TIM1 Channel.
   1731            * This parameter can be one of the following values:
   1732            *                       - TIM1_CHANNEL_1: TIM1 Channel1
   1733            *                       - TIM1_CHANNEL_2: TIM1 Channel2
   1734            *                       - TIM1_CHANNEL_3: TIM1 Channel3
   1735            *                       - TIM1_CHANNEL_4: TIM1 Channel4
   1736            * @param   TIM1_OCMode specifies the TIM1 Output Compare Mode.
   1737            * This paramter can be one of the following values:
   1738            *                       - TIM1_OCMODE_TIMING
   1739            *                       - TIM1_OCMODE_ACTIVE
   1740            *                       - TIM1_OCMODE_TOGGLE
   1741            *                       - TIM1_OCMODE_PWM1
   1742            *                       - TIM1_OCMODE_PWM2
   1743            *                       - TIM1_FORCEDACTION_ACTIVE
   1744            *                       - TIM1_FORCEDACTION_INACTIVE
   1745            * @retval None
   1746            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1747          void TIM1_SelectOCxM(TIM1_Channel_TypeDef TIM1_Channel, TIM1_OCMode_TypeDef TIM1_OCMode)
   1748          {
   \                     TIM1_SelectOCxM:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
   1749              /* Check the parameters */
   1750              assert_param(IS_TIM1_CHANNEL_OK(TIM1_Channel));
   \   000009 2713                  JREQ      L:??CrossCallReturnLabel_117
   \   00000B A101                  CP        A, #0x1
   \   00000D 270F                  JREQ      L:??CrossCallReturnLabel_117
   \   00000F A102                  CP        A, #0x2
   \   000011 270B                  JREQ      L:??CrossCallReturnLabel_117
   \   000013 A103                  CP        A, #0x3
   \   000015 2707                  JREQ      L:??CrossCallReturnLabel_117
   \   000017 AE06D6                LDW       X, #0x6d6
   \   00001A 8D000000              CALLF     ?Subroutine9
   1751              assert_param(IS_TIM1_OCM_OK(TIM1_OCMode));
   \                     ??CrossCallReturnLabel_117:
   \   00001E 3D00                  TNZ       S:?b9
   \   000020 2725                  JREQ      L:??CrossCallReturnLabel_116
   \   000022 B600                  LD        A, S:?b9
   \   000024 A110                  CP        A, #0x10
   \   000026 271F                  JREQ      L:??CrossCallReturnLabel_116
   \   000028 A120                  CP        A, #0x20
   \   00002A 271B                  JREQ      L:??CrossCallReturnLabel_116
   \   00002C A130                  CP        A, #0x30
   \   00002E 2717                  JREQ      L:??CrossCallReturnLabel_116
   \   000030 A160                  CP        A, #0x60
   \   000032 2713                  JREQ      L:??CrossCallReturnLabel_116
   \   000034 A170                  CP        A, #0x70
   \   000036 270F                  JREQ      L:??CrossCallReturnLabel_116
   \   000038 A150                  CP        A, #0x50
   \   00003A 270B                  JREQ      L:??CrossCallReturnLabel_116
   \   00003C A140                  CP        A, #0x40
   \   00003E 2707                  JREQ      L:??CrossCallReturnLabel_116
   \   000040 AE06D7                LDW       X, #0x6d7
   \   000043 8D000000              CALLF     ?Subroutine9
   1752          
   1753              if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??CrossCallReturnLabel_116:
   \   000047 3D00                  TNZ       S:?b8
   \   000049 2612                  JRNE      L:??TIM1_SelectOCxM_0
   1754              {
   1755                  /* Disable the Channel 1: Reset the CCE Bit */
   1756                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \   00004B 7211525C              BRES      L:0x525c, #0x0
   1757          
   1758                  /* Reset the Output Compare Bits & Set the Output Compare Mode */
   1759                  TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) 
   1760                                          | (uint8_t)TIM1_OCMode);
   \   00004F C65258                LD        A, L:0x5258
   \   000052 A48F                  AND       A, #0x8f
   \   000054 BA00                  OR        A, S:?b9
   \   000056 C75258                LD        L:0x5258, A
   \   000059 AC000000              JPF       L:?epilogue_w4
   1761              }
   1762              else if (TIM1_Channel == TIM1_CHANNEL_2)
   \                     ??TIM1_SelectOCxM_0:
   \   00005D B600                  LD        A, S:?b8
   \   00005F A101                  CP        A, #0x1
   \   000061 2612                  JRNE      L:??TIM1_SelectOCxM_1
   1763              {
   1764                  /* Disable the Channel 2: Reset the CCE Bit */
   1765                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2E);
   \   000063 7219525C              BRES      L:0x525c, #0x4
   1766          
   1767                  /* Reset the Output Compare Bits & Set the Output Compare Mode */
   1768                  TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM))
   1769                                          | (uint8_t)TIM1_OCMode);
   \   000067 C65259                LD        A, L:0x5259
   \   00006A A48F                  AND       A, #0x8f
   \   00006C BA00                  OR        A, S:?b9
   \   00006E C75259                LD        L:0x5259, A
   \   000071 AC000000              JPF       L:?epilogue_w4
   1770              }
   1771              else if (TIM1_Channel == TIM1_CHANNEL_3)
   \                     ??TIM1_SelectOCxM_1:
   \   000075 A102                  CP        A, #0x2
   \   000077 2612                  JRNE      L:??TIM1_SelectOCxM_2
   1772              {
   1773                  /* Disable the Channel 3: Reset the CCE Bit */
   1774                  TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3E);
   \   000079 7211525D              BRES      L:0x525d, #0x0
   1775          
   1776                  /* Reset the Output Compare Bits & Set the Output Compare Mode */
   1777                  TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) 
   1778                                          | (uint8_t)TIM1_OCMode);
   \   00007D C6525A                LD        A, L:0x525a
   \   000080 A48F                  AND       A, #0x8f
   \   000082 BA00                  OR        A, S:?b9
   \   000084 C7525A                LD        L:0x525a, A
   \   000087 AC000000              JPF       L:?epilogue_w4
   1779              }
   1780              else
   1781              {
   1782                  /* Disable the Channel 4: Reset the CCE Bit */
   1783                  TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4E);
   \                     ??TIM1_SelectOCxM_2:
   \   00008B 7219525D              BRES      L:0x525d, #0x4
   1784          
   1785                  /* Reset the Output Compare Bits & Set the Output Compare Mode */
   1786                  TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_OCM)) 
   1787                                          | (uint8_t)TIM1_OCMode);
   \   00008F C6525B                LD        A, L:0x525b
   \   000092 A48F                  AND       A, #0x8f
   \   000094 BA00                  OR        A, S:?b9
   \   000096 C7525B                LD        L:0x525b, A
   1788              }
   1789          }
   \   000099 AC000000              JPF       L:?epilogue_w4
   1790          
   1791          
   1792          /**
   1793            * @brief  Sets the TIM1 Counter Register value.
   1794            * @param   Counter specifies the Counter register new value.
   1795            * This parameter is between 0x0000 and 0xFFFF.
   1796            * @retval None
   1797            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1798          void TIM1_SetCounter(uint16_t Counter)
   1799          {
   \                     TIM1_SetCounter:
   \   000000 9093                  LDW       Y, X
   1800              /* Set the Counter Register value */
   1801              TIM1->CNTRH = (uint8_t)(Counter >> 8);
   \   000002 4F                    CLR       A
   \   000003 01                    RRWA      X, A
   \   000004 9F                    LD        A, XL
   \   000005 C7525E                LD        L:0x525e, A
   1802              TIM1->CNTRL = (uint8_t)(Counter);
   \   000008 909F                  LD        A, YL
   \   00000A C7525F                LD        L:0x525f, A
   1803          
   1804          }
   \   00000D 87                    RETF
   1805          
   1806          
   1807          /**
   1808            * @brief  Sets the TIM1 Autoreload Register value.
   1809            * @param   Autoreload specifies the Autoreload register new value.
   1810            * This parameter is between 0x0000 and 0xFFFF.
   1811            * @retval None
   1812            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1813          void TIM1_SetAutoreload(uint16_t Autoreload)
   1814          {
   \                     TIM1_SetAutoreload:
   \   000000 9093                  LDW       Y, X
   1815          
   1816              /* Set the Autoreload Register value */
   1817              TIM1->ARRH = (uint8_t)(Autoreload >> 8);
   \   000002 4F                    CLR       A
   \   000003 01                    RRWA      X, A
   \   000004 9F                    LD        A, XL
   \   000005 C75262                LD        L:0x5262, A
   1818              TIM1->ARRL = (uint8_t)(Autoreload);
   \   000008 909F                  LD        A, YL
   \   00000A C75263                LD        L:0x5263, A
   1819          
   1820          }
   \   00000D 87                    RETF
   1821          
   1822          
   1823          /**
   1824            * @brief  Sets the TIM1 Capture Compare1 Register value.
   1825            * @param   Compare1 specifies the Capture Compare1 register new value.
   1826            * This parameter is between 0x0000 and 0xFFFF.
   1827            * @retval None
   1828            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1829          void TIM1_SetCompare1(uint16_t Compare1)
   1830          {
   \                     TIM1_SetCompare1:
   \   000000 9093                  LDW       Y, X
   1831              /* Set the Capture Compare1 Register value */
   1832              TIM1->CCR1H = (uint8_t)(Compare1 >> 8);
   \   000002 4F                    CLR       A
   \   000003 01                    RRWA      X, A
   \   000004 9F                    LD        A, XL
   \   000005 C75265                LD        L:0x5265, A
   1833              TIM1->CCR1L = (uint8_t)(Compare1);
   \   000008 909F                  LD        A, YL
   \   00000A C75266                LD        L:0x5266, A
   1834          
   1835          }
   \   00000D 87                    RETF
   1836          
   1837          
   1838          /**
   1839            * @brief  Sets the TIM1 Capture Compare2 Register value.
   1840            * @param   Compare2 specifies the Capture Compare2 register new value.
   1841            * This parameter is between 0x0000 and 0xFFFF.
   1842            * @retval None
   1843            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1844          void TIM1_SetCompare2(uint16_t Compare2)
   1845          {
   \                     TIM1_SetCompare2:
   \   000000 9093                  LDW       Y, X
   1846              /* Set the Capture Compare2 Register value */
   1847              TIM1->CCR2H = (uint8_t)(Compare2 >> 8);
   \   000002 4F                    CLR       A
   \   000003 01                    RRWA      X, A
   \   000004 9F                    LD        A, XL
   \   000005 C75267                LD        L:0x5267, A
   1848              TIM1->CCR2L = (uint8_t)(Compare2);
   \   000008 909F                  LD        A, YL
   \   00000A C75268                LD        L:0x5268, A
   1849          
   1850          }
   \   00000D 87                    RETF
   1851          
   1852          
   1853          /**
   1854            * @brief  Sets the TIM1 Capture Compare3 Register value.
   1855            * @param   Compare3 specifies the Capture Compare3 register new value.
   1856            * This parameter is between 0x0000 and 0xFFFF.
   1857            * @retval None
   1858            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1859          void TIM1_SetCompare3(uint16_t Compare3)
   1860          {
   \                     TIM1_SetCompare3:
   \   000000 9093                  LDW       Y, X
   1861              /* Set the Capture Compare3 Register value */
   1862              TIM1->CCR3H = (uint8_t)(Compare3 >> 8);
   \   000002 4F                    CLR       A
   \   000003 01                    RRWA      X, A
   \   000004 9F                    LD        A, XL
   \   000005 C75269                LD        L:0x5269, A
   1863              TIM1->CCR3L = (uint8_t)(Compare3);
   \   000008 909F                  LD        A, YL
   \   00000A C7526A                LD        L:0x526a, A
   1864          
   1865          }
   \   00000D 87                    RETF
   1866          
   1867          
   1868          /**
   1869            * @brief  Sets the TIM1 Capture Compare4 Register value.
   1870            * @param   Compare4 specifies the Capture Compare4 register new value.
   1871            * This parameter is between 0x0000 and 0xFFFF.
   1872            * @retval None
   1873            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1874          void TIM1_SetCompare4(uint16_t Compare4)
   1875          {
   \                     TIM1_SetCompare4:
   \   000000 9093                  LDW       Y, X
   1876              /* Set the Capture Compare4 Register value */
   1877              TIM1->CCR4H = (uint8_t)(Compare4 >> 8);
   \   000002 4F                    CLR       A
   \   000003 01                    RRWA      X, A
   \   000004 9F                    LD        A, XL
   \   000005 C7526B                LD        L:0x526b, A
   1878              TIM1->CCR4L = (uint8_t)(Compare4);
   \   000008 909F                  LD        A, YL
   \   00000A C7526C                LD        L:0x526c, A
   1879          }
   \   00000D 87                    RETF
   1880          
   1881          
   1882          /**
   1883            * @brief  Sets the TIM1 Input Capture 1 prescaler.
   1884            * @param   TIM1_IC1Prescaler specifies the Input Capture prescaler new value
   1885            * This parameter can be one of the following values:
   1886            *                       - TIM1_ICPSC_DIV1: no prescaler
   1887            *                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
   1888            *                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
   1889            *                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
   1890            * @retval None
   1891            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1892          void TIM1_SetIC1Prescaler(TIM1_ICPSC_TypeDef TIM1_IC1Prescaler)
   1893          {
   \                     TIM1_SetIC1Prescaler:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1894              /* Check the parameters */
   1895              assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_IC1Prescaler));
   \   000005 2713                  JREQ      L:??CrossCallReturnLabel_118
   \   000007 A104                  CP        A, #0x4
   \   000009 270F                  JREQ      L:??CrossCallReturnLabel_118
   \   00000B A108                  CP        A, #0x8
   \   00000D 270B                  JREQ      L:??CrossCallReturnLabel_118
   \   00000F A10C                  CP        A, #0xc
   \   000011 2707                  JREQ      L:??CrossCallReturnLabel_118
   \   000013 AE0767                LDW       X, #0x767
   \   000016 8D000000              CALLF     ?Subroutine9
   1896          
   1897              /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
   1898              TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_ICxPSC)) 
   1899                                      | (uint8_t)TIM1_IC1Prescaler);
   \                     ??CrossCallReturnLabel_118:
   \   00001A C65258                LD        A, L:0x5258
   \   00001D A4F3                  AND       A, #0xf3
   \   00001F BA00                  OR        A, S:?b8
   \   000021 C75258                LD        L:0x5258, A
   1900          
   1901          }
   \   000024 320000                POP       S:?b8
   \   000027 87                    RETF
   1902          
   1903          /**
   1904            * @brief  Sets the TIM1 Input Capture 2 prescaler.
   1905            * @param   TIM1_IC2Prescaler specifies the Input Capture prescaler new value
   1906            * This parameter can be one of the following values:
   1907            *                       - TIM1_ICPSC_DIV1: no prescaler
   1908            *                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
   1909            *                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
   1910            *                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
   1911            * @retval None
   1912            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1913          void TIM1_SetIC2Prescaler(TIM1_ICPSC_TypeDef TIM1_IC2Prescaler)
   1914          {
   \                     TIM1_SetIC2Prescaler:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1915          
   1916              /* Check the parameters */
   1917              assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_IC2Prescaler));
   \   000005 2713                  JREQ      L:??CrossCallReturnLabel_119
   \   000007 A104                  CP        A, #0x4
   \   000009 270F                  JREQ      L:??CrossCallReturnLabel_119
   \   00000B A108                  CP        A, #0x8
   \   00000D 270B                  JREQ      L:??CrossCallReturnLabel_119
   \   00000F A10C                  CP        A, #0xc
   \   000011 2707                  JREQ      L:??CrossCallReturnLabel_119
   \   000013 AE077D                LDW       X, #0x77d
   \   000016 8D000000              CALLF     ?Subroutine9
   1918          
   1919              /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
   1920              TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_ICxPSC))
   1921                                      | (uint8_t)TIM1_IC2Prescaler);
   \                     ??CrossCallReturnLabel_119:
   \   00001A C65259                LD        A, L:0x5259
   \   00001D A4F3                  AND       A, #0xf3
   \   00001F BA00                  OR        A, S:?b8
   \   000021 C75259                LD        L:0x5259, A
   1922          }
   \   000024 320000                POP       S:?b8
   \   000027 87                    RETF
   1923          
   1924          
   1925          /**
   1926            * @brief  Sets the TIM1 Input Capture 3 prescaler.
   1927            * @param   TIM1_IC3Prescaler specifies the Input Capture prescaler new value
   1928            * This parameter can be one of the following values:
   1929            *                       - TIM1_ICPSC_DIV1: no prescaler
   1930            *                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
   1931            *                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
   1932            *                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
   1933            * @retval None
   1934            */

   \                                 In section .far_func.text, align 1
   1935          void TIM1_SetIC3Prescaler(TIM1_ICPSC_TypeDef TIM1_IC3Prescaler)
   1936          {
   \                     TIM1_SetIC3Prescaler:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1937          
   1938              /* Check the parameters */
   1939              assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_IC3Prescaler));
   \   000005 2713                  JREQ      L:??CrossCallReturnLabel_120
   \   000007 A104                  CP        A, #0x4
   \   000009 270F                  JREQ      L:??CrossCallReturnLabel_120
   \   00000B A108                  CP        A, #0x8
   \   00000D 270B                  JREQ      L:??CrossCallReturnLabel_120
   \   00000F A10C                  CP        A, #0xc
   \   000011 2707                  JREQ      L:??CrossCallReturnLabel_120
   \   000013 AE0793                LDW       X, #0x793
   \   000016 8D000000              CALLF     ?Subroutine9
   1940          
   1941              /* Reset the IC1PSC Bits & Set the IC1PSC value */
   1942              TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | 
   1943                                      (uint8_t)TIM1_IC3Prescaler);
   \                     ??CrossCallReturnLabel_120:
   \   00001A C6525A                LD        A, L:0x525a
   \   00001D A4F3                  AND       A, #0xf3
   \   00001F BA00                  OR        A, S:?b8
   \   000021 C7525A                LD        L:0x525a, A
   1944          }
   \   000024 320000                POP       S:?b8
   \   000027 87                    RETF
   1945          
   1946          /**
   1947            * @brief  Sets the TIM1 Input Capture 4 prescaler.
   1948            * @param  TIM1_IC4Prescaler specifies the Input Capture prescaler new value
   1949            *         This parameter can be one of the following values:
   1950            *                       - TIM1_ICPSC_DIV1: no prescaler
   1951            *                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
   1952            *                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
   1953            *                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
   1954            * @retval None
   1955            */

   \                                 In section .far_func.text, align 1
   1956          void TIM1_SetIC4Prescaler(TIM1_ICPSC_TypeDef TIM1_IC4Prescaler)
   1957          {
   \                     TIM1_SetIC4Prescaler:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1958          
   1959              /* Check the parameters */
   1960              assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_IC4Prescaler));
   \   000005 2713                  JREQ      L:??CrossCallReturnLabel_121
   \   000007 A104                  CP        A, #0x4
   \   000009 270F                  JREQ      L:??CrossCallReturnLabel_121
   \   00000B A108                  CP        A, #0x8
   \   00000D 270B                  JREQ      L:??CrossCallReturnLabel_121
   \   00000F A10C                  CP        A, #0xc
   \   000011 2707                  JREQ      L:??CrossCallReturnLabel_121
   \   000013 AE07A8                LDW       X, #0x7a8
   \   000016 8D000000              CALLF     ?Subroutine9
   1961          
   1962              /* Reset the IC1PSC Bits &  Set the IC1PSC value */
   1963              TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_ICxPSC)) |
   1964                                      (uint8_t)TIM1_IC4Prescaler);
   \                     ??CrossCallReturnLabel_121:
   \   00001A C6525B                LD        A, L:0x525b
   \   00001D A4F3                  AND       A, #0xf3
   \   00001F BA00                  OR        A, S:?b8
   \   000021 C7525B                LD        L:0x525b, A
   1965          }
   \   000024 320000                POP       S:?b8
   \   000027 87                    RETF
   1966          
   1967          /**
   1968            * @brief  Gets the TIM1 Input Capture 1 value.
   1969            * @param  None
   1970            * @retval Capture Compare 1 Register value.
   1971            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine0:
   \   000000 B700                  LD        S:?b0, A
   \   000002 5F                    CLRW      X
   \   000003 41                    EXG       A, XL
   \   000004 B600                  LD        A, S:?b1
   \   000006 41                    EXG       A, XL
   \   000007 4F                    CLR       A
   \   000008 02                    RLWA      X, A
   \   000009 905F                  CLRW      Y
   \   00000B B600                  LD        A, S:?b0
   \   00000D 61                    EXG       A, YL
   \   00000E BF00                  LDW       S:?w0, X
   \   000010 93                    LDW       X, Y
   \   000011 02                    RLWA      X, A
   \   000012 BA00                  OR        A, S:?b0
   \   000014 01                    RRWA      X, A
   \   000015 87                    RETF

   \                                 In section .far_func.text, align 1
   1972          uint16_t TIM1_GetCapture1(void)
   1973          {
   1974              /* Get the Capture 1 Register value */
   1975          
   1976              uint16_t tmpccr1 = 0;
   1977              uint8_t tmpccr1l=0, tmpccr1h=0;
   1978          
   1979              tmpccr1h = TIM1->CCR1H;
   \                     TIM1_GetCapture1:
   \   000000 C65265                LD        A, L:0x5265
   \   000003 B700                  LD        S:?b1, A
   1980              tmpccr1l = TIM1->CCR1L;
   \   000005 C65266                LD        A, L:0x5266
   \   000008 8D000000              CALLF     ?Subroutine0
   1981          
   1982              tmpccr1 = (uint16_t)(tmpccr1l);
   1983              tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   1984              /* Get the Capture 1 Register value */
   1985              return (uint16_t)tmpccr1;
   \                     ??CrossCallReturnLabel_3:
   \   00000C 87                    RETF
   1986          }
   1987          
   1988          /**
   1989            * @brief  Gets the TIM1 Input Capture 2 value.
   1990            * @param  None
   1991            * @retval Capture Compare 2 Register value.
   1992            */

   \                                 In section .far_func.text, align 1
   1993          uint16_t TIM1_GetCapture2(void)
   1994          {
   1995              /* Get the Capture 2 Register value */
   1996          
   1997              uint16_t tmpccr2 = 0;
   1998              uint8_t tmpccr2l=0, tmpccr2h=0;
   1999          
   2000              tmpccr2h = TIM1->CCR2H;
   \                     TIM1_GetCapture2:
   \   000000 C65267                LD        A, L:0x5267
   \   000003 B700                  LD        S:?b1, A
   2001              tmpccr2l = TIM1->CCR2L;
   \   000005 C65268                LD        A, L:0x5268
   \   000008 8D000000              CALLF     ?Subroutine0
   2002          
   2003              tmpccr2 = (uint16_t)(tmpccr2l);
   2004              tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   2005              /* Get the Capture 2 Register value */
   2006              return (uint16_t)tmpccr2;
   \                     ??CrossCallReturnLabel_2:
   \   00000C 87                    RETF
   2007          }
   2008          
   2009          /**
   2010            * @brief  Gets the TIM1 Input Capture 3 value.
   2011            * @param  None
   2012            * @retval Capture Compare 3 Register value.
   2013            */

   \                                 In section .far_func.text, align 1
   2014          uint16_t TIM1_GetCapture3(void)
   2015          {
   2016              /* Get the Capture 3 Register value */
   2017              uint16_t tmpccr3 = 0;
   2018              uint8_t tmpccr3l=0, tmpccr3h=0;
   2019          
   2020              tmpccr3h = TIM1->CCR3H;
   \                     TIM1_GetCapture3:
   \   000000 C65269                LD        A, L:0x5269
   \   000003 B700                  LD        S:?b1, A
   2021              tmpccr3l = TIM1->CCR3L;
   \   000005 C6526A                LD        A, L:0x526a
   \   000008 8D000000              CALLF     ?Subroutine0
   2022          
   2023              tmpccr3 = (uint16_t)(tmpccr3l);
   2024              tmpccr3 |= (uint16_t)((uint16_t)tmpccr3h << 8);
   2025              /* Get the Capture 3 Register value */
   2026              return (uint16_t)tmpccr3;
   \                     ??CrossCallReturnLabel_1:
   \   00000C 87                    RETF
   2027          }
   2028          
   2029          /**
   2030            * @brief  Gets the TIM1 Input Capture 4 value.
   2031            * @param  None
   2032            * @retval Capture Compare 4 Register value.
   2033            */

   \                                 In section .far_func.text, align 1
   2034          uint16_t TIM1_GetCapture4(void)
   2035          {
   2036              /* Get the Capture 4 Register value */
   2037              uint16_t tmpccr4 = 0;
   2038              uint8_t tmpccr4l=0, tmpccr4h=0;
   2039          
   2040              tmpccr4h = TIM1->CCR4H;
   \                     TIM1_GetCapture4:
   \   000000 C6526B                LD        A, L:0x526b
   \   000003 B700                  LD        S:?b1, A
   2041              tmpccr4l = TIM1->CCR4L;
   \   000005 C6526C                LD        A, L:0x526c
   \   000008 8D000000              CALLF     ?Subroutine0
   2042          
   2043              tmpccr4 = (uint16_t)(tmpccr4l);
   2044              tmpccr4 |= (uint16_t)((uint16_t)tmpccr4h << 8);
   2045              /* Get the Capture 4 Register value */
   2046              return (uint16_t)tmpccr4;
   \                     ??CrossCallReturnLabel_0:
   \   00000C 87                    RETF
   2047          }
   2048          
   2049          /**
   2050            * @brief  Gets the TIM1 Counter value.
   2051            * @param  None
   2052            * @retval Counter Register value.
   2053            */

   \                                 In section .far_func.text, align 1
   2054          uint16_t TIM1_GetCounter(void)
   2055          {
   2056            uint16_t tmpcntr = 0;
   2057            
   2058            tmpcntr = ((uint16_t)TIM1->CNTRH << 8);
   \                     TIM1_GetCounter:
   \   000000 C6525E                LD        A, L:0x525e
   2059             
   2060            /* Get the Counter Register value */
   2061              return (uint16_t)(tmpcntr | (uint16_t)(TIM1->CNTRL));
   \   000003 5F                    CLRW      X
   \   000004 97                    LD        XL, A
   \   000005 4F                    CLR       A
   \   000006 02                    RLWA      X, A
   \   000007 C6525F                LD        A, L:0x525f
   \   00000A 8D000000              CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_136:
   \   00000E 87                    RETF
   2062          }

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine14:
   \   000000 905F                  CLRW      Y
   \   000002 9097                  LD        YL, A
   \   000004 90BF00                LDW       S:?w0, Y
   \   000007 01                    RRWA      X, A
   \   000008 BA00                  OR        A, S:?b1
   \   00000A 02                    RLWA      X, A
   \   00000B 87                    RETF
   2063          
   2064          /**
   2065            * @brief  Gets the TIM1 Prescaler value.
   2066            * @param  None
   2067            * @retval Prescaler Register value.
   2068            */

   \                                 In section .far_func.text, align 1
   2069          uint16_t TIM1_GetPrescaler(void)
   2070          {
   2071             uint16_t temp = 0;
   2072             
   2073             temp = ((uint16_t)TIM1->PSCRH << 8);
   \                     TIM1_GetPrescaler:
   \   000000 C65260                LD        A, L:0x5260
   2074             
   2075            /* Get the Prescaler Register value */
   2076              return (uint16_t)( temp | (uint16_t)(TIM1->PSCRL));
   \   000003 5F                    CLRW      X
   \   000004 97                    LD        XL, A
   \   000005 4F                    CLR       A
   \   000006 02                    RLWA      X, A
   \   000007 C65261                LD        A, L:0x5261
   \   00000A 8D000000              CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_135:
   \   00000E 87                    RETF
   2077          }
   2078          
   2079          /**
   2080            * @brief  Checks whether the specified TIM1 flag is set or not.
   2081            * @param  TIM1_FLAG specifies the flag to check.
   2082            *         This parameter can be one of the following values:
   2083            *                   - TIM1_FLAG_UPDATE: TIM1 update Flag
   2084            *                   - TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
   2085            *                   - TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
   2086            *                   - TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
   2087            *                   - TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
   2088            *                   - TIM1_FLAG_COM: TIM1 Commutation Flag
   2089            *                   - TIM1_FLAG_TRIGGER: TIM1 Trigger Flag
   2090            *                   - TIM1_FLAG_BREAK: TIM1 Break Flag
   2091            *                   - TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
   2092            *                   - TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
   2093            *                   - TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
   2094            *                   - TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
   2095            * @retval FlagStatus The new state of TIM1_FLAG (SET or RESET).
   2096            */

   \                                 In section .far_func.text, align 1
   2097          FlagStatus TIM1_GetFlagStatus(TIM1_FLAG_TypeDef TIM1_FLAG)
   2098          {
   \                     TIM1_GetFlagStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
   2099              FlagStatus bitstatus = RESET;
   2100              uint8_t tim1_flag_l = 0, tim1_flag_h = 0;
   2101          
   2102              /* Check the parameters */
   2103              assert_param(IS_TIM1_GET_FLAG_OK(TIM1_FLAG));
   \   000006 A30001                CPW       X, #0x1
   \   000009 273E                  JREQ      L:??CrossCallReturnLabel_122
   \   00000B A30002                CPW       X, #0x2
   \   00000E 2739                  JREQ      L:??CrossCallReturnLabel_122
   \   000010 A30004                CPW       X, #0x4
   \   000013 2734                  JREQ      L:??CrossCallReturnLabel_122
   \   000015 A30008                CPW       X, #0x8
   \   000018 272F                  JREQ      L:??CrossCallReturnLabel_122
   \   00001A A30010                CPW       X, #0x10
   \   00001D 272A                  JREQ      L:??CrossCallReturnLabel_122
   \   00001F A30020                CPW       X, #0x20
   \   000022 2725                  JREQ      L:??CrossCallReturnLabel_122
   \   000024 A30040                CPW       X, #0x40
   \   000027 2720                  JREQ      L:??CrossCallReturnLabel_122
   \   000029 A30080                CPW       X, #0x80
   \   00002C 271B                  JREQ      L:??CrossCallReturnLabel_122
   \   00002E A30200                CPW       X, #0x200
   \   000031 2716                  JREQ      L:??CrossCallReturnLabel_122
   \   000033 A30400                CPW       X, #0x400
   \   000036 2711                  JREQ      L:??CrossCallReturnLabel_122
   \   000038 A30800                CPW       X, #0x800
   \   00003B 270C                  JREQ      L:??CrossCallReturnLabel_122
   \   00003D A31000                CPW       X, #0x1000
   \   000040 2707                  JREQ      L:??CrossCallReturnLabel_122
   \   000042 AE0837                LDW       X, #0x837
   \   000045 8D000000              CALLF     ?Subroutine9
   2104          
   2105              tim1_flag_l = (uint8_t)(TIM1->SR1 & (uint8_t)TIM1_FLAG);
   \                     ??CrossCallReturnLabel_122:
   \   000049 C65255                LD        A, L:0x5255
   \   00004C B700                  LD        S:?b1, A
   2106              tim1_flag_h = (uint8_t)((uint16_t)TIM1_FLAG >> 8);
   2107          
   2108              if ((tim1_flag_l | (uint8_t)(TIM1->SR2 & tim1_flag_h)) != 0)
   \   00004E BE00                  LDW       X, S:?w4
   \   000050 4F                    CLR       A
   \   000051 01                    RRWA      X, A
   \   000052 9F                    LD        A, XL
   \   000053 C45256                AND       A, L:0x5256
   \   000056 88                    PUSH      A
   \   000057 B600                  LD        A, S:?b9
   \   000059 B400                  AND       A, S:?b1
   \   00005B B700                  LD        S:?b1, A
   \   00005D 84                    POP       A
   \   00005E BA00                  OR        A, S:?b1
   \   000060 2706                  JREQ      L:??TIM1_GetFlagStatus_0
   2109              {
   2110                  bitstatus = SET;
   \   000062 A601                  LD        A, #0x1
   \   000064 AC000000              JPF       L:?epilogue_w4
   2111              }
   2112              else
   2113              {
   2114                  bitstatus = RESET;
   \                     ??TIM1_GetFlagStatus_0:
   \   000068 4F                    CLR       A
   2115              }
   2116              return (FlagStatus)(bitstatus);
   \   000069 AC000000              JPF       L:?epilogue_w4
   2117          }
   2118          
   2119          /**
   2120            * @brief  Clears the TIM1s pending flags.
   2121            * @param  TIM1_FLAG specifies the flag to clear.
   2122            *         This parameter can be one of the following values:
   2123            *                       - TIM1_FLAG_UPDATE: TIM1 update Flag
   2124            *                       - TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
   2125            *                       - TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
   2126            *                       - TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
   2127            *                       - TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
   2128            *                       - TIM1_FLAG_COM: TIM1 Commutation Flag
   2129            *                       - TIM1_FLAG_TRIGGER: TIM1 Trigger Flag
   2130            *                       - TIM1_FLAG_BREAK: TIM1 Break Flag
   2131            *                       - TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
   2132            *                       - TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
   2133            *                       - TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
   2134            *                       - TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
   2135            * @retval None.
   2136            */

   \                                 In section .far_func.text, align 1
   2137          void TIM1_ClearFlag(TIM1_FLAG_TypeDef TIM1_FLAG)
   2138          {
   \                     TIM1_ClearFlag:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
   2139              /* Check the parameters */
   2140              assert_param(IS_TIM1_CLEAR_FLAG_OK(TIM1_FLAG));
   \   000006 02                    RLWA      X, A
   \   000007 A4E1                  AND       A, #0xe1
   \   000009 02                    RLWA      X, A
   \   00000A 4F                    CLR       A
   \   00000B 02                    RLWA      X, A
   \   00000C 5D                    TNZW      X
   \   00000D 2604                  JRNE      L:??TIM1_ClearFlag_0
   \   00000F BE00                  LDW       X, S:?w4
   \   000011 2607                  JRNE      L:??CrossCallReturnLabel_123
   \                     ??TIM1_ClearFlag_0:
   \   000013 AE085C                LDW       X, #0x85c
   \   000016 8D000000              CALLF     ?Subroutine9
   2141          
   2142              /* Clear the flags (rc_w0) clear this bit by writing 0. Writing 1 has no effect*/
   2143              TIM1->SR1 = (uint8_t)(~(uint8_t)(TIM1_FLAG));
   \                     ??CrossCallReturnLabel_123:
   \   00001A B600                  LD        A, S:?b9
   \   00001C 43                    CPL       A
   \   00001D C75255                LD        L:0x5255, A
   2144              TIM1->SR2 = (uint8_t)((uint8_t)(~((uint8_t)((uint16_t)TIM1_FLAG >> 8))) & 
   2145                                    (uint8_t)0x1E);
   \   000020 BE00                  LDW       X, S:?w4
   \   000022 4F                    CLR       A
   \   000023 01                    RRWA      X, A
   \   000024 9F                    LD        A, XL
   \   000025 43                    CPL       A
   \   000026 A41E                  AND       A, #0x1e
   \   000028 C75256                LD        L:0x5256, A
   2146          }
   \   00002B AC000000              JPF       L:?epilogue_w4
   2147          
   2148          /**
   2149            * @brief  Checks whether the TIM1 interrupt has occurred or not.
   2150            * @param  TIM1_IT specifies the TIM1 interrupt source to check.
   2151            *         This parameter can be one of the following values:
   2152            *                       - TIM1_IT_UPDATE: TIM1 update Interrupt source
   2153            *                       - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
   2154            *                       - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
   2155            *                       - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
   2156            *                       - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
   2157            *                       - TIM1_IT_COM: TIM1 Commutation Interrupt source
   2158            *                       - TIM1_IT_TRIGGER: TIM1 Trigger Interrupt source
   2159            *                       - TIM1_IT_BREAK: TIM1 Break Interrupt source
   2160            * @retval ITStatus The new state of the TIM1_IT(SET or RESET).
   2161            */

   \                                 In section .far_func.text, align 1
   2162          ITStatus TIM1_GetITStatus(TIM1_IT_TypeDef TIM1_IT)
   2163          {
   \                     TIM1_GetITStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   2164              ITStatus bitstatus = RESET;
   2165              uint8_t TIM1_itStatus = 0, TIM1_itEnable = 0;
   2166          
   2167              /* Check the parameters */
   2168              assert_param(IS_TIM1_GET_IT_OK(TIM1_IT));
   \   000005 A101                  CP        A, #0x1
   \   000007 2723                  JREQ      L:??CrossCallReturnLabel_124
   \   000009 A102                  CP        A, #0x2
   \   00000B 271F                  JREQ      L:??CrossCallReturnLabel_124
   \   00000D A104                  CP        A, #0x4
   \   00000F 271B                  JREQ      L:??CrossCallReturnLabel_124
   \   000011 A108                  CP        A, #0x8
   \   000013 2717                  JREQ      L:??CrossCallReturnLabel_124
   \   000015 A110                  CP        A, #0x10
   \   000017 2713                  JREQ      L:??CrossCallReturnLabel_124
   \   000019 A120                  CP        A, #0x20
   \   00001B 270F                  JREQ      L:??CrossCallReturnLabel_124
   \   00001D A140                  CP        A, #0x40
   \   00001F 270B                  JREQ      L:??CrossCallReturnLabel_124
   \   000021 A180                  CP        A, #0x80
   \   000023 2707                  JREQ      L:??CrossCallReturnLabel_124
   \   000025 AE0878                LDW       X, #0x878
   \   000028 8D000000              CALLF     ?Subroutine9
   2169          
   2170              TIM1_itStatus = (uint8_t)(TIM1->SR1 & (uint8_t)TIM1_IT);
   \                     ??CrossCallReturnLabel_124:
   \   00002C C65255                LD        A, L:0x5255
   \   00002F B700                  LD        S:?b1, A
   2171          
   2172              TIM1_itEnable = (uint8_t)(TIM1->IER & (uint8_t)TIM1_IT);
   \   000031 B600                  LD        A, S:?b8
   \   000033 C45254                AND       A, L:0x5254
   \   000036 B700                  LD        S:?b0, A
   2173          
   2174              if ((TIM1_itStatus != (uint8_t)RESET ) && (TIM1_itEnable != (uint8_t)RESET ))
   \   000038 B600                  LD        A, S:?b8
   \   00003A B500                  BCP       A, S:?b1
   \   00003C 2708                  JREQ      L:??TIM1_GetITStatus_0
   \   00003E 3D00                  TNZ       S:?b0
   \   000040 2704                  JREQ      L:??TIM1_GetITStatus_0
   2175              {
   2176                  bitstatus = SET;
   \   000042 A601                  LD        A, #0x1
   \   000044 2001                  JRA       L:??TIM1_GetITStatus_1
   2177              }
   2178              else
   2179              {
   2180                  bitstatus = RESET;
   \                     ??TIM1_GetITStatus_0:
   \   000046 4F                    CLR       A
   2181              }
   2182              return (ITStatus)(bitstatus);
   \                     ??TIM1_GetITStatus_1:
   \   000047 320000                POP       S:?b8
   \   00004A 87                    RETF
   2183          }
   2184          
   2185          /**
   2186            * @brief  Clears the TIM1's interrupt pending bits.
   2187            * @param  TIM1_IT specifies the pending bit to clear.
   2188            *         This parameter can be one of the following values:
   2189            *                       - TIM1_IT_UPDATE: TIM1 update Interrupt source
   2190            *                       - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
   2191            *                       - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
   2192            *                       - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
   2193            *                       - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
   2194            *                       - TIM1_IT_COM: TIM1 Commutation Interrupt source
   2195            *                       - TIM1_IT_TRIGGER: TIM1 Trigger Interrupt source
   2196            *                       - TIM1_IT_BREAK: TIM1 Break Interrupt source
   2197            * @retval None.
   2198            */

   \                                 In section .far_func.text, align 1
   2199          void TIM1_ClearITPendingBit(TIM1_IT_TypeDef TIM1_IT)
   2200          {
   \                     TIM1_ClearITPendingBit:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   2201              /* Check the parameters */
   2202              assert_param(IS_TIM1_IT_OK(TIM1_IT));
   \   000005 2607                  JRNE      L:??CrossCallReturnLabel_125
   \   000007 AE089A                LDW       X, #0x89a
   \   00000A 8D000000              CALLF     ?Subroutine9
   2203          
   2204              /* Clear the IT pending Bit */
   2205              TIM1->SR1 = (uint8_t)(~(uint8_t)TIM1_IT);
   \                     ??CrossCallReturnLabel_125:
   \   00000E 3300                  CPL       S:?b8
   \   000010 B600                  LD        A, S:?b8
   \   000012 C75255                LD        L:0x5255, A
   2206          }
   \   000015 320000                POP       S:?b8
   \   000018 87                    RETF
   2207          
   2208          /**
   2209            * @brief  Configure the TI1 as Input.
   2210            * @param  TIM1_ICPolarity  The Input Polarity.
   2211            *         This parameter can be one of the following values:
   2212            *                       - TIM1_ICPOLARITY_FALLING
   2213            *                       - TIM1_ICPOLARITY_RISING
   2214            * @param  TIM1_ICSelection specifies the input to be used.
   2215            *         This parameter can be one of the following values:
   2216            *                       - TIM1_ICSELECTION_DIRECTTI: TIM1 Input 1 is selected to
   2217            *                         be connected to IC1.
   2218            *                       - TIM1_ICSELECTION_INDIRECTTI: TIM1 Input 1 is selected to
   2219            *                         be connected to IC2.
   2220            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2221            *         This parameter must be a value between 0x00 and 0x0F.
   2222            * @retval None
   2223            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine1:
   \   000000 A40C                  AND       A, #0xc
   \   000002 BA00                  OR        A, S:?b0
   \   000004 B700                  LD        S:?b0, A
   \   000006 B600                  LD        A, S:?b1
   \   000008 4E                    SWAP      A
   \   000009 A4F0                  AND       A, #0xf0
   \   00000B BA00                  OR        A, S:?b0
   \   00000D 87                    RETF

   \                                 In section .far_func.text, align 1
   2224          static void TI1_Config(uint8_t TIM1_ICPolarity,
   2225                                 uint8_t TIM1_ICSelection,
   2226                                 uint8_t TIM1_ICFilter)
   2227          {
   \                     TI1_Config:
   \   000000 B700                  LD        S:?b2, A
   2228          
   2229              /* Disable the Channel 1: Reset the CCE Bit */
   2230              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \   000002 7211525C              BRES      L:0x525c, #0x0
   2231          
   2232              /* Select the Input and set the filter */
   2233              TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~(uint8_t)( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF ))) | 
   2234                                      (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000006 C65258                LD        A, L:0x5258
   \   000009 8D000000              CALLF     ?Subroutine1
   \                     ??CrossCallReturnLabel_7:
   \   00000D C75258                LD        L:0x5258, A
   2235          
   2236              /* Select the Polarity */
   2237              if (TIM1_ICPolarity != TIM1_ICPOLARITY_RISING)
   \   000010 3D00                  TNZ       S:?b2
   \   000012 2706                  JREQ      L:??TI1_Config_0
   2238              {
   2239                  TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \   000014 7212525C              BSET      L:0x525c, #0x1
   \   000018 2004                  JRA       L:??TI1_Config_1
   2240              }
   2241              else
   2242              {
   2243                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TI1_Config_0:
   \   00001A 7213525C              BRES      L:0x525c, #0x1
   2244              }
   2245          
   2246              /* Set the CCE Bit */
   2247              TIM1->CCER1 |=  TIM1_CCER1_CC1E;
   \                     ??TI1_Config_1:
   \   00001E 7210525C              BSET      L:0x525c, #0x0
   2248          }
   \   000022 87                    RETF
   2249          
   2250          /**
   2251            * @brief  Configure the TI2 as Input.
   2252            * @param  TIM1_ICPolarity  The Input Polarity.
   2253            *         This parameter can be one of the following values:
   2254            *                       - TIM1_ICPOLARITY_FALLING
   2255            *                       - TIM1_ICPOLARITY_RISING
   2256            * @param  TIM1_ICSelection specifies the input to be used.
   2257            *         This parameter can be one of the following values:
   2258            *                       - TIM1_ICSELECTION_DIRECTTI: TIM1 Input 2 is selected to
   2259            *                         be connected to IC2.
   2260            *                       - TIM1_ICSELECTION_INDIRECTTI: TIM1 Input 2 is selected to
   2261            *                         be connected to IC1.
   2262            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2263            *         This parameter must be a value between 0x00 and 0x0F.
   2264            * @retval None
   2265            */

   \                                 In section .far_func.text, align 1
   2266          static void TI2_Config(uint8_t TIM1_ICPolarity,
   2267                                 uint8_t TIM1_ICSelection,
   2268                                 uint8_t TIM1_ICFilter)
   2269          {
   \                     TI2_Config:
   \   000000 B700                  LD        S:?b2, A
   2270              /* Disable the Channel 2: Reset the CCE Bit */
   2271              TIM1->CCER1 &=  (uint8_t)(~TIM1_CCER1_CC2E);
   \   000002 7219525C              BRES      L:0x525c, #0x4
   2272          
   2273              /* Select the Input and set the filter */
   2274              TIM1->CCMR2  = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~(uint8_t)( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF ))) 
   2275                                      | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000006 C65259                LD        A, L:0x5259
   \   000009 8D000000              CALLF     ?Subroutine1
   \                     ??CrossCallReturnLabel_6:
   \   00000D C75259                LD        L:0x5259, A
   2276              /* Select the Polarity */
   2277              if (TIM1_ICPolarity != TIM1_ICPOLARITY_RISING)
   \   000010 3D00                  TNZ       S:?b2
   \   000012 2706                  JREQ      L:??TI2_Config_0
   2278              {
   2279                  TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \   000014 721A525C              BSET      L:0x525c, #0x5
   \   000018 2004                  JRA       L:??TI2_Config_1
   2280              }
   2281              else
   2282              {
   2283                  TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TI2_Config_0:
   \   00001A 721B525C              BRES      L:0x525c, #0x5
   2284              }
   2285              /* Set the CCE Bit */
   2286              TIM1->CCER1 |=  TIM1_CCER1_CC2E;
   \                     ??TI2_Config_1:
   \   00001E 7218525C              BSET      L:0x525c, #0x4
   2287          }
   \   000022 87                    RETF
   2288          
   2289          /**
   2290            * @brief  Configure the TI3 as Input.
   2291            * @param  TIM1_ICPolarity  The Input Polarity.
   2292            *         This parameter can be one of the following values:
   2293            *                       - TIM1_ICPOLARITY_FALLING
   2294            *                       - TIM1_ICPOLARITY_RISING
   2295            * @param  TIM1_ICSelection specifies the input to be used.
   2296            *         This parameter can be one of the following values:
   2297            *                       - TIM1_ICSELECTION_DIRECTTI: TIM1 Input 3 is selected to
   2298            *                         be connected to IC3.
   2299            *                       - TIM1_ICSELECTION_INDIRECTTI: TIM1 Input 3 is selected to
   2300            *                         be connected to IC4.
   2301            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2302            *         This parameter must be a value between 0x00 and 0x0F.
   2303            * @retval None
   2304            */

   \                                 In section .far_func.text, align 1
   2305          static void TI3_Config(uint8_t TIM1_ICPolarity,
   2306                                 uint8_t TIM1_ICSelection,
   2307                                 uint8_t TIM1_ICFilter)
   2308          {
   \                     TI3_Config:
   \   000000 B700                  LD        S:?b2, A
   2309              /* Disable the Channel 3: Reset the CCE Bit */
   2310              TIM1->CCER2 &=  (uint8_t)(~TIM1_CCER2_CC3E);
   \   000002 7211525D              BRES      L:0x525d, #0x0
   2311          
   2312              /* Select the Input and set the filter */
   2313              TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~(uint8_t)( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF))) 
   2314                                      | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000006 C6525A                LD        A, L:0x525a
   \   000009 8D000000              CALLF     ?Subroutine1
   \                     ??CrossCallReturnLabel_5:
   \   00000D C7525A                LD        L:0x525a, A
   2315          
   2316              /* Select the Polarity */
   2317              if (TIM1_ICPolarity != TIM1_ICPOLARITY_RISING)
   \   000010 3D00                  TNZ       S:?b2
   \   000012 2706                  JREQ      L:??TI3_Config_0
   2318              {
   2319                  TIM1->CCER2 |= TIM1_CCER2_CC3P;
   \   000014 7212525D              BSET      L:0x525d, #0x1
   \   000018 2004                  JRA       L:??TI3_Config_1
   2320              }
   2321              else
   2322              {
   2323                  TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3P);
   \                     ??TI3_Config_0:
   \   00001A 7213525D              BRES      L:0x525d, #0x1
   2324              }
   2325              /* Set the CCE Bit */
   2326              TIM1->CCER2 |=  TIM1_CCER2_CC3E;
   \                     ??TI3_Config_1:
   \   00001E 7210525D              BSET      L:0x525d, #0x0
   2327          }
   \   000022 87                    RETF
   2328          
   2329          
   2330          /**
   2331            * @brief  Configure the TI4 as Input.
   2332            * @param  TIM1_ICPolarity  The Input Polarity.
   2333            *         This parameter can be one of the following values:
   2334            *                       - TIM1_ICPOLARITY_FALLING
   2335            *                       - TIM1_ICPOLARITY_RISING
   2336            * @param  TIM1_ICSelection specifies the input to be used.
   2337            *         This parameter can be one of the following values:
   2338            *                       - TIM1_ICSELECTION_DIRECTTI: TIM1 Input 4 is selected to
   2339            *                         be connected to IC4.
   2340            *                       - TIM1_ICSELECTION_INDIRECTTI: TIM1 Input 4 is selected to
   2341            *                         be connected to IC3.
   2342            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2343            *         This parameter must be a value between 0x00 and 0x0F.
   2344            * @retval None
   2345            */

   \                                 In section .far_func.text, align 1
   2346          static void TI4_Config(uint8_t TIM1_ICPolarity,
   2347                                 uint8_t TIM1_ICSelection,
   2348                                 uint8_t TIM1_ICFilter)
   2349          {
   \                     TI4_Config:
   \   000000 B700                  LD        S:?b2, A
   2350          
   2351              /* Disable the Channel 4: Reset the CCE Bit */
   2352              TIM1->CCER2 &=  (uint8_t)(~TIM1_CCER2_CC4E);
   \   000002 7219525D              BRES      L:0x525d, #0x4
   2353          
   2354              /* Select the Input and set the filter */
   2355              TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~(uint8_t)( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF )))
   2356                                      | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000006 C6525B                LD        A, L:0x525b
   \   000009 8D000000              CALLF     ?Subroutine1
   \                     ??CrossCallReturnLabel_4:
   \   00000D C7525B                LD        L:0x525b, A
   2357          
   2358              /* Select the Polarity */
   2359              if (TIM1_ICPolarity != TIM1_ICPOLARITY_RISING)
   \   000010 3D00                  TNZ       S:?b2
   \   000012 2706                  JREQ      L:??TI4_Config_0
   2360              {
   2361                  TIM1->CCER2 |= TIM1_CCER2_CC4P;
   \   000014 721A525D              BSET      L:0x525d, #0x5
   \   000018 2004                  JRA       L:??TI4_Config_1
   2362              }
   2363              else
   2364              {
   2365                  TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4P);
   \                     ??TI4_Config_0:
   \   00001A 721B525D              BRES      L:0x525d, #0x5
   2366              }
   2367          
   2368              /* Set the CCE Bit */
   2369              TIM1->CCER2 |=  TIM1_CCER2_CC4E;
   \                     ??TI4_Config_1:
   \   00001E 7218525D              BSET      L:0x525d, #0x4
   2370          }
   \   000022 87                    RETF

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\Documents and Sett...">`:
   \   000000 433A5C446F63          DC8 43H, 3AH, 5CH, 44H, 6FH, 63H, 75H, 6DH
   \   000008 656E74732061          DC8 65H, 6EH, 74H, 73H, 20H, 61H, 6EH, 64H
   \   000010 205365747469          DC8 20H, 53H, 65H, 74H, 74H, 69H, 6EH, 67H
   \   000018 735C41646D69          DC8 73H, 5CH, 41H, 64H, 6DH, 69H, 6EH, 69H
   \   000020 73747261746F          DC8 73H, 74H, 72H, 61H, 74H, 6FH, 72H, 5CH
   \   000028 4465736B746F          DC8 44H, 65H, 73H, 6BH, 74H, 6FH, 70H, 5CH
   \   000030 73746D387331          DC8 73H, 74H, 6DH, 38H, 73H, 31H, 30H, 35H
   \   000038 6B2D636F6E74          DC8 6BH, 2DH, 63H, 6FH, 6EH, 74H, 72H, 6FH
   \   000040 6C6C65725C4C          DC8 6CH, 6CH, 65H, 72H, 5CH, 4CH, 69H, 62H
   \   000048 726172696573          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \   000050 544D38535F53          DC8 54H, 4DH, 38H, 53H, 5FH, 53H, 74H, 64H
   \   000058 506572697068          DC8 50H, 65H, 72H, 69H, 70H, 68H, 5FH, 44H
   \   000060 72697665725C          DC8 72H, 69H, 76H, 65H, 72H, 5CH, 73H, 72H
   \   000068 635C73746D38          DC8 63H, 5CH, 73H, 74H, 6DH, 38H, 73H, 5FH
   \   000070 74696D312E63          DC8 74H, 69H, 6DH, 31H, 2EH, 63H, 0
   2371          
   2372          
   2373          /**
   2374            * @}
   2375            */
   2376            
   2377          /**
   2378            * @}
   2379            */
   2380            
   2381          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                          Bytes
     --------------                          -----
     TIM1_DeInit                              153
     ?Subroutine9                              12
     TIM1_TimeBaseInit                         81
     ?Subroutine12                             14
     ?Subroutine13                              9
     ?Subroutine5                              21
     TIM1_OC1Init                             215
     ?Subroutine8                              11
     ?Subroutine2                              31
     TIM1_OC2Init                             241
     ?Subroutine7                              11
     TIM1_OC3Init                             215
     ?Subroutine4                              11
     TIM1_OC4Init                             170
     ?Subroutine3                              11
     TIM1_BDTRConfig                          138
     TIM1_ICInit                              179
     ?Subroutine17                              7
     ?Subroutine15                             15
     ?Subroutine11                              7
     ?Subroutine18                             10
     ?Subroutine10                              7
     ?Subroutine19                             10
     TIM1_PWMIConfig                          170
     TIM1_Cmd                                  24
     TIM1_CtrlPWMOutputs                       24
     TIM1_ITConfig                             56
     TIM1_InternalClockConfig                   9
     ?Subroutine6                               9
     TIM1_ETRClockMode1Config                  68
     ?Subroutine16                             12
     TIM1_ETRClockMode2Config                  64
     TIM1_ETRConfig                            47
     TIM1_TIxExternalClockConfig              108
     TIM1_SelectInputTrigger                   50
     TIM1_UpdateDisableConfig                  24
     TIM1_UpdateRequestConfig                  24
     TIM1_SelectHallSensor                     24
     TIM1_SelectOnePulseMode                   24
     TIM1_SelectOutputTrigger                  52
     TIM1_SelectSlaveMode                      42
     TIM1_SelectMasterSlaveMode                24
     TIM1_EncoderInterfaceConfig              133
     TIM1_PrescalerConfig                      41
     TIM1_CounterModeConfig                    44
     TIM1_ForcedOC1Config                      28
     TIM1_ForcedOC2Config                      28
     TIM1_ForcedOC3Config                      28
     TIM1_ForcedOC4Config                      28
     TIM1_ARRPreloadConfig                     24
     TIM1_SelectCOM                            24
     TIM1_CCPreloadControl                     24
     TIM1_OC1PreloadConfig                     24
     TIM1_OC2PreloadConfig                     24
     TIM1_OC3PreloadConfig                     24
     TIM1_OC4PreloadConfig                     24
     TIM1_OC1FastConfig                        24
     TIM1_OC2FastConfig                        24
     TIM1_OC3FastConfig                        24
     TIM1_OC4FastConfig                        24
     TIM1_GenerateEvent                        23
     TIM1_OC1PolarityConfig                    24
     TIM1_OC1NPolarityConfig                   24
     TIM1_OC2PolarityConfig                    24
     TIM1_OC2NPolarityConfig                   24
     TIM1_OC3PolarityConfig                    24
     TIM1_OC3NPolarityConfig                   24
     TIM1_OC4PolarityConfig                    24
     TIM1_CCxCmd                              141
     TIM1_CCxNCmd                             113
     TIM1_SelectOCxM                          157
     TIM1_SetCounter                           14
     TIM1_SetAutoreload                        14
     TIM1_SetCompare1                          14
     TIM1_SetCompare2                          14
     TIM1_SetCompare3                          14
     TIM1_SetCompare4                          14
     TIM1_SetIC1Prescaler                      40
     TIM1_SetIC2Prescaler                      40
     TIM1_SetIC3Prescaler                      40
     TIM1_SetIC4Prescaler                      40
     ?Subroutine0                              22
     TIM1_GetCapture1                          13
     TIM1_GetCapture2                          13
     TIM1_GetCapture3                          13
     TIM1_GetCapture4                          13
     TIM1_GetCounter                           15
     ?Subroutine14                             12
     TIM1_GetPrescaler                         15
     TIM1_GetFlagStatus                       109
     TIM1_ClearFlag                            47
     TIM1_GetITStatus                          75
     TIM1_ClearITPendingBit                    25
     ?Subroutine1                              14
     TI1_Config                                35
     TI2_Config                                35
     TI3_Config                                35
     TI4_Config                                35
     ?<Constant "C:\\Documents and Sett...">  119

 
 4 400 bytes in section .far_func.text
   119 bytes in section .near.rodata
 
 4 400 bytes of CODE  memory
   119 bytes of CONST memory

Errors: none
Warnings: none
