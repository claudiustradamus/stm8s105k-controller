###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             08/Mar/2013  21:34:36 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\Volt2Ser #
#                    ial\Libraries\STM8S_StdPeriph_Driver\src\stm8s_spi.c     #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\Volt2Se #
#                    rial\Libraries\STM8S_StdPeriph_Driver\src\stm8s_spi.c"   #
#                    -e -Ohz --debug --code_model medium --data_model medium  #
#                    -o "C:\Documents and Settings\Administrator\Desktop\Volt #
#                    2Serial\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S105 #
#                    \Obj\" --dlib_config "C:\Program Files\IAR               #
#                    Systems\Embedded Workbench 6.0\stm8\LIB\dlstm8mmf.h" -D  #
#                    STM8S105 -lC "C:\Documents and                           #
#                    Settings\Administrator\Desktop\Volt2Serial\Project\STM8S #
#                    _StdPeriph_Template\EWSTM8\STM8S105\List\" -lA           #
#                    "C:\Documents and Settings\Administrator\Desktop\Volt2Se #
#                    rial\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Li #
#                    st\" -I "C:\Documents and Settings\Administrator\Desktop #
#                    \Volt2Serial\Project\STM8S_StdPeriph_Template\EWSTM8\..\ #
#                    " -I "C:\Documents and Settings\Administrator\Desktop\Vo #
#                    lt2Serial\Project\STM8S_StdPeriph_Template\EWSTM8\..\..\ #
#                    ..\Libraries\STM8S_StdPeriph_Driver\inc\" --vregs 16     #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\Volt2Ser #
#                    ial\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Lis #
#                    t\stm8s_spi.lst                                          #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\Volt2Ser #
#                    ial\Project\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Obj #
#                    \stm8s_spi.o                                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\Volt2Serial\Libraries\STM8S_StdPeriph_Driver\src\stm8s_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_spi.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the SPI peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_spi.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28            
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          
     35          /** @addtogroup SPI_Public_Functions
     36            * @{
     37            */
     38          
     39          /**
     40            * @brief  Deinitializes the SPI peripheral registers to their default reset values.
     41            * @param  None
     42            * @retval None
     43            */

   \                                 In section .far_func.text, align 1
     44          void SPI_DeInit(void)
     45          {
     46              SPI->CR1    = SPI_CR1_RESET_VALUE;
   \                     SPI_DeInit:
   \   000000 725F5200              CLR       L:0x5200
     47              SPI->CR2    = SPI_CR2_RESET_VALUE;
   \   000004 725F5201              CLR       L:0x5201
     48              SPI->ICR    = SPI_ICR_RESET_VALUE;
   \   000008 725F5202              CLR       L:0x5202
     49              SPI->SR     = SPI_SR_RESET_VALUE;
   \   00000C 35025203              MOV       L:0x5203, #0x2
     50              SPI->CRCPR  = SPI_CRCPR_RESET_VALUE;
   \   000010 35075205              MOV       L:0x5205, #0x7
     51          }
   \   000014 87                    RETF
     52          
     53          /**
     54            * @brief  Initializes the SPI according to the specified parameters.
     55            * @param  FirstBit : This parameter can be any of the 
     56            *         @ref SPI_FirstBit_TypeDef enumeration.
     57            * @param  BaudRatePrescaler : This parameter can be any of the 
     58            *         @ref SPI_BaudRatePrescaler_TypeDef enumeration.
     59            * @param  Mode : This parameter can be any of the  
     60            *         @ref SPI_Mode_TypeDef enumeration.
     61            * @param  ClockPolarity : This parameter can be any of the 
     62            *         @ref SPI_ClockPolarity_TypeDef enumeration.
     63            * @param  ClockPhase : This parameter can be any of the 
     64            *         @ref SPI_ClockPhase_TypeDef enumeration.
     65            * @param  Data_Direction : This parameter can be any of the 
     66            *         @ref SPI_DataDirection_TypeDef enumeration.
     67            * @param  Slave_Management : This parameter can be any of the 
     68            *         @ref SPI_NSS_TypeDef enumeration.
     69            * @param  CRCPolynomial : Configures the CRC polynomial.
     70            * @retval None
     71            */

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 AE0000                LDW       X, #`?<Constant "C:\\\\Documents and Sett...">`
   \   000008 AC000000              JPF       assert_failed

   \                                 In section .far_func.text, align 1
     72          void SPI_Init(SPI_FirstBit_TypeDef FirstBit, SPI_BaudRatePrescaler_TypeDef BaudRatePrescaler, SPI_Mode_TypeDef Mode, SPI_ClockPolarity_TypeDef ClockPolarity, SPI_ClockPhase_TypeDef ClockPhase, SPI_DataDirection_TypeDef Data_Direction, SPI_NSS_TypeDef Slave_Management, uint8_t CRCPolynomial)
     73          {
   \                     SPI_Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 B700                  LD        S:?b15, A
   \   00000A 450000                MOV       S:?b8, S:?b0
   \   00000D 450000                MOV       S:?b9, S:?b1
   \   000010 450000                MOV       S:?b14, S:?b2
   \   000013 450000                MOV       S:?b13, S:?b3
   \   000016 450000                MOV       S:?b10, S:?b4
   \   000019 450000                MOV       S:?b12, S:?b5
   \   00001C 450000                MOV       S:?b11, S:?b6
     74              /* Check structure elements */
     75              assert_param(IS_SPI_FIRSTBIT_OK(FirstBit));
   \   00001F 270B                  JREQ      L:??CrossCallReturnLabel_7
   \   000021 A180                  CP        A, #0x80
   \   000023 2707                  JREQ      L:??CrossCallReturnLabel_7
   \   000025 AE004B                LDW       X, #0x4b
   \   000028 8D000000              CALLF     ?Subroutine0
     76              assert_param(IS_SPI_BAUDRATE_PRESCALER_OK(BaudRatePrescaler));
   \                     ??CrossCallReturnLabel_7:
   \   00002C 3D00                  TNZ       S:?b8
   \   00002E 2725                  JREQ      L:??CrossCallReturnLabel_6
   \   000030 B600                  LD        A, S:?b8
   \   000032 A108                  CP        A, #0x8
   \   000034 271F                  JREQ      L:??CrossCallReturnLabel_6
   \   000036 A110                  CP        A, #0x10
   \   000038 271B                  JREQ      L:??CrossCallReturnLabel_6
   \   00003A A118                  CP        A, #0x18
   \   00003C 2717                  JREQ      L:??CrossCallReturnLabel_6
   \   00003E A120                  CP        A, #0x20
   \   000040 2713                  JREQ      L:??CrossCallReturnLabel_6
   \   000042 A128                  CP        A, #0x28
   \   000044 270F                  JREQ      L:??CrossCallReturnLabel_6
   \   000046 A130                  CP        A, #0x30
   \   000048 270B                  JREQ      L:??CrossCallReturnLabel_6
   \   00004A A138                  CP        A, #0x38
   \   00004C 2707                  JREQ      L:??CrossCallReturnLabel_6
   \   00004E AE004C                LDW       X, #0x4c
   \   000051 8D000000              CALLF     ?Subroutine0
     77              assert_param(IS_SPI_MODE_OK(Mode));
   \                     ??CrossCallReturnLabel_6:
   \   000055 B600                  LD        A, S:?b9
   \   000057 A104                  CP        A, #0x4
   \   000059 270B                  JREQ      L:??CrossCallReturnLabel_5
   \   00005B 3D00                  TNZ       S:?b9
   \   00005D 2707                  JREQ      L:??CrossCallReturnLabel_5
   \   00005F AE004D                LDW       X, #0x4d
   \   000062 8D000000              CALLF     ?Subroutine0
     78              assert_param(IS_SPI_POLARITY_OK(ClockPolarity));
   \                     ??CrossCallReturnLabel_5:
   \   000066 3D00                  TNZ       S:?b14
   \   000068 270D                  JREQ      L:??CrossCallReturnLabel_4
   \   00006A B600                  LD        A, S:?b14
   \   00006C A102                  CP        A, #0x2
   \   00006E 2707                  JREQ      L:??CrossCallReturnLabel_4
   \   000070 AE004E                LDW       X, #0x4e
   \   000073 8D000000              CALLF     ?Subroutine0
     79              assert_param(IS_SPI_PHASE_OK(ClockPhase));
   \                     ??CrossCallReturnLabel_4:
   \   000077 3D00                  TNZ       S:?b13
   \   000079 270D                  JREQ      L:??CrossCallReturnLabel_3
   \   00007B B600                  LD        A, S:?b13
   \   00007D A101                  CP        A, #0x1
   \   00007F 2707                  JREQ      L:??CrossCallReturnLabel_3
   \   000081 AE004F                LDW       X, #0x4f
   \   000084 8D000000              CALLF     ?Subroutine0
     80              assert_param(IS_SPI_DATA_DIRECTION_OK(Data_Direction));
   \                     ??CrossCallReturnLabel_3:
   \   000088 3D00                  TNZ       S:?b10
   \   00008A 2715                  JREQ      L:??CrossCallReturnLabel_2
   \   00008C B600                  LD        A, S:?b10
   \   00008E A104                  CP        A, #0x4
   \   000090 270F                  JREQ      L:??CrossCallReturnLabel_2
   \   000092 A180                  CP        A, #0x80
   \   000094 270B                  JREQ      L:??CrossCallReturnLabel_2
   \   000096 A1C0                  CP        A, #0xc0
   \   000098 2707                  JREQ      L:??CrossCallReturnLabel_2
   \   00009A AE0050                LDW       X, #0x50
   \   00009D 8D000000              CALLF     ?Subroutine0
     81              assert_param(IS_SPI_SLAVEMANAGEMENT_OK(Slave_Management));
   \                     ??CrossCallReturnLabel_2:
   \   0000A1 B600                  LD        A, S:?b12
   \   0000A3 A102                  CP        A, #0x2
   \   0000A5 270B                  JREQ      L:??CrossCallReturnLabel_1
   \   0000A7 3D00                  TNZ       S:?b12
   \   0000A9 2707                  JREQ      L:??CrossCallReturnLabel_1
   \   0000AB AE0051                LDW       X, #0x51
   \   0000AE 8D000000              CALLF     ?Subroutine0
     82              assert_param(IS_SPI_CRC_POLYNOMIAL_OK(CRCPolynomial));
   \                     ??CrossCallReturnLabel_1:
   \   0000B2 3D00                  TNZ       S:?b11
   \   0000B4 2607                  JRNE      L:??CrossCallReturnLabel_0
   \   0000B6 AE0052                LDW       X, #0x52
   \   0000B9 8D000000              CALLF     ?Subroutine0
     83          
     84              /* Frame Format, BaudRate, Clock Polarity and Phase configuration */
     85              SPI->CR1 = (uint8_t)((uint8_t)((uint8_t)FirstBit | BaudRatePrescaler) |
     86                              (uint8_t)((uint8_t)ClockPolarity | ClockPhase));
   \                     ??CrossCallReturnLabel_0:
   \   0000BD B600                  LD        A, S:?b8
   \   0000BF BA00                  OR        A, S:?b15
   \   0000C1 BA00                  OR        A, S:?b14
   \   0000C3 BA00                  OR        A, S:?b13
   \   0000C5 C75200                LD        L:0x5200, A
     87          
     88              /* Data direction configuration: BDM, BDOE and RXONLY bits */
     89              SPI->CR2 = (uint8_t)((uint8_t)(Data_Direction) | (uint8_t)(Slave_Management));
   \   0000C8 B600                  LD        A, S:?b12
   \   0000CA BA00                  OR        A, S:?b10
   \   0000CC C75201                LD        L:0x5201, A
     90          
     91              if (Mode == SPI_MODE_MASTER)
   \   0000CF B600                  LD        A, S:?b9
   \   0000D1 A104                  CP        A, #0x4
   \   0000D3 2606                  JRNE      L:??SPI_Init_0
     92              {
     93                  SPI->CR2 |= (uint8_t)SPI_CR2_SSI;
   \   0000D5 72105201              BSET      L:0x5201, #0x0
   \   0000D9 2004                  JRA       L:??SPI_Init_1
     94              }
     95              else
     96              {
     97                  SPI->CR2 &= (uint8_t)~(SPI_CR2_SSI);
   \                     ??SPI_Init_0:
   \   0000DB 72115201              BRES      L:0x5201, #0x0
     98              }
     99          
    100              /* Master/Slave mode configuration */
    101              SPI->CR1 |= (uint8_t)(Mode);
   \                     ??SPI_Init_1:
   \   0000DF CA5200                OR        A, L:0x5200
   \   0000E2 C75200                LD        L:0x5200, A
    102          
    103              /* CRC configuration */
    104              SPI->CRCPR = (uint8_t)CRCPolynomial;
   \   0000E5 B600                  LD        A, S:?b11
   \   0000E7 C75205                LD        L:0x5205, A
    105          }
   \   0000EA AC000000              JPF       L:?epilogue_l2_l3
    106          
    107          /**
    108            * @brief  Enables or disables the SPI peripheral.
    109            * @param  NewState New state of the SPI peripheral.
    110            *         This parameter can be: ENABLE or DISABLE
    111            * @retval None
    112            */

   \                                 In section .far_func.text, align 1, keep-with-next
    113          void SPI_Cmd(FunctionalState NewState)
    114          {
    115              /* Check function parameters */
    116              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     SPI_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??SPI_Cmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_13
   \   000007 AE0074                LDW       X, #0x74
   \   00000A 8D000000              CALLF     ?Subroutine0
    117          
    118              if (NewState != DISABLE)
    119              {
    120                  SPI->CR1 |= SPI_CR1_SPE; /* Enable the SPI peripheral*/
   \                     ??CrossCallReturnLabel_13:
   \   00000E 721C5200              BSET      L:0x5200, #0x6
   \   000012 87                    RETF
    121              }
    122              else
    123              {
    124                  SPI->CR1 &= (uint8_t)(~SPI_CR1_SPE); /* Disable the SPI peripheral*/
   \                     ??SPI_Cmd_0:
   \   000013 721D5200              BRES      L:0x5200, #0x6
    125              }
    126          }
   \   000017 87                    RETF
    127          
    128          /**
    129            * @brief  Enables or disables the specified interrupts.
    130            * @param  SPI_IT Specifies the SPI interrupts sources to be enabled or disabled.
    131            * @param  NewState: The new state of the specified SPI interrupts.
    132            *         This parameter can be: ENABLE or DISABLE.
    133            * @retval None
    134            */

   \                                 In section .far_func.text, align 1
    135          void SPI_ITConfig(SPI_IT_TypeDef SPI_IT, FunctionalState NewState)
    136          {
   \                     SPI_ITConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    137              uint8_t itpos = 0;
    138              /* Check function parameters */
    139              assert_param(IS_SPI_CONFIG_IT_OK(SPI_IT));
   \   000009 A117                  CP        A, #0x17
   \   00000B 2713                  JREQ      L:??CrossCallReturnLabel_9
   \   00000D A106                  CP        A, #0x6
   \   00000F 270F                  JREQ      L:??CrossCallReturnLabel_9
   \   000011 A105                  CP        A, #0x5
   \   000013 270B                  JREQ      L:??CrossCallReturnLabel_9
   \   000015 A134                  CP        A, #0x34
   \   000017 2707                  JREQ      L:??CrossCallReturnLabel_9
   \   000019 AE008B                LDW       X, #0x8b
   \   00001C 8D000000              CALLF     ?Subroutine0
    140              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_9:
   \   000020 3D00                  TNZ       S:?b9
   \   000022 270D                  JREQ      L:??CrossCallReturnLabel_8
   \   000024 B600                  LD        A, S:?b9
   \   000026 A101                  CP        A, #0x1
   \   000028 2707                  JREQ      L:??CrossCallReturnLabel_8
   \   00002A AE008C                LDW       X, #0x8c
   \   00002D 8D000000              CALLF     ?Subroutine0
    141          
    142              /* Get the SPI IT index */
    143              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)SPI_IT & (uint8_t)0x0F));
   \                     ??CrossCallReturnLabel_8:
   \   000031 B600                  LD        A, S:?b8
   \   000033 8D000000              CALLF     ??Subroutine2_0
    144          
    145              if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_20:
   \   000037 3D00                  TNZ       S:?b9
   \   000039 2705                  JREQ      L:??SPI_ITConfig_0
    146              {
    147                  SPI->ICR |= itpos; /* Enable interrupt*/
   \   00003B CA5202                OR        A, L:0x5202
   \   00003E 2004                  JRA       ??SPI_ITConfig_1
    148              }
    149              else
    150              {
    151                  SPI->ICR &= (uint8_t)(~itpos); /* Disable interrupt*/
   \                     ??SPI_ITConfig_0:
   \   000040 43                    CPL       A
   \   000041 C45202                AND       A, L:0x5202
   \                     ??SPI_ITConfig_1:
   \   000044 C75202                LD        L:0x5202, A
    152              }
    153          }
   \   000047 AC000000              JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1
   \                     ??Subroutine2_0:
   \   000000 A40F                  AND       A, #0xf
   \   000002 5F                    CLRW      X
   \   000003 5C                    INCW      X
   \   000004 8D000000              CALLF     L:?sll16_x_x_a
   \   000008 9F                    LD        A, XL
   \   000009 87                    RETF
    154          /**
    155            * @brief  Transmits a Data through the SPI peripheral.
    156            * @param  Data : Byte to be transmitted.
    157            * @retval None
    158            */

   \                                 In section .far_func.text, align 1
    159          void SPI_SendData(uint8_t Data)
    160          {
    161              SPI->DR = Data; /* Write in the DR register the data to be sent*/
   \                     SPI_SendData:
   \   000000 C75204                LD        L:0x5204, A
    162          }
   \   000003 87                    RETF
    163          
    164          /**
    165            * @brief  Returns the most recent received data by the SPI peripheral.
    166            * @param  None
    167            * @retval The value of the received data.
    168            */

   \                                 In section .far_func.text, align 1
    169          uint8_t SPI_ReceiveData(void)
    170          {
    171              return ((uint8_t)SPI->DR); /* Return the data in the DR register*/
   \                     SPI_ReceiveData:
   \   000000 C65204                LD        A, L:0x5204
   \   000003 87                    RETF
    172          }
    173          
    174          /**
    175            * @brief  Configures internally by software the NSS pin.
    176            * @param  NewState Indicates the new state of the SPI Software slave management.
    177            *         This parameter can be: ENABLE or DISABLE.
    178            * @retval None
    179            */

   \                                 In section .far_func.text, align 1
    180          void SPI_NSSInternalSoftwareCmd(FunctionalState NewState)
    181          {
    182              /* Check function parameters */
    183              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     SPI_NSSInternalSoftwareCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??SPI_NSSInternalSoftwareCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_10
   \   000007 AE00B7                LDW       X, #0xb7
   \   00000A 8D000000              CALLF     ?Subroutine0
    184          
    185              if (NewState != DISABLE)
    186              {
    187                  SPI->CR2 |= SPI_CR2_SSI; /* Set NSS pin internally by software*/
   \                     ??CrossCallReturnLabel_10:
   \   00000E 72105201              BSET      L:0x5201, #0x0
   \   000012 87                    RETF
    188              }
    189              else
    190              {
    191                  SPI->CR2 &= (uint8_t)(~SPI_CR2_SSI); /* Reset NSS pin internally by software*/
   \                     ??SPI_NSSInternalSoftwareCmd_0:
   \   000013 72115201              BRES      L:0x5201, #0x0
    192              }
    193          }
   \   000017 87                    RETF
    194          
    195          /**
    196            * @brief  Enables the transmit of the CRC value.
    197            * @param  None
    198            * @retval None
    199            */

   \                                 In section .far_func.text, align 1
    200          void SPI_TransmitCRC(void)
    201          {
    202              SPI->CR2 |= SPI_CR2_CRCNEXT; /* Enable the CRC transmission*/
   \                     SPI_TransmitCRC:
   \   000000 72185201              BSET      L:0x5201, #0x4
    203          }
   \   000004 87                    RETF
    204          
    205          /**
    206            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    207            * @param  NewState Indicates the new state of the SPI CRC value calculation.
    208            *         This parameter can be: ENABLE or DISABLE.
    209            * @retval None
    210            */

   \                                 In section .far_func.text, align 1, keep-with-next
    211          void SPI_CalculateCRCCmd(FunctionalState NewState)
    212          {
    213              /* Check function parameters */
    214              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     SPI_CalculateCRCCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??SPI_CalculateCRCCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_12
   \   000007 AE00D6                LDW       X, #0xd6
   \   00000A 8D000000              CALLF     ?Subroutine0
    215          
    216              if (NewState != DISABLE)
    217              {
    218                  SPI->CR2 |= SPI_CR2_CRCEN; /* Enable the CRC calculation*/
   \                     ??CrossCallReturnLabel_12:
   \   00000E 721A5201              BSET      L:0x5201, #0x5
   \   000012 87                    RETF
    219              }
    220              else
    221              {
    222                  SPI->CR2 &= (uint8_t)(~SPI_CR2_CRCEN); /* Disable the CRC calculation*/
   \                     ??SPI_CalculateCRCCmd_0:
   \   000013 721B5201              BRES      L:0x5201, #0x5
    223              }
    224          }
   \   000017 87                    RETF
    225          
    226          /**
    227            * @brief  Returns the transmit or the receive CRC register value.
    228            * @param  SPI_CRC Specifies the CRC register to be read.
    229            * @retval The selected CRC register value.
    230            */

   \                                 In section .far_func.text, align 1
    231          uint8_t SPI_GetCRC(SPI_CRC_TypeDef SPI_CRC)
    232          {
    233              uint8_t crcreg = 0;
    234          
    235              /* Check function parameters */
    236              assert_param(IS_SPI_CRC_OK(SPI_CRC));
   \                     SPI_GetCRC:
   \   000000 A101                  CP        A, #0x1
   \   000002 270A                  JREQ      L:??CrossCallReturnLabel_11
   \   000004 4D                    TNZ       A
   \   000005 270B                  JREQ      L:??SPI_GetCRC_0
   \   000007 AE00EC                LDW       X, #0xec
   \   00000A 8D000000              CALLF     ?Subroutine0
    237          
    238              if (SPI_CRC != SPI_CRC_RX)
    239              {
    240                  crcreg = SPI->TXCRCR;  /* Get the Tx CRC register*/
   \                     ??CrossCallReturnLabel_11:
   \   00000E C65207                LD        A, L:0x5207
   \   000011 87                    RETF
    241              }
    242              else
    243              {
    244                  crcreg = SPI->RXCRCR; /* Get the Rx CRC register*/
   \                     ??SPI_GetCRC_0:
   \   000012 C65206                LD        A, L:0x5206
    245              }
    246          
    247              /* Return the selected CRC register status*/
    248              return crcreg;
   \   000015 87                    RETF
    249          }
    250          
    251          /**
    252            * @brief  Reset the Rx CRCR and Tx CRCR registers.
    253            * @param  None
    254            * @retval None
    255            */

   \                                 In section .far_func.text, align 1
    256          void SPI_ResetCRC(void)
    257          {
    258              /* Rx CRCR & Tx CRCR registers are reset when CRCEN (hardware calculation)
    259                 bit in SPI_CR2 is written to 1 (enable) */
    260              SPI_CalculateCRCCmd(ENABLE);
   \                     SPI_ResetCRC:
   \   000000 A601                  LD        A, #0x1
   \   000002 8D000000              CALLF     SPI_CalculateCRCCmd
    261          
    262              /* Previous function disable the SPI */
    263              SPI_Cmd(ENABLE);
   \   000006 A601                  LD        A, #0x1
   \   000008 AC000000              JPF       SPI_Cmd
    264          }
    265          
    266          /**
    267            * @brief  Returns the CRC Polynomial register value.
    268            * @param  None
    269            * @retval The CRC Polynomial register value.
    270            */

   \                                 In section .far_func.text, align 1
    271          uint8_t SPI_GetCRCPolynomial(void)
    272          {
    273              return SPI->CRCPR; /* Return the CRC polynomial register */
   \                     SPI_GetCRCPolynomial:
   \   000000 C65205                LD        A, L:0x5205
   \   000003 87                    RETF
    274          }
    275          
    276          /**
    277            * @brief  Selects the data transfer direction in bi-directional mode.
    278            * @param  SPI_Direction Specifies the data transfer direction in bi-directional mode.
    279            * @retval None
    280            */

   \                                 In section .far_func.text, align 1
    281          void SPI_BiDirectionalLineConfig(SPI_Direction_TypeDef SPI_Direction)
    282          {
    283              /* Check function parameters */
    284              assert_param(IS_SPI_DIRECTION_OK(SPI_Direction));
   \                     SPI_BiDirectionalLineConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??SPI_BiDirectionalLineConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_14
   \   000007 AE011C                LDW       X, #0x11c
   \   00000A 8D000000              CALLF     ?Subroutine0
    285          
    286              if (SPI_Direction != SPI_DIRECTION_RX)
    287              {
    288                  SPI->CR2 |= SPI_CR2_BDOE; /* Set the Tx only mode*/
   \                     ??CrossCallReturnLabel_14:
   \   00000E 721C5201              BSET      L:0x5201, #0x6
   \   000012 87                    RETF
    289              }
    290              else
    291              {
    292                  SPI->CR2 &= (uint8_t)(~SPI_CR2_BDOE); /* Set the Rx only mode*/
   \                     ??SPI_BiDirectionalLineConfig_0:
   \   000013 721D5201              BRES      L:0x5201, #0x6
    293              }
    294          }
   \   000017 87                    RETF
    295          
    296          /**
    297            * @brief  Checks whether the specified SPI flag is set or not.
    298            * @param  SPI_FLAG : Specifies the flag to check.
    299            *         This parameter can be any of the @ref SPI_FLAG_TypeDef enumeration.
    300            * @retval FlagStatus : Indicates the state of SPI_FLAG.
    301            *         This parameter can be any of the @ref FlagStatus enumeration.
    302            */
    303          

   \                                 In section .far_func.text, align 1
    304          FlagStatus SPI_GetFlagStatus(SPI_Flag_TypeDef SPI_FLAG)
    305          {
   \                     SPI_GetFlagStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    306              FlagStatus status = RESET;
    307              /* Check parameters */
    308              assert_param(IS_SPI_FLAGS_OK(SPI_FLAG));
   \   000005 A140                  CP        A, #0x40
   \   000007 271F                  JREQ      L:??CrossCallReturnLabel_15
   \   000009 A120                  CP        A, #0x20
   \   00000B 271B                  JREQ      L:??CrossCallReturnLabel_15
   \   00000D A110                  CP        A, #0x10
   \   00000F 2717                  JREQ      L:??CrossCallReturnLabel_15
   \   000011 A108                  CP        A, #0x8
   \   000013 2713                  JREQ      L:??CrossCallReturnLabel_15
   \   000015 A102                  CP        A, #0x2
   \   000017 270F                  JREQ      L:??CrossCallReturnLabel_15
   \   000019 A101                  CP        A, #0x1
   \   00001B 270B                  JREQ      L:??CrossCallReturnLabel_15
   \   00001D A180                  CP        A, #0x80
   \   00001F 2707                  JREQ      L:??CrossCallReturnLabel_15
   \   000021 AE0134                LDW       X, #0x134
   \   000024 8D000000              CALLF     ?Subroutine0
    309          
    310              /* Check the status of the specified SPI flag */
    311              if ((SPI->SR & (uint8_t)SPI_FLAG) != (uint8_t)RESET)
   \                     ??CrossCallReturnLabel_15:
   \   000028 B600                  LD        A, S:?b8
   \   00002A C55203                BCP       A, L:0x5203
   \   00002D 2704                  JREQ      L:??SPI_GetFlagStatus_0
    312              {
    313                  status = SET; /* SPI_FLAG is set */
   \   00002F A601                  LD        A, #0x1
   \   000031 2001                  JRA       L:??SPI_GetFlagStatus_1
    314              }
    315              else
    316              {
    317                  status = RESET; /* SPI_FLAG is reset*/
   \                     ??SPI_GetFlagStatus_0:
   \   000033 4F                    CLR       A
    318              }
    319          
    320              /* Return the SPI_FLAG status */
    321              return status;
   \                     ??SPI_GetFlagStatus_1:
   \   000034 320000                POP       S:?b8
   \   000037 87                    RETF
    322          }
    323          
    324          /**
    325            * @brief  Clears the SPI flags.
    326            * @param  SPI_FLAG : Specifies the flag to clear.
    327            *         This parameter can be one of the following values:
    328            *         - SPI_FLAG_CRCERR
    329            *         - SPI_FLAG_WKUP
    330            * @note   - OVR (OverRun Error) interrupt pending bit is cleared by software
    331            *         sequence:
    332            *         a read operation to SPI_DR register (SPI_ReceiveData()) followed by
    333            *         a read operation to SPI_SR register (SPI_GetFlagStatus()).
    334            *         - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    335            *         a read/write operation to SPI_SR register (SPI_GetFlagStatus()) followed by
    336            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    337            * @retval None
    338            */

   \                                 In section .far_func.text, align 1
    339          void SPI_ClearFlag(SPI_Flag_TypeDef SPI_FLAG)
    340          {
   \                     SPI_ClearFlag:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    341              assert_param(IS_SPI_CLEAR_FLAGS_OK(SPI_FLAG));
   \   000005 A110                  CP        A, #0x10
   \   000007 270B                  JREQ      L:??CrossCallReturnLabel_16
   \   000009 A108                  CP        A, #0x8
   \   00000B 2707                  JREQ      L:??CrossCallReturnLabel_16
   \   00000D AE0155                LDW       X, #0x155
   \   000010 8D000000              CALLF     ?Subroutine0
    342              /* Clear the flag bit */
    343              SPI->SR = (uint8_t)(~SPI_FLAG);
   \                     ??CrossCallReturnLabel_16:
   \   000014 3300                  CPL       S:?b8
   \   000016 B600                  LD        A, S:?b8
   \   000018 C75203                LD        L:0x5203, A
    344          }
   \   00001B 320000                POP       S:?b8
   \   00001E 87                    RETF
    345          
    346          /**
    347            * @brief  Checks whether the specified interrupt has occurred or not.
    348            * @param  SPI_IT: Specifies the SPI interrupt pending bit to check.
    349            *         This parameter can be one of the following values:
    350            *         - SPI_IT_CRCERR
    351            *         - SPI_IT_WKUP
    352            *         - SPI_IT_OVR
    353            *         - SPI_IT_MODF
    354            *         - SPI_IT_RXNE
    355            *         - SPI_IT_TXE
    356            * @retval ITStatus : Indicates the state of the SPI_IT.
    357            *         This parameter can be any of the @ref ITStatus enumeration.
    358            */

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000 B600                  LD        A, S:?b8
   \   000002 4E                    SWAP      A
   \   000003                       REQUIRE ??Subroutine2_0
   \   000003                       ;               // Fall through to label ??Subroutine2_0

   \                                 In section .far_func.text, align 1
    359          ITStatus SPI_GetITStatus(SPI_IT_TypeDef SPI_IT)
    360          {
   \                     SPI_GetITStatus:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    361              ITStatus pendingbitstatus = RESET;
    362              uint8_t itpos = 0;
    363              uint8_t itmask1 = 0;
    364              uint8_t itmask2 = 0;
    365              uint8_t enablestatus = 0;
    366              assert_param(IS_SPI_GET_IT_OK(SPI_IT));
   \   000005 A165                  CP        A, #0x65
   \   000007 271B                  JREQ      L:??CrossCallReturnLabel_17
   \   000009 A155                  CP        A, #0x55
   \   00000B 2717                  JREQ      L:??CrossCallReturnLabel_17
   \   00000D A145                  CP        A, #0x45
   \   00000F 2713                  JREQ      L:??CrossCallReturnLabel_17
   \   000011 A134                  CP        A, #0x34
   \   000013 270F                  JREQ      L:??CrossCallReturnLabel_17
   \   000015 A117                  CP        A, #0x17
   \   000017 270B                  JREQ      L:??CrossCallReturnLabel_17
   \   000019 A106                  CP        A, #0x6
   \   00001B 2707                  JREQ      L:??CrossCallReturnLabel_17
   \   00001D AE016E                LDW       X, #0x16e
   \   000020 8D000000              CALLF     ?Subroutine0
    367              /* Get the SPI IT index */
    368              itpos = (uint8_t)((uint8_t)1 << ((uint8_t)SPI_IT & (uint8_t)0x0F));
    369          
    370              /* Get the SPI IT mask */
    371              itmask1 = (uint8_t)((uint8_t)SPI_IT >> (uint8_t)4);
    372              /* Set the IT mask */
    373              itmask2 = (uint8_t)((uint8_t)1 << itmask1);
    374              /* Get the SPI_ITPENDINGBIT enable bit status */
    375              enablestatus = (uint8_t)((uint8_t)SPI->SR & itmask2);
   \                     ??CrossCallReturnLabel_17:
   \   000024 8D000000              CALLF     ?Subroutine1
   \                     ??CrossCallReturnLabel_22:
   \   000028 C45203                AND       A, L:0x5203
   \   00002B B700                  LD        S:?b0, A
    376              /* Check the status of the specified SPI interrupt */
    377              if (((SPI->ICR & itpos) != RESET) && enablestatus)
   \   00002D B600                  LD        A, S:?b8
   \   00002F 8D000000              CALLF     ??Subroutine2_0
   \                     ??CrossCallReturnLabel_19:
   \   000033 C55202                BCP       A, L:0x5202
   \   000036 2708                  JREQ      L:??SPI_GetITStatus_0
   \   000038 3D00                  TNZ       S:?b0
   \   00003A 2704                  JREQ      L:??SPI_GetITStatus_0
    378              {
    379                  /* SPI_ITPENDINGBIT is set */
    380                  pendingbitstatus = SET;
   \   00003C A601                  LD        A, #0x1
   \   00003E 2001                  JRA       L:??SPI_GetITStatus_1
    381              }
    382              else
    383              {
    384                  /* SPI_ITPENDINGBIT is reset */
    385                  pendingbitstatus = RESET;
   \                     ??SPI_GetITStatus_0:
   \   000040 4F                    CLR       A
    386              }
    387              /* Return the SPI_ITPENDINGBIT status */
    388              return  pendingbitstatus;
   \                     ??SPI_GetITStatus_1:
   \   000041 320000                POP       S:?b8
   \   000044 87                    RETF
    389          }
    390          /**
    391            * @brief  Clears the interrupt pending bits.
    392            * @param  SPI_IT: Specifies the interrupt pending bit to clear.
    393            *         This parameter can be one of the following values:
    394            *         - SPI_IT_CRCERR
    395            *         - SPI_IT_WKUP
    396            * @note   - OVR (OverRun Error) interrupt pending bit is cleared by software sequence:
    397            *         a read operation to SPI_DR register (SPI_ReceiveData()) followed by
    398            *         a read operation to SPI_SR register (SPI_GetITStatus()).
    399            *         - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    400            *         a read/write operation to SPI_SR register (SPI_GetITStatus()) followed by
    401            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    402            * @retval None
    403            */

   \                                 In section .far_func.text, align 1
    404          void SPI_ClearITPendingBit(SPI_IT_TypeDef SPI_IT)
    405          {
   \                     SPI_ClearITPendingBit:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    406              uint8_t itpos = 0;
    407              assert_param(IS_SPI_CLEAR_IT_OK(SPI_IT));
   \   000005 A145                  CP        A, #0x45
   \   000007 270B                  JREQ      L:??CrossCallReturnLabel_18
   \   000009 A134                  CP        A, #0x34
   \   00000B 2707                  JREQ      L:??CrossCallReturnLabel_18
   \   00000D AE0197                LDW       X, #0x197
   \   000010 8D000000              CALLF     ?Subroutine0
    408          
    409              /* Clear  SPI_IT_CRCERR or SPI_IT_WKUP interrupt pending bits */
    410          
    411              /* Get the SPI pending bit index */
    412              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)(SPI_IT & (uint8_t)0xF0) >> 4));
    413              /* Clear the pending bit */
    414              SPI->SR = (uint8_t)(~itpos);
   \                     ??CrossCallReturnLabel_18:
   \   000014 8D000000              CALLF     ?Subroutine1
   \                     ??CrossCallReturnLabel_21:
   \   000018 43                    CPL       A
   \   000019 C75203                LD        L:0x5203, A
    415          
    416          }
   \   00001C 320000                POP       S:?b8
   \   00001F 87                    RETF

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\Documents and Sett...">`:
   \   000000 433A5C446F63          DC8 43H, 3AH, 5CH, 44H, 6FH, 63H, 75H, 6DH
   \   000008 656E74732061          DC8 65H, 6EH, 74H, 73H, 20H, 61H, 6EH, 64H
   \   000010 205365747469          DC8 20H, 53H, 65H, 74H, 74H, 69H, 6EH, 67H
   \   000018 735C41646D69          DC8 73H, 5CH, 41H, 64H, 6DH, 69H, 6EH, 69H
   \   000020 73747261746F          DC8 73H, 74H, 72H, 61H, 74H, 6FH, 72H, 5CH
   \   000028 4465736B746F          DC8 44H, 65H, 73H, 6BH, 74H, 6FH, 70H, 5CH
   \   000030 566F6C743253          DC8 56H, 6FH, 6CH, 74H, 32H, 53H, 65H, 72H
   \   000038 69616C5C4C69          DC8 69H, 61H, 6CH, 5CH, 4CH, 69H, 62H, 72H
   \   000040 61726965735C          DC8 61H, 72H, 69H, 65H, 73H, 5CH, 53H, 54H
   \   000048 4D38535F5374          DC8 4DH, 38H, 53H, 5FH, 53H, 74H, 64H, 50H
   \   000050 65726970685F          DC8 65H, 72H, 69H, 70H, 68H, 5FH, 44H, 72H
   \   000058 697665725C73          DC8 69H, 76H, 65H, 72H, 5CH, 73H, 72H, 63H
   \   000060 5C73746D3873          DC8 5CH, 73H, 74H, 6DH, 38H, 73H, 5FH, 73H
   \   000068 70692E6300            DC8 70H, 69H, 2EH, 63H, 0
    417          /**
    418            * @}
    419            */
    420            
    421          /**
    422            * @}
    423            */
    424            
    425          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                          Bytes
     --------------                          -----
     SPI_DeInit                                21
     ?Subroutine0                              12
     SPI_Init                                 238
     SPI_Cmd                                   24
     SPI_ITConfig                              75
     ??Subroutine2_0                           10
     SPI_SendData                               4
     SPI_ReceiveData                            4
     SPI_NSSInternalSoftwareCmd                24
     SPI_TransmitCRC                            5
     SPI_CalculateCRCCmd                       24
     SPI_GetCRC                                22
     SPI_ResetCRC                              12
     SPI_GetCRCPolynomial                       4
     SPI_BiDirectionalLineConfig               24
     SPI_GetFlagStatus                         56
     SPI_ClearFlag                             31
     ?Subroutine1                               3
     SPI_GetITStatus                           69
     SPI_ClearITPendingBit                     32
     ?<Constant "C:\\Documents and Sett...">  109

 
 694 bytes in section .far_func.text
 109 bytes in section .near.rodata
 
 694 bytes of CODE  memory
 109 bytes of CONST memory

Errors: none
Warnings: none
