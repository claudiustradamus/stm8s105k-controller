###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             11/Sep/2013  20:03:29 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s_ #
#                    uart2.c                                                  #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s #
#                    _uart2.c" -e -Ohz --debug --code_model medium            #
#                    --data_model medium -o "C:\Documents and                 #
#                    Settings\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Obj\"       #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\stm8\LIB\dlstm8mmf.h" -D STM8S105 -lC      #
#                    "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\ST #
#                    M8S105\List\" -lA "C:\Documents and                      #
#                    Settings\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\List\" -I   #
#                    "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\.. #
#                    \" -I "C:\Documents and Settings\Administrator\Desktop\s #
#                    tm8s105k-controller\Project\STM8S_StdPeriph_Template\EWS #
#                    TM8\..\..\..\Libraries\STM8S_StdPeriph_Driver\inc\"      #
#                    --vregs 16                                               #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\STM #
#                    8S105\List\stm8s_uart2.lst                               #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\STM #
#                    8S105\Obj\stm8s_uart2.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\stm8s105k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s_uart2.c
      1          /**
      2            ********************************************************************************
      3            * @file    stm8s_uart2.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the UART2 peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_uart2.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          /* Public functions ----------------------------------------------------------*/
     35          
     36          /** @}
     37            * @addtogroup UART2_Public_Functions
     38            * @{
     39            */
     40          
     41          /**
     42            * @brief  Deinitializes the UART peripheral.
     43            * @param  None
     44            * @retval None
     45            */
     46          

   \                                 In section .far_func.text, align 1
     47          void UART2_DeInit(void)
     48          {
     49              /*  Clear the Idle Line Detected bit in the status register by a read
     50                 to the UART2_SR register followed by a Read to the UART2_DR register */
     51              (void) UART2->SR;
   \                     UART2_DeInit:
   \   000000 C65240                LD        A, L:0x5240
     52              (void)UART2->DR;
   \   000003 C65241                LD        A, L:0x5241
     53          
     54              UART2->BRR2 = UART2_BRR2_RESET_VALUE;  /*  Set UART2_BRR2 to reset value 0x00 */
   \   000006 725F5243              CLR       L:0x5243
     55              UART2->BRR1 = UART2_BRR1_RESET_VALUE;  /*  Set UART2_BRR1 to reset value 0x00 */
   \   00000A 725F5242              CLR       L:0x5242
     56          
     57              UART2->CR1 = UART2_CR1_RESET_VALUE; /*  Set UART2_CR1 to reset value 0x00  */
   \   00000E 725F5244              CLR       L:0x5244
     58              UART2->CR2 = UART2_CR2_RESET_VALUE; /*  Set UART2_CR2 to reset value 0x00  */
   \   000012 725F5245              CLR       L:0x5245
     59              UART2->CR3 = UART2_CR3_RESET_VALUE; /*  Set UART2_CR3 to reset value 0x00  */
   \   000016 725F5246              CLR       L:0x5246
     60              UART2->CR4 = UART2_CR4_RESET_VALUE; /*  Set UART2_CR4 to reset value 0x00  */
   \   00001A 725F5247              CLR       L:0x5247
     61              UART2->CR5 = UART2_CR5_RESET_VALUE; /*  Set UART2_CR5 to reset value 0x00  */
   \   00001E 725F5248              CLR       L:0x5248
     62              UART2->CR6 = UART2_CR6_RESET_VALUE; /*  Set UART2_CR6 to reset value 0x00  */
   \   000022 725F5249              CLR       L:0x5249
     63          
     64          }
   \   000026 87                    RETF
     65          
     66          /**
     67            * @brief  Initializes the UART2 according to the specified parameters.
     68            * @param  BaudRate: The baudrate.
     69            * @param  WordLength : This parameter can be any of the 
     70            *         @ref UART2_WordLength_TypeDef enumeration.
     71            * @param  StopBits: This parameter can be any of the 
     72            *         @ref UART2_StopBits_TypeDef enumeration.
     73            * @param  Parity: This parameter can be any of the 
     74            *         @ref UART2_Parity_TypeDef enumeration.
     75            * @param  SyncMode: This parameter can be any of the 
     76            *         @ref UART2_SyncMode_TypeDef values.
     77            * @param  Mode: This parameter can be any of the @ref UART2_Mode_TypeDef values
     78            * @retval None
     79            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine2:
   \   000000 CA5244                OR        A, L:0x5244
   \   000003 C75244                LD        L:0x5244, A
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine0:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 AE0000                LDW       X, #`?<Constant "C:\\\\Documents and Sett...">`
   \   000008 AC000000              JPF       assert_failed

   \                                 In section .far_func.text, align 1
     80          void UART2_Init(uint32_t BaudRate, UART2_WordLength_TypeDef WordLength, UART2_StopBits_TypeDef StopBits, UART2_Parity_TypeDef Parity, UART2_SyncMode_TypeDef SyncMode, UART2_Mode_TypeDef Mode)
     81          {
   \                     UART2_Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 3B0000                PUSH      S:?b6
   \   00000B 3B0000                PUSH      S:?b7
   \   00000E 8D000000              CALLF     L:?mov_l2_l0
   \   000012 B700                  LD        S:?b14, A
   \   000014 450000                MOV       S:?b12, S:?b4
   \   000017 450000                MOV       S:?b13, S:?b5
     82              uint8_t BRR2_1 = 0, BRR2_2 = 0;
     83              uint32_t BaudRate_Mantissa = 0, BaudRate_Mantissa100 = 0;
     84          
     85              /* Check the parameters */
     86              assert_param(IS_UART2_BAUDRATE_OK(BaudRate));
   \   00001A BE00                  LDW       X, S:?w4
   \   00001C A30009                CPW       X, #0x9
   \   00001F 2605                  JRNE      L:??UART2_Init_0
   \   000021 BE00                  LDW       X, S:?w5
   \   000023 A38969                CPW       X, #0x8969
   \                     ??UART2_Init_0:
   \   000026 2507                  JRC       L:??CrossCallReturnLabel_5
   \   000028 AE0056                LDW       X, #0x56
   \   00002B 8D000000              CALLF     ?Subroutine0
     87              assert_param(IS_UART2_WORDLENGTH_OK(WordLength));
   \                     ??CrossCallReturnLabel_5:
   \   00002F 3D00                  TNZ       S:?b14
   \   000031 270D                  JREQ      L:??CrossCallReturnLabel_4
   \   000033 B600                  LD        A, S:?b14
   \   000035 A110                  CP        A, #0x10
   \   000037 2707                  JREQ      L:??CrossCallReturnLabel_4
   \   000039 AE0057                LDW       X, #0x57
   \   00003C 8D000000              CALLF     ?Subroutine0
     88              assert_param(IS_UART2_STOPBITS_OK(StopBits));
   \                     ??CrossCallReturnLabel_4:
   \   000040 3D00                  TNZ       S:?b12
   \   000042 2715                  JREQ      L:??CrossCallReturnLabel_3
   \   000044 B600                  LD        A, S:?b12
   \   000046 A110                  CP        A, #0x10
   \   000048 270F                  JREQ      L:??CrossCallReturnLabel_3
   \   00004A A120                  CP        A, #0x20
   \   00004C 270B                  JREQ      L:??CrossCallReturnLabel_3
   \   00004E A130                  CP        A, #0x30
   \   000050 2707                  JREQ      L:??CrossCallReturnLabel_3
   \   000052 AE0058                LDW       X, #0x58
   \   000055 8D000000              CALLF     ?Subroutine0
     89              assert_param(IS_UART2_PARITY_OK(Parity));
   \                     ??CrossCallReturnLabel_3:
   \   000059 3D00                  TNZ       S:?b13
   \   00005B 2711                  JREQ      L:??CrossCallReturnLabel_2
   \   00005D B600                  LD        A, S:?b13
   \   00005F A104                  CP        A, #0x4
   \   000061 270B                  JREQ      L:??CrossCallReturnLabel_2
   \   000063 A106                  CP        A, #0x6
   \   000065 2707                  JREQ      L:??CrossCallReturnLabel_2
   \   000067 AE0059                LDW       X, #0x59
   \   00006A 8D000000              CALLF     ?Subroutine0
     90              assert_param(IS_UART2_MODE_OK((uint8_t)Mode));
   \                     ??CrossCallReturnLabel_2:
   \   00006E 7B01                  LD        A, (0x1,SP)
   \   000070 A108                  CP        A, #0x8
   \   000072 2723                  JREQ      L:??CrossCallReturnLabel_1
   \   000074 A140                  CP        A, #0x40
   \   000076 271F                  JREQ      L:??CrossCallReturnLabel_1
   \   000078 A104                  CP        A, #0x4
   \   00007A 271B                  JREQ      L:??CrossCallReturnLabel_1
   \   00007C A180                  CP        A, #0x80
   \   00007E 2717                  JREQ      L:??CrossCallReturnLabel_1
   \   000080 A10C                  CP        A, #0xc
   \   000082 2713                  JREQ      L:??CrossCallReturnLabel_1
   \   000084 A144                  CP        A, #0x44
   \   000086 270F                  JREQ      L:??CrossCallReturnLabel_1
   \   000088 A1C0                  CP        A, #0xc0
   \   00008A 270B                  JREQ      L:??CrossCallReturnLabel_1
   \   00008C A188                  CP        A, #0x88
   \   00008E 2707                  JREQ      L:??CrossCallReturnLabel_1
   \   000090 AE005A                LDW       X, #0x5a
   \   000093 8D000000              CALLF     ?Subroutine0
     91              assert_param(IS_UART2_SYNCMODE_OK((uint8_t)SyncMode));
   \                     ??CrossCallReturnLabel_1:
   \   000097 7B02                  LD        A, (0x2,SP)
   \   000099 A488                  AND       A, #0x88
   \   00009B A188                  CP        A, #0x88
   \   00009D 2718                  JREQ      L:??UART2_Init_1
   \   00009F 7B02                  LD        A, (0x2,SP)
   \   0000A1 A444                  AND       A, #0x44
   \   0000A3 A144                  CP        A, #0x44
   \   0000A5 2710                  JREQ      L:??UART2_Init_1
   \   0000A7 7B02                  LD        A, (0x2,SP)
   \   0000A9 A422                  AND       A, #0x22
   \   0000AB A122                  CP        A, #0x22
   \   0000AD 2708                  JREQ      L:??UART2_Init_1
   \   0000AF 7B02                  LD        A, (0x2,SP)
   \   0000B1 A411                  AND       A, #0x11
   \   0000B3 A111                  CP        A, #0x11
   \   0000B5 2607                  JRNE      L:??CrossCallReturnLabel_0
   \                     ??UART2_Init_1:
   \   0000B7 AE005B                LDW       X, #0x5b
   \   0000BA 8D000000              CALLF     ?Subroutine0
     92          
     93               /* Clear the word length bit */
     94              UART2->CR1 &= (uint8_t)(~UART2_CR1_M);
   \                     ??CrossCallReturnLabel_0:
   \   0000BE 72195244              BRES      L:0x5244, #0x4
     95              /* Set the word length bit according to UART2_WordLength value */
     96              UART2->CR1 |= (uint8_t)WordLength; 
   \   0000C2 B600                  LD        A, S:?b14
   \   0000C4 8D000000              CALLF     ?Subroutine2
     97          
     98              /* Clear the STOP bits */
     99              UART2->CR3 &= (uint8_t)(~UART2_CR3_STOP);
   \                     ??CrossCallReturnLabel_28:
   \   0000C8 C65246                LD        A, L:0x5246
   \   0000CB A4CF                  AND       A, #0xcf
   \   0000CD C75246                LD        L:0x5246, A
    100              /* Set the STOP bits number according to UART2_StopBits value  */
    101              UART2->CR3 |= (uint8_t)StopBits; 
   \   0000D0 B600                  LD        A, S:?b12
   \   0000D2 CA5246                OR        A, L:0x5246
   \   0000D5 C75246                LD        L:0x5246, A
    102          
    103              /* Clear the Parity Control bit */
    104              UART2->CR1 &= (uint8_t)(~(UART2_CR1_PCEN | UART2_CR1_PS  ));
   \   0000D8 C65244                LD        A, L:0x5244
   \   0000DB A4F9                  AND       A, #0xf9
   \   0000DD C75244                LD        L:0x5244, A
    105              /* Set the Parity Control bit to UART2_Parity value */
    106              UART2->CR1 |= (uint8_t)Parity;
   \   0000E0 B600                  LD        A, S:?b13
   \   0000E2 8D000000              CALLF     ?Subroutine2
    107          
    108              /* Clear the LSB mantissa of UART2DIV  */
    109              UART2->BRR1 &= (uint8_t)(~UART2_BRR1_DIVM);
   \                     ??CrossCallReturnLabel_29:
   \   0000E6 C65242                LD        A, L:0x5242
   \   0000E9 725F5242              CLR       L:0x5242
    110              /* Clear the MSB mantissa of UART2DIV  */
    111              UART2->BRR2 &= (uint8_t)(~UART2_BRR2_DIVM);
   \   0000ED C65243                LD        A, L:0x5243
   \   0000F0 A40F                  AND       A, #0xf
   \   0000F2 C75243                LD        L:0x5243, A
    112              /* Clear the Fraction bits of UART2DIV */
    113              UART2->BRR2 &= (uint8_t)(~UART2_BRR2_DIVF);
   \   0000F5 C65243                LD        A, L:0x5243
   \   0000F8 A4F0                  AND       A, #0xf0
   \   0000FA C75243                LD        L:0x5243, A
    114          
    115              /* Set the UART2 BaudRates in BRR1 and BRR2 registers according to UART2_BaudRate value */
    116              BaudRate_Mantissa    = ((uint32_t)CLK_GetClockFreq() / (BaudRate << 4));
   \   0000FD 8D000000              CALLF     L:?mov_l0_l2
   \   000101 A604                  LD        A, #0x4
   \   000103 8D000000              CALLF     L:?sll32_l0_l0_a
   \   000107 8D000000              CALLF     L:?mov_l2_l0
   \   00010B 8D000000              CALLF     CLK_GetClockFreq
   \   00010F 8D000000              CALLF     L:?mov_l1_l2
   \   000113 8D000000              CALLF     L:?udiv32_l0_l0_l1
   \   000117 8D000000              CALLF     L:?mov_l3_l0
    117              BaudRate_Mantissa100 = (((uint32_t)CLK_GetClockFreq() * 100) / (BaudRate << 4));
    118              
    119              /* The fraction and MSB mantissa should be loaded in one step in the BRR2 register*/
    120              /* Set the fraction of UARTDIV  */
    121              BRR2_1 = (uint8_t)((uint8_t)(((BaudRate_Mantissa100 - (BaudRate_Mantissa * 100))
    122                                  << 4) / 100) & (uint8_t)0x0F); 
    123              BRR2_2 = (uint8_t)((BaudRate_Mantissa >> 4) & (uint8_t)0xF0);
    124          
    125              UART2->BRR2 = (uint8_t)(BRR2_1 | BRR2_2);
   \   00011B 8D000000              CALLF     ?Subroutine3
   \                     ??CrossCallReturnLabel_30:
   \   00011F 8D000000              CALLF     L:?push_l0
   \   000123 8D000000              CALLF     CLK_GetClockFreq
   \   000127 8D000000              CALLF     ?Subroutine3
   \                     ??CrossCallReturnLabel_31:
   \   00012B 8D000000              CALLF     L:?mov_l1_l2
   \   00012F 8D000000              CALLF     L:?udiv32_l0_l0_l1
   \   000133 8D000000              CALLF     L:?pop_l1
   \   000137 8D000000              CALLF     L:?sub32_l0_l0_l1
   \   00013B A604                  LD        A, #0x4
   \   00013D 8D000000              CALLF     L:?sll32_l0_l0_a
   \   000141 8D000000              CALLF     L:?udiv32_l0_l0_dl
   \   000145 00000064              DC32      0x64
   \   000149 B600                  LD        A, S:?b3
   \   00014B A40F                  AND       A, #0xf
   \   00014D 88                    PUSH      A
   \   00014E BE00                  LDW       X, S:?w7
   \   000150 54                    SRLW      X
   \   000151 54                    SRLW      X
   \   000152 54                    SRLW      X
   \   000153 54                    SRLW      X
   \   000154 9F                    LD        A, XL
   \   000155 A4F0                  AND       A, #0xf0
   \   000157 B700                  LD        S:?b1, A
   \   000159 84                    POP       A
   \   00015A BA00                  OR        A, S:?b1
   \   00015C C75243                LD        L:0x5243, A
    126              /* Set the LSB mantissa of UARTDIV  */
    127              UART2->BRR1 = (uint8_t)BaudRate_Mantissa;           
   \   00015F B600                  LD        A, S:?b15
   \   000161 C75242                LD        L:0x5242, A
    128          
    129              /* Disable the Transmitter and Receiver before seting the LBCL, CPOL and CPHA bits */
    130              UART2->CR2 &= (uint8_t)~(UART2_CR2_TEN | UART2_CR2_REN);
   \   000164 C65245                LD        A, L:0x5245
   \   000167 A4F3                  AND       A, #0xf3
   \   000169 C75245                LD        L:0x5245, A
    131              /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
    132              UART2->CR3 &= (uint8_t)~(UART2_CR3_CPOL | UART2_CR3_CPHA | UART2_CR3_LBCL);
   \   00016C C65246                LD        A, L:0x5246
   \   00016F A4F8                  AND       A, #0xf8
   \   000171 C75246                LD        L:0x5246, A
    133              /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
    134              UART2->CR3 |= (uint8_t)((uint8_t)SyncMode & (uint8_t)(UART2_CR3_CPOL | \
    135                                                        UART2_CR3_CPHA | UART2_CR3_LBCL));
   \   000174 7B02                  LD        A, (0x2,SP)
   \   000176 A407                  AND       A, #0x7
   \   000178 CA5246                OR        A, L:0x5246
   \   00017B C75246                LD        L:0x5246, A
    136          
    137              if ((uint8_t)(Mode & UART2_MODE_TX_ENABLE))
   \   00017E 7B01                  LD        A, (0x1,SP)
   \   000180 A504                  BCP       A, #0x4
   \   000182 2706                  JREQ      L:??UART2_Init_2
    138              {
    139                  /* Set the Transmitter Enable bit */
    140                  UART2->CR2 |= (uint8_t)UART2_CR2_TEN;
   \   000184 72165245              BSET      L:0x5245, #0x3
   \   000188 2004                  JRA       L:??UART2_Init_3
    141              }
    142              else
    143              {
    144                  /* Clear the Transmitter Disable bit */
    145                  UART2->CR2 &= (uint8_t)(~UART2_CR2_TEN);
   \                     ??UART2_Init_2:
   \   00018A 72175245              BRES      L:0x5245, #0x3
    146              }
    147              if ((uint8_t)(Mode & UART2_MODE_RX_ENABLE))
   \                     ??UART2_Init_3:
   \   00018E 7B01                  LD        A, (0x1,SP)
   \   000190 A508                  BCP       A, #0x8
   \   000192 2706                  JREQ      L:??UART2_Init_4
    148              {
    149                  /* Set the Receiver Enable bit */
    150                  UART2->CR2 |= (uint8_t)UART2_CR2_REN;
   \   000194 72145245              BSET      L:0x5245, #0x2
   \   000198 2004                  JRA       L:??UART2_Init_5
    151              }
    152              else
    153              {
    154                  /* Clear the Receiver Disable bit */
    155                  UART2->CR2 &= (uint8_t)(~UART2_CR2_REN);
   \                     ??UART2_Init_4:
   \   00019A 72155245              BRES      L:0x5245, #0x2
    156              }
    157              /* Set the Clock Enable bit, lock Polarity, lock Phase and Last Bit Clock 
    158                     pulse bits according to UART2_Mode value */
    159              if ((uint8_t)(SyncMode & UART2_SYNCMODE_CLOCK_DISABLE))
   \                     ??UART2_Init_5:
   \   00019E 7B02                  LD        A, (0x2,SP)
   \   0001A0 A580                  BCP       A, #0x80
   \   0001A2 2706                  JREQ      L:??UART2_Init_6
    160              {
    161                  /* Clear the Clock Enable bit */
    162                  UART2->CR3 &= (uint8_t)(~UART2_CR3_CKEN); 
   \   0001A4 72175246              BRES      L:0x5246, #0x3
   \   0001A8 200A                  JRA       L:??UART2_Init_7
    163              }
    164              else
    165              {
    166                  UART2->CR3 |= (uint8_t)((uint8_t)SyncMode & UART2_CR3_CKEN);
   \                     ??UART2_Init_6:
   \   0001AA 7B02                  LD        A, (0x2,SP)
   \   0001AC A408                  AND       A, #0x8
   \   0001AE CA5246                OR        A, L:0x5246
   \   0001B1 C75246                LD        L:0x5246, A
    167              }
    168          }
   \                     ??UART2_Init_7:
   \   0001B4 5B02                  ADD       SP, #0x2
   \   0001B6 AC000000              JPF       L:?epilogue_l2_l3

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine3:
   \   000000 AE0064                LDW       X, #0x64
   \   000003 BF00                  LDW       S:?w3, X
   \   000005 5F                    CLRW      X
   \   000006 BF00                  LDW       S:?w2, X
   \   000008 AC000000              JPF       L:?mul32_l0_l0_l1
    169          
    170          /**
    171            * @brief  Enable the UART2 peripheral.
    172            * @param  NewState : The new state of the UART Communication.
    173            *         This parameter can be any of the @ref FunctionalState enumeration.
    174            * @retval None
    175            */

   \                                 In section .far_func.text, align 1
    176          void UART2_Cmd(FunctionalState NewState)
    177          {
    178          
    179              if (NewState != DISABLE)
   \                     UART2_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??UART2_Cmd_0
    180              {
    181                  /* UART2 Enable */
    182                  UART2->CR1 &= (uint8_t)(~UART2_CR1_UARTD);
   \   000003 721B5244              BRES      L:0x5244, #0x5
   \   000007 87                    RETF
    183              }
    184              else
    185              {
    186                  /* UART2 Disable */
    187                  UART2->CR1 |= UART2_CR1_UARTD; 
   \                     ??UART2_Cmd_0:
   \   000008 721A5244              BSET      L:0x5244, #0x5
    188              }
    189          }
   \   00000C 87                    RETF
    190          
    191          /**
    192            * @brief  Enables or disables the specified UART2 interrupts.
    193            * @param  UART2_IT specifies the UART2 interrupt sources to be enabled or disabled.
    194            *         This parameter can be one of the following values:
    195            *         - UART2_IT_LBDF:  LIN Break detection interrupt
    196            *         - UART2_IT_LHDF:  LIN Break detection interrupt
    197            *         - UART2_IT_TXE:  Tansmit Data Register empty interrupt
    198            *         - UART2_IT_TC:   Transmission complete interrupt
    199            *         - UART2_IT_RXNE_OR: Receive Data register not empty/Over run error interrupt
    200            *         - UART2_IT_IDLE: Idle line detection interrupt
    201            *         - UART2_IT_PE:   Parity Error interrupt
    202            * @param  NewState new state of the specified UART2 interrupts.
    203            *         This parameter can be: ENABLE or DISABLE.
    204            * @retval None
    205            */

   \                                 In section .far_func.text, align 1
    206          void UART2_ITConfig(UART2_IT_TypeDef UART2_IT, FunctionalState NewState)
    207          {
   \                     UART2_ITConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 BF00                  LDW       S:?w4, X
   \   000009 B700                  LD        S:?b10, A
    208              uint8_t uartreg = 0, itpos = 0x00;
    209              
    210              /* Check the parameters */
    211              assert_param(IS_UART2_CONFIG_IT_OK(UART2_IT));
   \   00000B A30100                CPW       X, #0x100
   \   00000E 2725                  JREQ      L:??CrossCallReturnLabel_7
   \   000010 A30277                CPW       X, #0x277
   \   000013 2720                  JREQ      L:??CrossCallReturnLabel_7
   \   000015 A30266                CPW       X, #0x266
   \   000018 271B                  JREQ      L:??CrossCallReturnLabel_7
   \   00001A A30255                CPW       X, #0x255
   \   00001D 2716                  JREQ      L:??CrossCallReturnLabel_7
   \   00001F A30244                CPW       X, #0x244
   \   000022 2711                  JREQ      L:??CrossCallReturnLabel_7
   \   000024 A30412                CPW       X, #0x412
   \   000027 270C                  JREQ      L:??CrossCallReturnLabel_7
   \   000029 A30346                CPW       X, #0x346
   \   00002C 2707                  JREQ      L:??CrossCallReturnLabel_7
   \   00002E AE00D3                LDW       X, #0xd3
   \   000031 8D000000              CALLF     ?Subroutine0
    212              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_7:
   \   000035 3D00                  TNZ       S:?b10
   \   000037 270D                  JREQ      L:??CrossCallReturnLabel_6
   \   000039 B600                  LD        A, S:?b10
   \   00003B A101                  CP        A, #0x1
   \   00003D 2707                  JREQ      L:??CrossCallReturnLabel_6
   \   00003F AE00D4                LDW       X, #0xd4
   \   000042 8D000000              CALLF     ?Subroutine0
    213          
    214              /* Get the UART2 register index */
    215              uartreg = (uint8_t)((uint16_t)UART2_IT >> 0x08);
   \                     ??CrossCallReturnLabel_6:
   \   000046 BE00                  LDW       X, S:?w4
   \   000048 4F                    CLR       A
   \   000049 01                    RRWA      X, A
   \   00004A 41                    EXG       A, XL
   \   00004B B700                  LD        S:?b1, A
   \   00004D 41                    EXG       A, XL
    216          
    217              /* Get the UART2 IT index */
    218              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART2_IT & (uint8_t)0x0F));
   \   00004E 8D000000              CALLF     ?Subroutine1
    219          
    220              if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_25:
   \   000052 3D00                  TNZ       S:?b10
   \   000054 2733                  JREQ      L:??UART2_ITConfig_0
    221              {
    222                  /* Enable the Interrupt bits according to UART2_IT mask */
    223                  if (uartreg == 0x01)
   \   000056 B600                  LD        A, S:?b1
   \   000058 A101                  CP        A, #0x1
   \   00005A 260A                  JRNE      L:??UART2_ITConfig_1
    224                  {
    225                      UART2->CR1 |= itpos;
   \   00005C B600                  LD        A, S:?b0
   \   00005E CA5244                OR        A, L:0x5244
   \                     ??UART2_ITConfig_2:
   \   000061 C75244                LD        L:0x5244, A
   \   000064 2050                  JRA       L:??UART2_ITConfig_3
    226                  }
    227                  else if (uartreg == 0x02)
   \                     ??UART2_ITConfig_1:
   \   000066 A102                  CP        A, #0x2
   \   000068 260A                  JRNE      L:??UART2_ITConfig_4
    228                  {
    229                      UART2->CR2 |= itpos;
   \   00006A B600                  LD        A, S:?b0
   \   00006C CA5245                OR        A, L:0x5245
   \                     ??UART2_ITConfig_5:
   \   00006F C75245                LD        L:0x5245, A
   \   000072 2042                  JRA       L:??UART2_ITConfig_3
    230                  }
    231                  else if (uartreg == 0x03)
   \                     ??UART2_ITConfig_4:
   \   000074 A103                  CP        A, #0x3
   \   000076 260A                  JRNE      L:??UART2_ITConfig_6
    232                  {
    233                      UART2->CR4 |= itpos;
   \   000078 B600                  LD        A, S:?b0
   \   00007A CA5247                OR        A, L:0x5247
   \                     ??UART2_ITConfig_7:
   \   00007D C75247                LD        L:0x5247, A
   \   000080 2034                  JRA       L:??UART2_ITConfig_3
    234                  }
    235                  else
    236                  {
    237                      UART2->CR6 |= itpos;
   \                     ??UART2_ITConfig_6:
   \   000082 B600                  LD        A, S:?b0
   \   000084 CA5249                OR        A, L:0x5249
   \   000087 202A                  JRA       ??UART2_ITConfig_8
    238                  }
    239              }
    240              else
    241              {
    242                  /* Disable the interrupt bits according to UART2_IT mask */
    243                  if (uartreg == 0x01)
   \                     ??UART2_ITConfig_0:
   \   000089 3300                  CPL       S:?b0
   \   00008B B600                  LD        A, S:?b1
   \   00008D A101                  CP        A, #0x1
   \   00008F 2607                  JRNE      L:??UART2_ITConfig_9
    244                  {
    245                      UART2->CR1 &= (uint8_t)(~itpos);
   \   000091 B600                  LD        A, S:?b0
   \   000093 C45244                AND       A, L:0x5244
   \   000096 20C9                  JRA       ??UART2_ITConfig_2
    246                  }
    247                  else if (uartreg == 0x02)
   \                     ??UART2_ITConfig_9:
   \   000098 A102                  CP        A, #0x2
   \   00009A 2607                  JRNE      L:??UART2_ITConfig_10
    248                  {
    249                      UART2->CR2 &= (uint8_t)(~itpos);
   \   00009C B600                  LD        A, S:?b0
   \   00009E C45245                AND       A, L:0x5245
   \   0000A1 20CC                  JRA       ??UART2_ITConfig_5
    250                  }
    251                  else if (uartreg == 0x03)
   \                     ??UART2_ITConfig_10:
   \   0000A3 A103                  CP        A, #0x3
   \   0000A5 2607                  JRNE      L:??UART2_ITConfig_11
    252                  {
    253                      UART2->CR4 &= (uint8_t)(~itpos);
   \   0000A7 B600                  LD        A, S:?b0
   \   0000A9 C45247                AND       A, L:0x5247
   \   0000AC 20CF                  JRA       ??UART2_ITConfig_7
    254                  }
    255                  else
    256                  {
    257                      UART2->CR6 &= (uint8_t)(~itpos);
   \                     ??UART2_ITConfig_11:
   \   0000AE B600                  LD        A, S:?b0
   \   0000B0 C45249                AND       A, L:0x5249
   \                     ??UART2_ITConfig_8:
   \   0000B3 C75249                LD        L:0x5249, A
    258                  }
    259              }
    260          }
   \                     ??UART2_ITConfig_3:
   \   0000B6 320000                POP       S:?b10
   \   0000B9 AC000000              JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine1:
   \   000000 A40F                  AND       A, #0xf
   \   000002 5F                    CLRW      X
   \   000003 5C                    INCW      X
   \   000004 8D000000              CALLF     L:?sll16_x_x_a
   \   000008 41                    EXG       A, XL
   \   000009 B700                  LD        S:?b0, A
   \   00000B 87                    RETF
    261          /**
    262            * @brief  Configures the UART2’s IrDA interface.
    263            * @param  UART2_IrDAMode specifies the IrDA mode.
    264            *         This parameter can be any of the @ref UART2_IrDAMode_TypeDef values.
    265            * @retval None
    266            */

   \                                 In section .far_func.text, align 1
    267          void UART2_IrDAConfig(UART2_IrDAMode_TypeDef UART2_IrDAMode)
    268          {
    269              assert_param(IS_UART2_IRDAMODE_OK(UART2_IrDAMode));
   \                     UART2_IrDAConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 270A                  JREQ      L:??CrossCallReturnLabel_8
   \   000004 4D                    TNZ       A
   \   000005 270C                  JREQ      L:??UART2_IrDAConfig_0
   \   000007 AE010D                LDW       X, #0x10d
   \   00000A 8D000000              CALLF     ?Subroutine0
    270          
    271              if (UART2_IrDAMode != UART2_IRDAMODE_NORMAL)
    272              {
    273                  UART2->CR5 |= UART2_CR5_IRLP;
   \                     ??CrossCallReturnLabel_8:
   \   00000E 72145248              BSET      L:0x5248, #0x2
   \   000012 87                    RETF
    274              }
    275              else
    276              {
    277                  UART2->CR5 &= ((uint8_t)~UART2_CR5_IRLP);
   \                     ??UART2_IrDAConfig_0:
   \   000013 72155248              BRES      L:0x5248, #0x2
    278              }
    279          }
   \   000017 87                    RETF
    280          
    281          /**
    282            * @brief  Enables or disables the UART2’s IrDA interface.
    283            * @param  NewState new state of the IrDA mode.
    284            *         This parameter can be: ENABLE or DISABLE.
    285            * @retval None
    286            */

   \                                 In section .far_func.text, align 1
    287          void UART2_IrDACmd(FunctionalState NewState)
    288          {
    289              /* Check parameters */
    290              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_IrDACmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??UART2_IrDACmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_9
   \   000007 AE0122                LDW       X, #0x122
   \   00000A 8D000000              CALLF     ?Subroutine0
    291          
    292              if (NewState != DISABLE)
    293              {
    294                  /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    295                  UART2->CR5 |= UART2_CR5_IREN;
   \                     ??CrossCallReturnLabel_9:
   \   00000E 72125248              BSET      L:0x5248, #0x1
   \   000012 87                    RETF
    296              }
    297              else
    298              {
    299                  /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    300                  UART2->CR5 &= ((uint8_t)~UART2_CR5_IREN);
   \                     ??UART2_IrDACmd_0:
   \   000013 72135248              BRES      L:0x5248, #0x1
    301              }
    302          }
   \   000017 87                    RETF
    303          
    304          /**
    305            * @brief  Sets the UART2 LIN Break detection length.
    306            * @param  UART2_LINBreakDetectionLength specifies the LIN break detection length.
    307            *         This parameter can be any of the 
    308            *         @ref UART2_LINBreakDetectionLength_TypeDef values.
    309            * @retval None
    310            */

   \                                 In section .far_func.text, align 1
    311          void UART2_LINBreakDetectionConfig(UART2_LINBreakDetectionLength_TypeDef UART2_LINBreakDetectionLength)
    312          {
    313              /* Check parameters */    
    314              assert_param(IS_UART2_LINBREAKDETECTIONLENGTH_OK(UART2_LINBreakDetectionLength));
   \                     UART2_LINBreakDetectionConfig:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??UART2_LINBreakDetectionConfig_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_10
   \   000007 AE013A                LDW       X, #0x13a
   \   00000A 8D000000              CALLF     ?Subroutine0
    315          
    316              if (UART2_LINBreakDetectionLength != UART2_LINBREAKDETECTIONLENGTH_10BITS)
    317              {
    318                  UART2->CR4 |= UART2_CR4_LBDL;
   \                     ??CrossCallReturnLabel_10:
   \   00000E 721A5247              BSET      L:0x5247, #0x5
   \   000012 87                    RETF
    319              }
    320              else
    321              {
    322                  UART2->CR4 &= ((uint8_t)~UART2_CR4_LBDL);
   \                     ??UART2_LINBreakDetectionConfig_0:
   \   000013 721B5247              BRES      L:0x5247, #0x5
    323              }
    324          }
   \   000017 87                    RETF
    325          
    326          /**
    327            * @brief  Configure the UART2 peripheral.
    328            * @param  UART2_Mode specifies the LIN mode.
    329            *         This parameter can be any of the @ref UART2_LinMode_TypeDef values.
    330            * @param  UART2_Autosync specifies the LIN automatic resynchronization mode.
    331            *         This parameter can be any of the @ref UART2_LinAutosync_TypeDef values.
    332            * @param  UART2_DivUp specifies the LIN divider update method.
    333            *         This parameter can be any of the @ref UART2_LinDivUp_TypeDef values.
    334            * @retval None
    335            */

   \                                 In section .far_func.text, align 1
    336          void UART2_LINConfig(UART2_LinMode_TypeDef UART2_Mode, 
    337                               UART2_LinAutosync_TypeDef UART2_Autosync, 
    338                               UART2_LinDivUp_TypeDef UART2_DivUp)
    339          {
   \                     UART2_LINConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 B700                  LD        S:?b8, A
   \   000009 450000                MOV       S:?b9, S:?b0
   \   00000C 450000                MOV       S:?b10, S:?b1
    340              /* Check parameters */
    341              assert_param(IS_UART2_SLAVE_OK(UART2_Mode));
   \   00000F 270B                  JREQ      L:??CrossCallReturnLabel_13
   \   000011 A101                  CP        A, #0x1
   \   000013 2707                  JREQ      L:??CrossCallReturnLabel_13
   \   000015 AE0155                LDW       X, #0x155
   \   000018 8D000000              CALLF     ?Subroutine0
    342              assert_param(IS_UART2_AUTOSYNC_OK(UART2_Autosync));
   \                     ??CrossCallReturnLabel_13:
   \   00001C B600                  LD        A, S:?b9
   \   00001E A101                  CP        A, #0x1
   \   000020 270B                  JREQ      L:??CrossCallReturnLabel_12
   \   000022 3D00                  TNZ       S:?b9
   \   000024 2707                  JREQ      L:??CrossCallReturnLabel_12
   \   000026 AE0156                LDW       X, #0x156
   \   000029 8D000000              CALLF     ?Subroutine0
    343              assert_param(IS_UART2_DIVUP_OK(UART2_DivUp));
   \                     ??CrossCallReturnLabel_12:
   \   00002D 3D00                  TNZ       S:?b10
   \   00002F 270D                  JREQ      L:??CrossCallReturnLabel_11
   \   000031 B600                  LD        A, S:?b10
   \   000033 A101                  CP        A, #0x1
   \   000035 2707                  JREQ      L:??CrossCallReturnLabel_11
   \   000037 AE0157                LDW       X, #0x157
   \   00003A 8D000000              CALLF     ?Subroutine0
    344          
    345              if (UART2_Mode != UART2_LIN_MODE_MASTER)
   \                     ??CrossCallReturnLabel_11:
   \   00003E 3D00                  TNZ       S:?b8
   \   000040 2706                  JREQ      L:??UART2_LINConfig_0
    346              {
    347                  UART2->CR6 |=  UART2_CR6_LSLV;
   \   000042 721A5249              BSET      L:0x5249, #0x5
   \   000046 2004                  JRA       L:??UART2_LINConfig_1
    348              }
    349              else
    350              {
    351                  UART2->CR6 &= ((uint8_t)~UART2_CR6_LSLV);
   \                     ??UART2_LINConfig_0:
   \   000048 721B5249              BRES      L:0x5249, #0x5
    352              }
    353          
    354              if (UART2_Autosync != UART2_LIN_AUTOSYNC_DISABLE)
   \                     ??UART2_LINConfig_1:
   \   00004C 3D00                  TNZ       S:?b9
   \   00004E 2706                  JREQ      L:??UART2_LINConfig_2
    355              {
    356                  UART2->CR6 |=  UART2_CR6_LASE ;
   \   000050 72185249              BSET      L:0x5249, #0x4
   \   000054 2004                  JRA       L:??UART2_LINConfig_3
    357              }
    358              else
    359              {
    360                  UART2->CR6 &= ((uint8_t)~ UART2_CR6_LASE );
   \                     ??UART2_LINConfig_2:
   \   000056 72195249              BRES      L:0x5249, #0x4
    361              }
    362          
    363              if (UART2_DivUp != UART2_LIN_DIVUP_LBRR1)
   \                     ??UART2_LINConfig_3:
   \   00005A 3D00                  TNZ       S:?b10
   \   00005C 2706                  JREQ      L:??UART2_LINConfig_4
    364              {
    365                  UART2->CR6 |=  UART2_CR6_LDUM;
   \   00005E 721E5249              BSET      L:0x5249, #0x7
   \   000062 2004                  JRA       L:??UART2_LINConfig_5
    366              }
    367              else
    368              {
    369                  UART2->CR6 &= ((uint8_t)~ UART2_CR6_LDUM);
   \                     ??UART2_LINConfig_4:
   \   000064 721F5249              BRES      L:0x5249, #0x7
    370              }
    371          }
   \                     ??UART2_LINConfig_5:
   \   000068 320000                POP       S:?b10
   \   00006B AC000000              JPF       L:?epilogue_w4
    372          
    373          /**
    374            * @brief  Enables or disables the UART2 LIN mode.
    375            * @param  NewState is new state of the UART2 LIN mode.
    376            *         This parameter can be ENABLE or DISABLE
    377            * @retval None
    378            */

   \                                 In section .far_func.text, align 1
    379          void UART2_LINCmd(FunctionalState NewState)
    380          {
    381              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_LINCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??UART2_LINCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_14
   \   000007 AE017D                LDW       X, #0x17d
   \   00000A 8D000000              CALLF     ?Subroutine0
    382          
    383              if (NewState != DISABLE)
    384              {
    385                  /* Enable the LIN mode by setting the LINE bit in the CR2 register */
    386                  UART2->CR3 |= UART2_CR3_LINEN;
   \                     ??CrossCallReturnLabel_14:
   \   00000E 721C5246              BSET      L:0x5246, #0x6
   \   000012 87                    RETF
    387              }
    388              else
    389              {
    390                  /* Disable the LIN mode by clearing the LINE bit in the CR2 register */
    391                  UART2->CR3 &= ((uint8_t)~UART2_CR3_LINEN);
   \                     ??UART2_LINCmd_0:
   \   000013 721D5246              BRES      L:0x5246, #0x6
    392              }
    393          }
   \   000017 87                    RETF
    394          /**
    395            * @brief  Enables or disables the UART2 Smart Card mode.
    396            * @param  NewState: new state of the Smart Card mode.
    397            *         This parameter can be: ENABLE or DISABLE.
    398            * @retval None
    399            */

   \                                 In section .far_func.text, align 1
    400          void UART2_SmartCardCmd(FunctionalState NewState)
    401          {
    402              /* Check parameters */
    403              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_SmartCardCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??UART2_SmartCardCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_15
   \   000007 AE0193                LDW       X, #0x193
   \   00000A 8D000000              CALLF     ?Subroutine0
    404          
    405              if (NewState != DISABLE)
    406              {
    407                  /* Enable the SC mode by setting the SCEN bit in the CR5 register */
    408                  UART2->CR5 |= UART2_CR5_SCEN;
   \                     ??CrossCallReturnLabel_15:
   \   00000E 721A5248              BSET      L:0x5248, #0x5
   \   000012 87                    RETF
    409              }
    410              else
    411              {
    412                  /* Disable the SC mode by clearing the SCEN bit in the CR5 register */
    413                  UART2->CR5 &= ((uint8_t)(~UART2_CR5_SCEN));
   \                     ??UART2_SmartCardCmd_0:
   \   000013 721B5248              BRES      L:0x5248, #0x5
    414              }
    415          }
   \   000017 87                    RETF
    416          
    417          /**
    418            * @brief  Enables or disables NACK transmission.
    419            * @param  NewState: new state of the Smart Card mode.
    420            *         This parameter can be: ENABLE or DISABLE.
    421            * @retval None
    422            */

   \                                 In section .far_func.text, align 1
    423          void UART2_SmartCardNACKCmd(FunctionalState NewState)
    424          {
    425              /* Check parameters */
    426              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_SmartCardNACKCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??UART2_SmartCardNACKCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_16
   \   000007 AE01AA                LDW       X, #0x1aa
   \   00000A 8D000000              CALLF     ?Subroutine0
    427          
    428              if (NewState != DISABLE)
    429              {
    430                  /* Enable the NACK transmission by setting the NACK bit in the CR5 register */
    431                  UART2->CR5 |= UART2_CR5_NACK;
   \                     ??CrossCallReturnLabel_16:
   \   00000E 72185248              BSET      L:0x5248, #0x4
   \   000012 87                    RETF
    432              }
    433              else
    434              {
    435                  /* Disable the NACK transmission by clearing the NACK bit in the CR5 register */
    436                  UART2->CR5 &= ((uint8_t)~(UART2_CR5_NACK));
   \                     ??UART2_SmartCardNACKCmd_0:
   \   000013 72195248              BRES      L:0x5248, #0x4
    437              }
    438          }
   \   000017 87                    RETF
    439          
    440          /**
    441            * @brief  Selects the UART2 WakeUp method.
    442            * @param  UART2_WakeUp: specifies the UART2 wakeup method.
    443            *         This parameter can be any of the @ref UART2_WakeUp_TypeDef values.
    444            * @retval None
    445            */

   \                                 In section .far_func.text, align 1
    446          void UART2_WakeUpConfig(UART2_WakeUp_TypeDef UART2_WakeUp)
    447          {
   \                     UART2_WakeUpConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    448              assert_param(IS_UART2_WAKEUP_OK(UART2_WakeUp));
   \   000005 270B                  JREQ      L:??CrossCallReturnLabel_17
   \   000007 A108                  CP        A, #0x8
   \   000009 2707                  JREQ      L:??CrossCallReturnLabel_17
   \   00000B AE01C0                LDW       X, #0x1c0
   \   00000E 8D000000              CALLF     ?Subroutine0
    449          
    450              UART2->CR1 &= ((uint8_t)~UART2_CR1_WAKE);
   \                     ??CrossCallReturnLabel_17:
   \   000012 72175244              BRES      L:0x5244, #0x3
    451              UART2->CR1 |= (uint8_t)UART2_WakeUp;
   \   000016 B600                  LD        A, S:?b8
   \   000018 8D000000              CALLF     ?Subroutine2
    452          }
   \                     ??CrossCallReturnLabel_27:
   \   00001C 320000                POP       S:?b8
   \   00001F 87                    RETF
    453          
    454          /**
    455            * @brief  Determines if the UART2 is in mute mode or not.
    456            * @param  NewState: new state of the UART2 mode.
    457            *         This parameter can be ENABLE or DISABLE
    458            * @retval None
    459            */

   \                                 In section .far_func.text, align 1
    460          void UART2_ReceiverWakeUpCmd(FunctionalState NewState)
    461          {
    462              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_ReceiverWakeUpCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??UART2_ReceiverWakeUpCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_18
   \   000007 AE01CE                LDW       X, #0x1ce
   \   00000A 8D000000              CALLF     ?Subroutine0
    463          
    464              if (NewState != DISABLE)
    465              {
    466                  /* Enable the mute mode UART2 by setting the RWU bit in the CR2 register */
    467                  UART2->CR2 |= UART2_CR2_RWU;
   \                     ??CrossCallReturnLabel_18:
   \   00000E 72125245              BSET      L:0x5245, #0x1
   \   000012 87                    RETF
    468              }
    469              else
    470              {
    471                  /* Disable the mute mode UART2 by clearing the RWU bit in the CR1 register */
    472                  UART2->CR2 &= ((uint8_t)~UART2_CR2_RWU);
   \                     ??UART2_ReceiverWakeUpCmd_0:
   \   000013 72135245              BRES      L:0x5245, #0x1
    473              }
    474          }
   \   000017 87                    RETF
    475          
    476          /**
    477            * @brief  Returns the most recent received data by the UART2 peripheral.
    478            * @param  None
    479            * @retval Received Data
    480            */

   \                                 In section .far_func.text, align 1
    481          uint8_t UART2_ReceiveData8(void)
    482          {
    483              return ((uint8_t)UART2->DR);
   \                     UART2_ReceiveData8:
   \   000000 C65241                LD        A, L:0x5241
   \   000003 87                    RETF
    484          }
    485          
    486          /**
    487            * @brief  Returns the most recent received data by the UART2 peripheral.
    488            * @param  None  
    489            * @retval Received Data
    490            */

   \                                 In section .far_func.text, align 1
    491          uint16_t UART2_ReceiveData9(void)
    492          {
    493            uint16_t temp = 0;
    494          
    495            temp = ((uint16_t)(((uint16_t)((uint16_t)UART2->CR1 & (uint16_t)UART2_CR1_R8)) << 1));
   \                     UART2_ReceiveData9:
   \   000000 C65244                LD        A, L:0x5244
    496            
    497            return (uint16_t)((((uint16_t)UART2->DR) | temp) & ((uint16_t)0x01FF));
   \   000003 5F                    CLRW      X
   \   000004 97                    LD        XL, A
   \   000005 01                    RRWA      X, A
   \   000006 A480                  AND       A, #0x80
   \   000008 02                    RLWA      X, A
   \   000009 58                    SLLW      X
   \   00000A C65241                LD        A, L:0x5241
   \   00000D 905F                  CLRW      Y
   \   00000F 9097                  LD        YL, A
   \   000011 BF00                  LDW       S:?w0, X
   \   000013 93                    LDW       X, Y
   \   000014 02                    RLWA      X, A
   \   000015 BA00                  OR        A, S:?b0
   \   000017 01                    RRWA      X, A
   \   000018 87                    RETF
    498          }
    499          
    500          /**
    501            * @brief  Transmits 8 bit data through the UART2 peripheral.
    502            * @param  Data: the data to transmit.
    503            * @retval None
    504            */

   \                                 In section .far_func.text, align 1
    505          void UART2_SendData8(uint8_t Data)
    506          {
    507              /* Transmit Data */
    508              UART2->DR = Data;
   \                     UART2_SendData8:
   \   000000 C75241                LD        L:0x5241, A
    509          }
   \   000003 87                    RETF
    510          
    511          /**
    512            * @brief  Transmits 9 bit data through the UART2 peripheral.
    513            * @param  Data: the data to transmit.
    514            * @retval None
    515            */

   \                                 In section .far_func.text, align 1
    516          void UART2_SendData9(uint16_t Data)
    517          {
   \                     UART2_SendData9:
   \   000000 9093                  LDW       Y, X
    518              /* Clear the transmit data bit 8 */
    519              UART2->CR1 &= ((uint8_t)~UART2_CR1_T8);                  
   \   000002 721D5244              BRES      L:0x5244, #0x6
    520              
    521              /* Write the transmit data bit [8] */
    522              UART2->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & UART2_CR1_T8); 
   \   000006 54                    SRLW      X
   \   000007 54                    SRLW      X
   \   000008 9F                    LD        A, XL
   \   000009 A440                  AND       A, #0x40
   \   00000B 8D000000              CALLF     ?Subroutine2
    523              
    524              /* Write the transmit data bit [0:7] */
    525              UART2->DR   = (uint8_t)(Data);                    
   \                     ??CrossCallReturnLabel_26:
   \   00000F 909F                  LD        A, YL
   \   000011 C75241                LD        L:0x5241, A
    526          
    527          }
   \   000014 87                    RETF
    528          
    529          /**
    530            * @brief  Transmits break characters.
    531            * @param  None
    532            * @retval None
    533            */

   \                                 In section .far_func.text, align 1
    534          void UART2_SendBreak(void)
    535          {
    536              UART2->CR2 |= UART2_CR2_SBK;
   \                     UART2_SendBreak:
   \   000000 72105245              BSET      L:0x5245, #0x0
    537          }
   \   000004 87                    RETF
    538          
    539          /**
    540            * @brief  Sets the address of the UART2 node.
    541            * @param  UART2_Address: Indicates the address of the UART2 node.
    542            * @retval None
    543            */

   \                                 In section .far_func.text, align 1
    544          void UART2_SetAddress(uint8_t UART2_Address)
    545          {
   \                     UART2_SetAddress:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    546              /*assert_param for x UART2_Address*/
    547              assert_param(IS_UART2_ADDRESS_OK(UART2_Address));
   \   000005 A110                  CP        A, #0x10
   \   000007 2507                  JRC       L:??CrossCallReturnLabel_19
   \   000009 AE0223                LDW       X, #0x223
   \   00000C 8D000000              CALLF     ?Subroutine0
    548          
    549              /* Clear the UART2 address */
    550              UART2->CR4 &= ((uint8_t)~UART2_CR4_ADD);
   \                     ??CrossCallReturnLabel_19:
   \   000010 C65247                LD        A, L:0x5247
   \   000013 A4F0                  AND       A, #0xf0
   \   000015 C75247                LD        L:0x5247, A
    551              /* Set the UART2 address node */
    552              UART2->CR4 |= UART2_Address;
   \   000018 B600                  LD        A, S:?b8
   \   00001A CA5247                OR        A, L:0x5247
   \   00001D C75247                LD        L:0x5247, A
    553          }
   \   000020 320000                POP       S:?b8
   \   000023 87                    RETF
    554          
    555          /**
    556            * @brief  Sets the specified UART2 guard time.
    557            * @note   SmartCard Mode should be Enabled  
    558            * @param  UART2_GuardTime: specifies the guard time.
    559            * @retval None
    560            */

   \                                 In section .far_func.text, align 1
    561          void UART2_SetGuardTime(uint8_t UART2_GuardTime)
    562          {
    563              /* Set the UART2 guard time */
    564              UART2->GTR = UART2_GuardTime;
   \                     UART2_SetGuardTime:
   \   000000 C7524A                LD        L:0x524a, A
    565          }
   \   000003 87                    RETF
    566          
    567          /**
    568            * @brief  Sets the system clock prescaler.
    569            * @note   IrDA Low Power mode or smartcard mode should be enabled
    570            * @note   This function is related to SmartCard and IrDa mode.
    571            * @param  UART2_Prescaler: specifies the prescaler clock.
    572            *         This parameter can be one of the following values:
    573            *         @par IrDA Low Power Mode
    574            *         The clock source is divided by the value given in the register (8 bits)
    575            *         - 0000 0000 Reserved
    576            *         - 0000 0001 divides the clock source by 1
    577            *         - 0000 0010 divides the clock source by 2
    578            *         - ...........................................................
    579            *        @par Smart Card Mode
    580            *        The clock source is divided by the value given in the register
    581            *        (5 significant bits) multiped by 2
    582            *         - 0 0000 Reserved
    583            *         - 0 0001 divides the clock source by 2
    584            *         - 0 0010 divides the clock source by 4
    585            *         - 0 0011 divides the clock source by 6
    586            *         - ...........................................................
    587            * @retval None
    588            */

   \                                 In section .far_func.text, align 1
    589          void UART2_SetPrescaler(uint8_t UART2_Prescaler)
    590          {
    591              /* Load the UART2 prescaler value*/
    592              UART2->PSCR = UART2_Prescaler;
   \                     UART2_SetPrescaler:
   \   000000 C7524B                LD        L:0x524b, A
    593          }
   \   000003 87                    RETF
    594          
    595          /**
    596            * @brief  Checks whether the specified UART2 flag is set or not.
    597            * @param  UART2_FLAG specifies the flag to check.
    598            *         This parameter can be any of the @ref UART2_Flag_TypeDef enumeration.
    599            * @retval FlagStatus (SET or RESET)
    600            */

   \                                 In section .far_func.text, align 1
    601          FlagStatus UART2_GetFlagStatus(UART2_Flag_TypeDef UART2_FLAG)
    602          {
   \                     UART2_GetFlagStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    603              FlagStatus status = RESET;
    604          
    605              /* Check parameters */
    606              assert_param(IS_UART2_FLAG_OK(UART2_FLAG));
   \   000006 A30080                CPW       X, #0x80
   \   000009 273E                  JREQ      L:??CrossCallReturnLabel_20
   \   00000B A30040                CPW       X, #0x40
   \   00000E 2739                  JREQ      L:??CrossCallReturnLabel_20
   \   000010 A30020                CPW       X, #0x20
   \   000013 2734                  JREQ      L:??CrossCallReturnLabel_20
   \   000015 A30010                CPW       X, #0x10
   \   000018 272F                  JREQ      L:??CrossCallReturnLabel_20
   \   00001A A30008                CPW       X, #0x8
   \   00001D 272A                  JREQ      L:??CrossCallReturnLabel_20
   \   00001F A30004                CPW       X, #0x4
   \   000022 2725                  JREQ      L:??CrossCallReturnLabel_20
   \   000024 A30002                CPW       X, #0x2
   \   000027 2720                  JREQ      L:??CrossCallReturnLabel_20
   \   000029 A30001                CPW       X, #0x1
   \   00002C 271B                  JREQ      L:??CrossCallReturnLabel_20
   \   00002E A30101                CPW       X, #0x101
   \   000031 272C                  JREQ      L:??UART2_GetFlagStatus_0
   \   000033 A30301                CPW       X, #0x301
   \   000036 2731                  JREQ      L:??UART2_GetFlagStatus_1
   \   000038 A30302                CPW       X, #0x302
   \   00003B 272C                  JREQ      L:??UART2_GetFlagStatus_1
   \   00003D A30210                CPW       X, #0x210
   \   000040 2712                  JREQ      L:??UART2_GetFlagStatus_2
   \   000042 AE025E                LDW       X, #0x25e
   \   000045 8D000000              CALLF     ?Subroutine0
    607          
    608              /* Check the status of the specified UART2 flag*/
    609              if (UART2_FLAG == UART2_FLAG_LBDF)
    610              {
    611                  if ((UART2->CR4 & (uint8_t)UART2_FLAG) != (uint8_t)0x00)
    612                  {
    613                      /* UART2_FLAG is set*/
    614                      status = SET;
    615                  }
    616                  else
    617                  {
    618                      /* UART2_FLAG is reset*/
    619                      status = RESET;
    620                  }
    621              }
    622              else if (UART2_FLAG == UART2_FLAG_SBK)
    623              {
    624                  if ((UART2->CR2 & (uint8_t)UART2_FLAG) != (uint8_t)0x00)
    625                  {
    626                      /* UART2_FLAG is set*/
    627                      status = SET;
    628                  }
    629                  else
    630                  {
    631                      /* UART2_FLAG is reset*/
    632                      status = RESET;
    633                  }
    634              }
    635              else if ((UART2_FLAG == UART2_FLAG_LHDF) || (UART2_FLAG == UART2_FLAG_LSF))
    636              {
    637                  if ((UART2->CR6 & (uint8_t)UART2_FLAG) != (uint8_t)0x00)
    638                  {
    639                      /* UART2_FLAG is set*/
    640                      status = SET;
    641                  }
    642                  else
    643                  {
    644                      /* UART2_FLAG is reset*/
    645                      status = RESET;
    646                  }
    647              }
    648              else
    649              {
    650                  if ((UART2->SR & (uint8_t)UART2_FLAG) != (uint8_t)0x00)
   \                     ??CrossCallReturnLabel_20:
   \   000049 B600                  LD        A, S:?b9
   \   00004B C45240                AND       A, L:0x5240
   \                     ??UART2_GetFlagStatus_3:
   \   00004E A100                  CP        A, #0x0
   \   000050 2607                  JRNE      L:??UART2_GetFlagStatus_4
   \   000052 2010                  JRA       L:??UART2_GetFlagStatus_5
    651                  {
    652                      /* UART2_FLAG is set*/
    653                      status = SET;
    654                  }
    655                  else
    656                  {
    657                      /* UART2_FLAG is reset*/
    658                      status = RESET;
    659                  }
    660              }
   \                     ??UART2_GetFlagStatus_2:
   \   000054 720952470B            BTJF      L:0x5247, #0x4, L:??UART2_GetFlagStatus_5
   \                     ??UART2_GetFlagStatus_4:
   \   000059 A601                  LD        A, #0x1
    661          
    662              /* Return the UART2_FLAG status*/
    663              return  status;
   \   00005B AC000000              JPF       L:?epilogue_w4
   \                     ??UART2_GetFlagStatus_0:
   \   00005F 72005245F5            BTJT      L:0x5245, #0x0, L:??UART2_GetFlagStatus_4
   \                     ??UART2_GetFlagStatus_5:
   \   000064 4F                    CLR       A
   \   000065 AC000000              JPF       L:?epilogue_w4
   \                     ??UART2_GetFlagStatus_1:
   \   000069 B600                  LD        A, S:?b9
   \   00006B C45249                AND       A, L:0x5249
   \   00006E 20DE                  JRA       ??UART2_GetFlagStatus_3
    664          }
    665          /**
    666            * @brief  Clears the UART2 flags.
    667            * @param  UART2_FLAG specifies the flag to clear
    668            *         This parameter can be any combination of the following values:
    669            *         - UART2_FLAG_LBDF: LIN Break detection flag.
    670            *         - UART2_FLAG_LHDF: LIN Header detection flag.
    671            *         - UART2_FLAG_LSF: LIN synchrone field flag.
    672            *         - UART2_FLAG_RXNE: Receive data register not empty flag.
    673            * @note:
    674            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    675            *           OR (OverRun error) and IDLE (Idle line detected) flags are cleared
    676            *           by software sequence: a read operation to UART2_SR register 
    677            *           (UART2_GetFlagStatus())followed by a read operation to UART2_DR 
    678            *           register(UART2_ReceiveData8() or UART2_ReceiveData9()).
    679            *        
    680            *         - RXNE flag can be also cleared by a read to the UART2_DR register
    681            *           (UART2_ReceiveData8()or UART2_ReceiveData9()).
    682            *
    683            *         - TC flag can be also cleared by software sequence: a read operation
    684            *           to UART2_SR register (UART2_GetFlagStatus()) followed by a write 
    685            *           operation to UART2_DR register (UART2_SendData8() or UART2_SendData9()).
    686            *             
    687            *         - TXE flag is cleared only by a write to the UART2_DR register 
    688            *           (UART2_SendData8() or UART2_SendData9()).
    689            *             
    690            *         - SBK flag is cleared during the stop bit of break.
    691            * @retval None
    692            */

   \                                 In section .far_func.text, align 1
    693          void UART2_ClearFlag(UART2_Flag_TypeDef UART2_FLAG)
    694          {
    695              assert_param(IS_UART2_CLEAR_FLAG_OK(UART2_FLAG));
   \                     UART2_ClearFlag:
   \   000000 A30020                CPW       X, #0x20
   \   000003 271B                  JREQ      L:??UART2_ClearFlag_0
   \   000005 A30302                CPW       X, #0x302
   \   000008 2720                  JREQ      L:??UART2_ClearFlag_1
   \   00000A A30301                CPW       X, #0x301
   \   00000D 270C                  JREQ      L:??CrossCallReturnLabel_21
   \   00000F A30210                CPW       X, #0x210
   \   000012 2711                  JREQ      L:??UART2_ClearFlag_2
   \   000014 AE02B7                LDW       X, #0x2b7
   \   000017 8D000000              CALLF     ?Subroutine0
    696          
    697              /*  Clear the Receive Register Not Empty flag */
    698              if (UART2_FLAG == UART2_FLAG_RXNE)
    699              {
    700                  UART2->SR = (uint8_t)~(UART2_SR_RXNE);
    701              }
    702              /*  Clear the LIN Break Detection flag */
    703              else if (UART2_FLAG == UART2_FLAG_LBDF)
    704              {
    705                  UART2->CR4 &= (uint8_t)(~UART2_CR4_LBDF);
    706              }
    707              /*  Clear the LIN Header Detection Flag */
    708              else if (UART2_FLAG == UART2_FLAG_LHDF)
    709              {
    710                  UART2->CR6 &= (uint8_t)(~UART2_CR6_LHDF);
    711              }
    712              /*  Clear the LIN Synch Field flag */
    713              else
    714              {
    715                  UART2->CR6 &= (uint8_t)(~UART2_CR6_LSF);
   \                     ??CrossCallReturnLabel_21:
   \   00001B 72115249              BRES      L:0x5249, #0x0
    716              }
    717          }
   \   00001F 87                    RETF
   \                     ??UART2_ClearFlag_0:
   \   000020 35DF5240              MOV       L:0x5240, #0xdf
   \   000024 87                    RETF
   \                     ??UART2_ClearFlag_2:
   \   000025 72195247              BRES      L:0x5247, #0x4
   \   000029 87                    RETF
   \                     ??UART2_ClearFlag_1:
   \   00002A 72135249              BRES      L:0x5249, #0x1
   \   00002E 87                    RETF
    718          
    719          /**
    720            * @brief  Checks whether the specified UART2 interrupt has occurred or not.
    721            * @param  UART2_IT: Specifies the UART2 interrupt pending bit to check.
    722            *         This parameter can be one of the following values:
    723            *         - UART2_IT_LBDF:  LIN Break detection interrupt
    724            *         - UART2_IT_TXE:  Tansmit Data Register empty interrupt
    725            *         - UART2_IT_TC:   Transmission complete interrupt
    726            *         - UART2_IT_RXNE: Receive Data register not empty interrupt
    727            *         - UART2_IT_IDLE: Idle line detection interrupt
    728            *         - UART2_IT_OR:  OverRun Error interrupt
    729            *         - UART2_IT_PE:   Parity Error interrupt
    730            * @retval The state of UART2_IT (SET or RESET).
    731            */

   \                                 In section .far_func.text, align 1
    732          ITStatus UART2_GetITStatus(UART2_IT_TypeDef UART2_IT)
    733          {
   \                     UART2_GetITStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    734              ITStatus pendingbitstatus = RESET;
    735              uint8_t itpos = 0;
    736              uint8_t itmask1 = 0;
    737              uint8_t itmask2 = 0;
    738              uint8_t enablestatus = 0;
    739          
    740              /* Check parameters */
    741              assert_param(IS_UART2_GET_IT_OK(UART2_IT));
   \   000006 A30277                CPW       X, #0x277
   \   000009 272A                  JREQ      L:??CrossCallReturnLabel_22
   \   00000B A30266                CPW       X, #0x266
   \   00000E 2725                  JREQ      L:??CrossCallReturnLabel_22
   \   000010 A30255                CPW       X, #0x255
   \   000013 2720                  JREQ      L:??CrossCallReturnLabel_22
   \   000015 A30244                CPW       X, #0x244
   \   000018 271B                  JREQ      L:??CrossCallReturnLabel_22
   \   00001A A30235                CPW       X, #0x235
   \   00001D 2716                  JREQ      L:??CrossCallReturnLabel_22
   \   00001F A30346                CPW       X, #0x346
   \   000022 2711                  JREQ      L:??CrossCallReturnLabel_22
   \   000024 A30412                CPW       X, #0x412
   \   000027 270C                  JREQ      L:??CrossCallReturnLabel_22
   \   000029 A30100                CPW       X, #0x100
   \   00002C 2707                  JREQ      L:??CrossCallReturnLabel_22
   \   00002E AE02E5                LDW       X, #0x2e5
   \   000031 8D000000              CALLF     ?Subroutine0
    742          
    743              /* Get the UART2 IT index*/
    744              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART2_IT & (uint8_t)0x0F));
   \                     ??CrossCallReturnLabel_22:
   \   000035 B600                  LD        A, S:?b9
   \   000037 8D000000              CALLF     ?Subroutine1
    745              /* Get the UART2 IT index*/
    746              itmask1 = (uint8_t)((uint8_t)UART2_IT >> (uint8_t)4);
    747              /* Set the IT mask*/
    748              itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \                     ??CrossCallReturnLabel_24:
   \   00003B B600                  LD        A, S:?b9
   \   00003D 4E                    SWAP      A
   \   00003E A40F                  AND       A, #0xf
   \   000040 5F                    CLRW      X
   \   000041 5C                    INCW      X
   \   000042 8D000000              CALLF     L:?sll16_x_x_a
   \   000046 9F                    LD        A, XL
    749          
    750              /* Check the status of the specified UART2 pending bit*/
    751              if (UART2_IT == UART2_IT_PE)
   \   000047 BE00                  LDW       X, S:?w4
   \   000049 A30100                CPW       X, #0x100
   \   00004C 2616                  JRNE      L:??UART2_GetITStatus_0
    752              {
    753                  /* Get the UART2_ITPENDINGBIT enable bit status*/
    754                  enablestatus = (uint8_t)((uint8_t)UART2->CR1 & itmask2);
   \   00004E C45244                AND       A, L:0x5244
   \   000051 B700                  LD        S:?b1, A
    755                  /* Check the status of the specified UART2 interrupt*/
    756          
    757                  if (((UART2->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   000053 B600                  LD        A, S:?b0
   \   000055 C55240                BCP       A, L:0x5240
   \   000058 271B                  JREQ      L:??UART2_GetITStatus_1
   \                     ??UART2_GetITStatus_2:
   \   00005A 3D00                  TNZ       S:?b1
   \   00005C 2717                  JREQ      L:??UART2_GetITStatus_1
    758                  {
    759                      /* Interrupt occurred*/
    760                      pendingbitstatus = SET;
   \   00005E A601                  LD        A, #0x1
    761                  }
    762                  else
    763                  {
    764                      /* Interrupt not occurred*/
    765                      pendingbitstatus = RESET;
    766                  }
    767              }
    768              else if (UART2_IT == UART2_IT_LBDF)
    769              {
    770                  /* Get the UART2_IT enable bit status*/
    771                  enablestatus = (uint8_t)((uint8_t)UART2->CR4 & itmask2);
    772                  /* Check the status of the specified UART2 interrupt*/
    773                  if (((UART2->CR4 & itpos) != (uint8_t)0x00) && enablestatus)
    774                  {
    775                      /* Interrupt occurred*/
    776                      pendingbitstatus = SET;
    777                  }
    778                  else
    779                  {
    780                      /* Interrupt not occurred*/
    781                      pendingbitstatus = RESET;
    782                  }
    783              }
    784              else if (UART2_IT == UART2_IT_LHDF)
    785              {
    786                  /* Get the UART2_IT enable bit status*/
    787                  enablestatus = (uint8_t)((uint8_t)UART2->CR6 & itmask2);
    788                  /* Check the status of the specified UART2 interrupt*/
    789                  if (((UART2->CR6 & itpos) != (uint8_t)0x00) && enablestatus)
    790                  {
    791                      /* Interrupt occurred*/
    792                      pendingbitstatus = SET;
    793                  }
    794                  else
    795                  {
    796                      /* Interrupt not occurred*/
    797                      pendingbitstatus = RESET;
    798                  }
    799              }
    800              else
    801              {
    802                  /* Get the UART2_IT enable bit status*/
    803                  enablestatus = (uint8_t)((uint8_t)UART2->CR2 & itmask2);
    804                  /* Check the status of the specified UART2 interrupt*/
    805                  if (((UART2->SR & itpos) != (uint8_t)0x00) && enablestatus)
    806                  {
    807                      /* Interrupt occurred*/
    808                      pendingbitstatus = SET;
    809                  }
    810                  else
    811                  {
    812                      /* Interrupt not occurred*/
    813                      pendingbitstatus = RESET;
    814                  }
    815              }
    816              /* Return the UART2_IT status*/
    817              return  pendingbitstatus;
   \   000060 AC000000              JPF       L:?epilogue_w4
   \                     ??UART2_GetITStatus_0:
   \   000064 A30346                CPW       X, #0x346
   \   000067 2611                  JRNE      L:??UART2_GetITStatus_3
   \   000069 C45247                AND       A, L:0x5247
   \   00006C B700                  LD        S:?b1, A
   \   00006E B600                  LD        A, S:?b0
   \   000070 C55247                BCP       A, L:0x5247
   \   000073 26E5                  JRNE      L:??UART2_GetITStatus_2
   \                     ??UART2_GetITStatus_1:
   \   000075 4F                    CLR       A
   \   000076 AC000000              JPF       L:?epilogue_w4
   \                     ??UART2_GetITStatus_3:
   \   00007A A30412                CPW       X, #0x412
   \   00007D 2610                  JRNE      L:??UART2_GetITStatus_4
   \   00007F C45249                AND       A, L:0x5249
   \   000082 B700                  LD        S:?b1, A
   \   000084 B600                  LD        A, S:?b0
   \   000086 C45249                AND       A, L:0x5249
   \                     ??UART2_GetITStatus_5:
   \   000089 A100                  CP        A, #0x0
   \   00008B 26CD                  JRNE      L:??UART2_GetITStatus_2
   \   00008D 20E6                  JRA       L:??UART2_GetITStatus_1
   \                     ??UART2_GetITStatus_4:
   \   00008F C45245                AND       A, L:0x5245
   \   000092 B700                  LD        S:?b1, A
   \   000094 B600                  LD        A, S:?b0
   \   000096 C45240                AND       A, L:0x5240
   \   000099 20EE                  JRA       ??UART2_GetITStatus_5
    818          }
    819          
    820          /**
    821            * @brief  Clears the UART2 pending flags.
    822            * @param  UART2_IT specifies the pending bit to clear
    823            *         This parameter can be one of the following values:
    824            *         - UART2_IT_LBDF:  LIN Break detection interrupt
    825            *         - UART2_IT_LHDF:  LIN Header detection interrupt
    826            *         - UART2_IT_RXNE: Receive Data register not empty interrupt.
    827            * @note
    828            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    829            *           OR (OverRun error) and IDLE (Idle line detected) pending bits are 
    830            *           cleared by software sequence: a read operation to UART2_SR register
    831            *           (UART2_GetITStatus()) followed by a read operation to UART2_DR register
    832            *           (UART2_ReceiveData8() or UART2_ReceiveData9()).
    833            *             
    834            *         - RXNE pending bit can be also cleared by a read to the UART2_DR 
    835            *           register (UART2_ReceiveData8() or UART2_ReceiveData9()).
    836            *              
    837            *         - TC (Transmit complete) pending bit can be cleared by software 
    838            *           sequence: a read operation to UART2_SR register 
    839            *           (UART2_GetITStatus()) followed by a write operation to UART2_DR 
    840            *           register (UART2_SendData8()or UART2_SendData9()).
    841            *               
    842            *         - TXE pending bit is cleared only by a write to the UART2_DR register
    843            *           (UART2_SendData8() or UART2_SendData9()).
    844            * @retval None
    845            */

   \                                 In section .far_func.text, align 1
    846          void UART2_ClearITPendingBit(UART2_IT_TypeDef UART2_IT)
    847          {
    848              assert_param(IS_UART2_CLEAR_IT_OK(UART2_IT));
   \                     UART2_ClearITPendingBit:
   \   000000 A30255                CPW       X, #0x255
   \   000003 2716                  JREQ      L:??UART2_ClearITPendingBit_0
   \   000005 A30412                CPW       X, #0x412
   \   000008 270C                  JREQ      L:??CrossCallReturnLabel_23
   \   00000A A30346                CPW       X, #0x346
   \   00000D 2711                  JREQ      L:??UART2_ClearITPendingBit_1
   \   00000F AE0350                LDW       X, #0x350
   \   000012 8D000000              CALLF     ?Subroutine0
    849          
    850              /*  Clear the Receive Register Not Empty pending bit */
    851              if (UART2_IT == UART2_IT_RXNE)
    852              {
    853                  UART2->SR = (uint8_t)~(UART2_SR_RXNE);
    854              }
    855              /*  Clear the LIN Break Detection pending bit */
    856              else if (UART2_IT == UART2_IT_LBDF)
    857              {
    858                  UART2->CR4 &= (uint8_t)~(UART2_CR4_LBDF);
    859              }
    860              /*  Clear the LIN Header Detection pending bit */
    861              else
    862              {
    863                  UART2->CR6 &= (uint8_t)(~UART2_CR6_LHDF);
   \                     ??CrossCallReturnLabel_23:
   \   000016 72135249              BRES      L:0x5249, #0x1
    864              }
    865          }
   \   00001A 87                    RETF
   \                     ??UART2_ClearITPendingBit_0:
   \   00001B 35DF5240              MOV       L:0x5240, #0xdf
   \   00001F 87                    RETF
   \                     ??UART2_ClearITPendingBit_1:
   \   000020 72195247              BRES      L:0x5247, #0x4
   \   000024 87                    RETF

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\Documents and Sett...">`:
   \   000000 433A5C446F63          DC8 43H, 3AH, 5CH, 44H, 6FH, 63H, 75H, 6DH
   \   000008 656E74732061          DC8 65H, 6EH, 74H, 73H, 20H, 61H, 6EH, 64H
   \   000010 205365747469          DC8 20H, 53H, 65H, 74H, 74H, 69H, 6EH, 67H
   \   000018 735C41646D69          DC8 73H, 5CH, 41H, 64H, 6DH, 69H, 6EH, 69H
   \   000020 73747261746F          DC8 73H, 74H, 72H, 61H, 74H, 6FH, 72H, 5CH
   \   000028 4465736B746F          DC8 44H, 65H, 73H, 6BH, 74H, 6FH, 70H, 5CH
   \   000030 73746D387331          DC8 73H, 74H, 6DH, 38H, 73H, 31H, 30H, 35H
   \   000038 6B2D636F6E74          DC8 6BH, 2DH, 63H, 6FH, 6EH, 74H, 72H, 6FH
   \   000040 6C6C65725C4C          DC8 6CH, 6CH, 65H, 72H, 5CH, 4CH, 69H, 62H
   \   000048 726172696573          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \   000050 544D38535F53          DC8 54H, 4DH, 38H, 53H, 5FH, 53H, 74H, 64H
   \   000058 506572697068          DC8 50H, 65H, 72H, 69H, 70H, 68H, 5FH, 44H
   \   000060 72697665725C          DC8 72H, 69H, 76H, 65H, 72H, 5CH, 73H, 72H
   \   000068 635C73746D38          DC8 63H, 5CH, 73H, 74H, 6DH, 38H, 73H, 5FH
   \   000070 75617274322E          DC8 75H, 61H, 72H, 74H, 32H, 2EH, 63H, 0
    866          /**
    867            * @}
    868            */
    869          
    870          /**
    871            * @}
    872            */
    873          
    874          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                          Bytes
     --------------                          -----
     UART2_DeInit                              39
     ?Subroutine2                               7
     ?Subroutine0                              12
     UART2_Init                               442
     ?Subroutine3                              12
     UART2_Cmd                                 13
     UART2_ITConfig                           189
     ?Subroutine1                              12
     UART2_IrDAConfig                          24
     UART2_IrDACmd                             24
     UART2_LINBreakDetectionConfig             24
     UART2_LINConfig                          111
     UART2_LINCmd                              24
     UART2_SmartCardCmd                        24
     UART2_SmartCardNACKCmd                    24
     UART2_WakeUpConfig                        32
     UART2_ReceiverWakeUpCmd                   24
     UART2_ReceiveData8                         4
     UART2_ReceiveData9                        25
     UART2_SendData8                            4
     UART2_SendData9                           21
     UART2_SendBreak                            5
     UART2_SetAddress                          36
     UART2_SetGuardTime                         4
     UART2_SetPrescaler                         4
     UART2_GetFlagStatus                      112
     UART2_ClearFlag                           47
     UART2_GetITStatus                        155
     UART2_ClearITPendingBit                   37
     ?<Constant "C:\\Documents and Sett...">  120

 
 1 491 bytes in section .far_func.text
   120 bytes in section .near.rodata
 
 1 491 bytes of CODE  memory
   120 bytes of CONST memory

Errors: none
Warnings: none
