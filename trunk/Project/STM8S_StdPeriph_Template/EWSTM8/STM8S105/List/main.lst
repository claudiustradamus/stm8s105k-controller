###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             08/Sep/2013  23:02:32 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\main.c     #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\main.c"   #
#                    -e -Ohz --debug --code_model medium --data_model medium  #
#                    -o "C:\Documents and Settings\Administrator\Desktop\stm8 #
#                    s105k-controller\Project\STM8S_StdPeriph_Template\EWSTM8 #
#                    \STM8S105\Obj\" --dlib_config "C:\Program Files\IAR      #
#                    Systems\Embedded Workbench 6.0\stm8\LIB\dlstm8mmf.h" -D  #
#                    STM8S105 -lC "C:\Documents and                           #
#                    Settings\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\List\" -lA  #
#                    "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\ST #
#                    M8S105\List\" -I "C:\Documents and                       #
#                    Settings\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\..\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\.. #
#                    \..\..\Libraries\STM8S_StdPeriph_Driver\inc\" --vregs 16 #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\STM #
#                    8S105\List\main.lst                                      #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\STM #
#                    8S105\Obj\main.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\stm8s105k-controller\Project\STM8S_StdPeriph_Template\main.c
      1          /**
      2             LCD PINOUT
      3             PINS  1    2    3   4   5   6   7   8   9   10   11   12   13   14    15    16
      4                  VSS  VDD  VO  RS  R/W  E  DB0 DB1 DB2  DB3  DB4  DB5 DB6  DB7  LED_A LED_K
      5                  GND
      6                                20   22  24                   18    19   21   23
      7                                3    5   7                    1     2    4    6
      8             */
      9          
     10          /** New Device STM8S105K4  */
     11          /* Controller LCD DS1307,DS18B20 */
     12          
     13          /* Daily Allarm ON OFF
     14                                  ON
     15                                  |
     16            First bit set ON      100H:HHHH MMMM:MMMM
     17                                     OFF
     18                                      |
     19            Second bit set OFF       010H:HHHH MMMM:MMMM
     20          
     21          
     22            Daily Allarm ON TimeLong(in minute for 24h 1440 minute 0x5A0)
     23          
     24          
     25          
     26          
     27          */
     28          
     29          
     30          
     31          /* Includes ------------------------------------------------------------------*/
     32          #include "stm8s.h"
     33          #include "stdio.h"
     34          #include "string.h"
     35          /* Private defines -----------------------------------------------------------*/
     36          
     37          /* ================ LCD ======================= */
     38          
     39          #define LCD_GPIO_PIN (GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7)
     40          #define LCD_PORT (GPIOC)
     41          #define LCD_GPIO_COTROL_PIN (GPIO_PIN_3 | GPIO_PIN_1 |GPIO_PIN_2)
     42          #define DATA4 GPIO_PIN_4
     43          #define DATA5 GPIO_PIN_5
     44          #define DATA6 GPIO_PIN_6
     45          #define DATA7 GPIO_PIN_7
     46          #define EN  GPIO_PIN_3
     47          #define RW  GPIO_PIN_1
     48          #define RS  GPIO_PIN_2
     49          #define LCD_EN(x)  x ? GPIO_WriteHigh(LCD_PORT, EN): GPIO_WriteLow(LCD_PORT,EN); //GPIOB->ODR =(GPIOB->ODR &~PIN_EN)|(x ? PIN_EN :0);
     50          #define LCD_RW(x)  x ? GPIO_WriteHigh(LCD_PORT, RW): GPIO_WriteLow(LCD_PORT,RW);
     51          #define LCD_RS(x)  x ? GPIO_WriteHigh(LCD_PORT, RS): GPIO_WriteLow(LCD_PORT,RS);
     52          
     53          #define key_ok    GPIO_PIN_4
     54          #define key_plus  GPIO_PIN_1
     55          #define key_minus GPIO_PIN_2
     56            //DS18B20  Temp Sensor
     57          #define ds18_data GPIO_PIN_2 //2
     58          #define DS18(x)   x ? GPIO_WriteHigh(GPIOD,ds18_data):GPIO_WriteLow(GPIOD,ds18_data);
     59            //Power
     60          #define power_pin GPIO_PIN_3
     61          
     62          
     63          
     64          //EEPROM Address;
     65          #define EEPROM_ADDR 0x4000
     66          #define EEPROM_ADR_STATUSH EEPROM_ADDR + 0
     67          #define EEPROM_ADR_STATUSL EEPROM_ADDR + 1
     68          #define EEPROM_ADR_TIME_ON_HOURS EEPROM_ADDR +2
     69          #define EEPROM_ADR_TIME_ON_MINUTES EEPROM_ADDR +3
     70          #define EEPROM_ADR_TIME_OFF_HOURS EEPROM_ADDR +4
     71          #define EEPROM_ADR_TIME_OFF_MINUTES EEPROM_ADDR +5
     72          
     73          
     74          
     75          #ifdef __GNUC__
     76            /* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf
     77               set to 'Yes') calls __io_putchar() */
     78            #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
     79          #else
     80            #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
     81          #endif /* __GNUC__ */
     82          
     83          
     84          
     85          
     86          #define SpecialSymbol 0x1b //Esc to start message
     87          //#define data_size 20
     88          #define key_time 8000
     89          #define key_time_ok 15000
     90          #define DS_Control  0x10  // Out 1s
     91          #define time_menu 50000
     92          
     93          
     94          
     95          
     96          /* Private variables ---------------------------------------------------------*/

   \                                 In section .near.bss, align 1
     97          volatile u16 timer1;
   \                     timer1:
   \   000000                       DS8 2

   \                                 In section .near.bss, align 1
     98          volatile u16 timer2;
   \                     timer2:
   \   000000                       DS8 2

   \                                 In section .near.bss, align 1
     99          volatile u8 timeout;
   \                     timeout:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    100          volatile u16 adcdata;
   \                     adcdata:
   \   000000                       DS8 2

   \                                 In section .near.bss, align 1
    101          volatile u8 rx_data;
   \                     rx_data:
   \   000000                       DS8 1
    102          //char data[data_size];
    103          //u16  measure[data_size];

   \                                 In section .near.bss, align 1
    104          u8 line_lcd;
   \                     line_lcd:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    105          u8 count;
   \                     count:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    106          u8 seconds;
   \                     seconds:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    107          u8 minutes;
   \                     minutes:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    108          u8 hours;
   \                     hours:
   \   000000                       DS8 1

   \                                 In section .near.data, align 1
    109          u8 days=1;
   \                     days:
   \   000000 01                    DC8 1

   \                                 In section .near.data, align 1
    110          u8 date=1;
   \                     `date`:
   \   000000 01                    DC8 1

   \                                 In section .near.data, align 1
    111          u8 mounts=1;
   \                     mounts:
   \   000000 01                    DC8 1

   \                                 In section .near.bss, align 1
    112          u8 years;
   \                     years:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    113          u8 error;
   \                     error:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    114          u8 temp_flag;
   \                     temp_flag:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    115          u8 temp2;
   \                     temp2:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    116          u8 daily_hour_on;
   \                     daily_hour_on:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    117          u8 daily_minute_on;
   \                     daily_minute_on:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    118          u8 daily_hour_off;
   \                     daily_hour_off:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    119          u8 daily_minute_off;
   \                     daily_minute_off:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    120          u16 daily_long_on;
   \                     daily_long_on:
   \   000000                       DS8 2

   \                                 In section .near.bss, align 1
    121          u16 time_on;
   \                     time_on:
   \   000000                       DS8 2

   \                                 In section .near.bss, align 1
    122          u16 time_off;
   \                     time_off:
   \   000000                       DS8 2

   \                                 In section .near.bss, align 1
    123          u8 ttimer;
   \                     ttimer:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    124          u8 result1;
   \                     result1:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    125          u8 result2;
   \                     result2:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    126          u8 result_old;
   \                     result_old:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    127          u8 l=0;
   \                     l:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    128          u16 status_check;
   \                     status_check:
   \   000000                       DS8 2

   \                                 In section .near.bss, align 1
    129          u8 test1;
   \                     test1:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    130          u8 test2;
   \                     test2:
   \   000000                       DS8 1

   \                                 In section .near.bss, align 1
    131          char line1[40];
   \                     line1:
   \   000000                       DS8 40

   \                                 In section .near.bss, align 1
    132          char string1[10];
   \                     string1:
   \   000000                       DS8 10

   \                                 In section .near.bss, align 1
    133          bool change;
   \                     change:
   \   000000                       DS8 1
    134          
    135          //u8 index=0;

   \                                 In section .near.bss, align 1
    136          float  result;
   \                     result:
   \   000000                       DS8 4

   \                                 In section .near.bss, align 1
    137          int volatile k=0;
   \                     k:
   \   000000                       DS8 2
    138          
    139          
    140           struct   status_reg
    141           {
    142             unsigned on:1;
    143             unsigned timer_on:1;
    144             unsigned daily:1;

   \                                 In section .near.bss, align 1
    145           }  volatile   status  ;
   \                     status:
   \   000000                       DS8 2
    146          
    147          
    148          
    149          
    150          
    151          
    152          
    153          /* Private function prototypes -----------------------------------------------*/
    154          void InitHardware();
    155          void GpioConfiguration();
    156          void InitClk();
    157          void InitAdc();
    158          void InitI2C();
    159          void EEPROM_INIT();
    160          bool ReadDS1307();
    161          //void InitUart();
    162          void InitLcd();
    163          void InitDelayTimer();
    164          void Delay1( u16 Delay);
    165          void Delay2( u16 Delay);
    166          void Delay_us(u16 Delay);
    167          void LCDInstrNibble (u8 Instr);
    168          void LCDInstr(u8 Instr);
    169          void LCDDataOut(u8 data);
    170          void LCD_Busy();
    171          void PulseEnable();
    172          //void SendData();
    173          void SendChar(u8 Char);
    174          //void Send_Hello();
    175          bool Set_Clock();
    176          bool key_ok_on();
    177          bool key_plus_on();
    178          bool key_minus_on();
    179          bool key_ok_plus();
    180          bool Init_DS1307(void);
    181          bool Check_DS1307(void);
    182          bool I2C_Start(void);
    183          bool I2C_WA(u8 address);
    184          bool I2C_WD(u8 data);
    185          bool I2C_RA(u8 address);
    186          bool Set_DS1307();
    187          //bool Set_Delay_Allarm();
    188          bool Set_Timer_On();
    189          bool Set_Timer_Off();
    190          bool Read_Allarm();
    191          bool Read_DS18();
    192          bool DS18_Write( u8 data);
    193          bool DS18_Reset();
    194          bool DS18Set();
    195          u8 temperature();
    196          u8 DS18_Read();
    197          u8 convert_tobcd(u8 data);
    198          u8 I2C_RD(void);
    199          u8 adj(u8 min,u8 max,u8 now);
    200          u8 bcd2hex(u8 bcd);
    201          void Power_On(void);
    202          void Power_Off();
    203          void Save_Status();
    204          void Rotate_Line( char * line);
    205          void Display_Line(char * line);
    206          void Clear_Line1(void);
    207          void Clear_Line2(void);
    208          void Menu(void);
    209          u8 Key_Press(void);
    210          
    211          u16  Average();
    212          
    213          
    214          /* Private functions ---------------------------------------------------------*/
    215          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000 8D000000              CALLF     key_ok_on
   \   000004 A100                  CP        A, #0x0
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine64_0:
   \   000000 AE500F                LDW       X, #0x500f
   \   000003 AC000000              JPF       GPIO_WriteHigh

   \                                 In section .far_func.text, align 1, keep-with-next
    216          void main(void)
    217          {
   \                     main:
   \   000000 3B0000                PUSH      S:?b8
    218              /*High speed internal clock prescaler: 1*/
    219              //CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);
    220          
    221              InitClk();
   \   000003 8D000000              CALLF     InitClk
    222              InitDelayTimer();
   \   000007 8D000000              CALLF     InitDelayTimer
    223              GpioConfiguration();
   \   00000B 8D000000              CALLF     GpioConfiguration
    224              GPIO_WriteLow(GPIOD, power_pin );
   \   00000F 8D000000              CALLF     ?Subroutine27
    225              //InitUart();
    226              enableInterrupts();
   \                     ??CrossCallReturnLabel_80:
   \   000013 9A                    RIM
    227              GPIO_WriteLow(GPIOD,GPIO_PIN_7); //R/W Line Read Mode
   \   000014 A680                  LD        A, #0x80
   \   000016 8D000000              CALLF     ?Subroutine58
    228              InitLcd();
   \                     ??CrossCallReturnLabel_152:
   \   00001A 8D000000              CALLF     InitLcd
    229              //InitAdc();
    230              InitI2C();
   \   00001E 8D000000              CALLF     InitI2C
    231              //Init DS18B20
    232              DS18Set();
   \   000022 8D000000              CALLF     DS18Set
    233              line_lcd=0;
   \   000026 725F0000              CLR       L:line_lcd
    234              if (!Read_DS18())
   \   00002A 8D000000              CALLF     Read_DS18
   \   00002E A100                  CP        A, #0x0
   \   000030 260D                  JRNE      L:??main_0
    235              {
    236               printf("\nDS_Err_I");
   \   000032 AE0000                LDW       X, #`?<Constant "\\nDS_Err_I">`
   \   000035 8D000000              CALLF     printf
    237                while (!key_ok_on());
   \                     ??main_1:
   \   000039 8D000000              CALLF     ?Subroutine18
    238              }
   \                     ??CrossCallReturnLabel_64:
   \   00003D 27FA                  JREQ      L:??main_1
    239          
    240          
    241          
    242          
    243          
    244              //years=bcd2hex(13);
    245              Delay1(1000);
   \                     ??main_0:
   \   00003F AE03E8                LDW       X, #0x3e8
   \   000042 8D000000              CALLF     Delay1
    246               if (!ReadDS1307())
   \   000046 8D000000              CALLF     ReadDS1307
   \   00004A A100                  CP        A, #0x0
   \   00004C 2615                  JRNE      L:??main_2
    247               {
    248                 printf("\n E2:%d",error);
   \   00004E C60000                LD        A, L:error
   \   000051 5F                    CLRW      X
   \   000052 97                    LD        XL, A
   \   000053 89                    PUSHW     X
   \   000054 AE0000                LDW       X, #`?<Constant "\\n E2:%d">`
   \   000057 8D000000              CALLF     printf
   \   00005B 5B02                  ADD       SP, #0x2
    249                 // Reset the CPU: Enable the watchdog and wait until it expires
    250                 IWDG->KR = IWDG_KEY_ENABLE;
   \   00005D 35CC50E0              MOV       L:0x50e0, #0xcc
    251                 while ( 1 );    // Wait until reset occurs from IWDG
   \                     ??main_3:
   \   000061 20FE                  JRA       L:??main_3
    252               }
    253               //Send_Hello();
    254              //line_lcd=0;
    255              //printf("\nHello");
    256          
    257          
    258              if (!Check_DS1307())
   \                     ??main_2:
   \   000063 8D000000              CALLF     Check_DS1307
   \   000067 A100                  CP        A, #0x0
   \   000069 2626                  JRNE      L:??main_4
    259              {
    260                 if (error!=0)
   \   00006B C60000                LD        A, L:error
   \   00006E 2712                  JREQ      L:??main_5
    261                 {
    262                  printf("\n E:%d",error);
   \   000070 5F                    CLRW      X
   \   000071 97                    LD        XL, A
   \   000072 89                    PUSHW     X
   \   000073 AE0000                LDW       X, #`?<Constant "\\n E:%d">`
   \   000076 8D000000              CALLF     printf
   \   00007A 5B02                  ADD       SP, #0x2
    263                   while (!key_ok_on());
   \                     ??main_6:
   \   00007C 8D000000              CALLF     ?Subroutine18
    264          
    265                 }
   \                     ??CrossCallReturnLabel_65:
   \   000080 27FA                  JREQ      L:??main_6
    266               line_lcd=0;
   \                     ??main_5:
   \   000082 725F0000              CLR       L:line_lcd
    267               printf("\nSetClock");
   \   000086 AE0000                LDW       X, #`?<Constant "\\nSetClock">`
   \   000089 8D000000              CALLF     printf
    268                Set_Clock();
   \   00008D 8D000000              CALLF     Set_Clock
    269          
    270              }
    271          
    272                 //Read Status register from eepom and update it
    273                //size=sizeof(status);
    274               //u16 status
    275               *(u16*)(&status)=(u16)(FLASH_ReadByte(EEPROM_ADR_STATUSH)*256)+(u16)FLASH_ReadByte(EEPROM_ADR_STATUSL);
   \                     ??main_4:
   \   000091 AE4000                LDW       X, #0x4000
   \   000094 8D000000              CALLF     ?Subroutine5
   \                     ??CrossCallReturnLabel_7:
   \   000098 B700                  LD        S:?b8, A
   \   00009A AE4001                LDW       X, #0x4001
   \   00009D 8D000000              CALLF     ?Subroutine5
   \                     ??CrossCallReturnLabel_6:
   \   0000A1 905F                  CLRW      Y
   \   0000A3 9097                  LD        YL, A
   \   0000A5 5F                    CLRW      X
   \   0000A6 41                    EXG       A, XL
   \   0000A7 B600                  LD        A, S:?b8
   \   0000A9 41                    EXG       A, XL
   \   0000AA 4F                    CLR       A
   \   0000AB 02                    RLWA      X, A
   \   0000AC 8D000000              CALLF     ??Subroutine67_0
   \                     ??CrossCallReturnLabel_206:
   \   0000B0 CF0000                LDW       L:status, X
    276                status_check = *(u16*)(&status);
   \   0000B3 CE0000                LDW       X, L:status
   \   0000B6 CF0000                LDW       L:status_check, X
    277              //When Start Check for Allarm and computing Daily_long_on
    278               if ( Read_Allarm() == TRUE)
   \   0000B9 8D000000              CALLF     Read_Allarm
   \   0000BD A101                  CP        A, #0x1
   \   0000BF 262A                  JRNE      L:??CrossCallReturnLabel_188
    279               {
    280                 time_on=daily_hour_on*60+daily_minute_on;
   \   0000C1 C60000                LD        A, L:daily_hour_on
   \   0000C4 8D000000              CALLF     ?Subroutine25
   \                     ??CrossCallReturnLabel_211:
   \   0000C8 C60000                LD        A, L:daily_minute_on
   \   0000CB 8D000000              CALLF     ?Subroutine41
   \                     ??CrossCallReturnLabel_207:
   \   0000CF CF0000                LDW       L:time_on, X
    281                 time_off= daily_hour_off*60+daily_minute_off;
   \   0000D2 C60000                LD        A, L:daily_hour_off
   \   0000D5 8D000000              CALLF     ??Subroutine68_0
    282               }
   \                     ??CrossCallReturnLabel_210:
   \   0000D9 C60000                LD        A, L:daily_minute_off
   \   0000DC 8D000000              CALLF     ?Subroutine41
   \                     ??CrossCallReturnLabel_208:
   \   0000E0 CF0000                LDW       L:time_off, X
   \   0000E3 2006                  JRA       L:??CrossCallReturnLabel_188
    283          
    284               //UART2_Cmd(DISABLE);  // Disable UART for the moment
    285          
    286               // Working fuction
    287              //Set_DS1307(13,7,13,34,0);//u8 year ,u8 mounts,u8 hours,u8 minutes,u8 seconds)
    288          
    289          
    290          
    291              // strcpy(line1,"Hello I am here! ");
    292              //  while(1)
    293              //  {
    294              //     Display_Line(line1);
    295              //     Delay2(20000);
    296              //  }
    297              //  while (!key_ok_on());
    298                 //sprintf(line1,"TIMER ON ");
    299              while(1)
    300              {
    301                ADC1_Cmd (ENABLE);
    302          
    303                 GPIO_WriteReverse(GPIOD, (GPIO_Pin_TypeDef)GPIO_PIN_0 );
    304                   Delay2(5000);
    305                   //ttimer++;
    306                 GPIO_WriteReverse(GPIOD, (GPIO_Pin_TypeDef)GPIO_PIN_0 );
    307                   Delay2(5000);
    308          
    309                     //status_check = *(u16*)(&status);
    310          
    311                line_lcd=0;
    312               if (!ReadDS1307())
    313               {
    314                 printf("\n E2:%d",error);
    315                  //restart i2c
    316                // Reset the CPU: Enable the watchdog and wait until it expires
    317                 IWDG->KR = IWDG_KEY_ENABLE;
    318                 while ( 1 );    // Wait until reset occurs from IWDG
    319          
    320               }
    321                 else
    322                   //printf("\n      ");
    323          
    324               //line_lcd=2;
    325               //printf("\n Just Test:%X", timer2);
    326                   //if (rx_data==SpecialSymbol) SendData();
    327                //SendData();
    328          
    329                if (key_ok_on())
    330                {
    331          
    332                  Menu();
    333                  /*
    334                  line_lcd=0;
    335                  printf("\n%02d:%02d:%02d",years,mounts,date);
    336                  status.daily=1; //On Daily timer
    337                  Save_Status();
    338                  Delay2(50000);
    339                  Clear_Line1();
    340                  change=TRUE;
    341                  //Delay2(10000);
    342                  //Delay2(10000);
    343                  */
    344                }
    345          
    346                //if(key_ok_plus()) Set_Delay_Allarm();  //Set Daily Allarm
    347                if(key_plus_on()) Power_On();
    348                if(key_minus_on())Power_Off();
    349          
    350          
    351                //Check for Allarm
    352                    if (status.daily==1)
    353                  {
    354                u16 time_now=hours*60+minutes;
    355                status.on=0;
    356                     u16 time=time_on;
    357                     do
    358                    {
    359                       if(time==time_now)
    360                       {
    361                         status.on=1;
    362                          break ;
    363                       }
    364                        time++;
    365                         if( time==1441) time=0;
    366                    } while(!(time==time_off));
    367                   };
    368          
    369          
    370                      //Read Temperature
    371                  // if( ttimer > 5 )
    372                   //{
    373          
    374          
    375                      result1=temperature();
    376                      if (result_old != result1) change=TRUE;
    377                       //else  change=FALSE;
    378                      result_old=result1;
    379                      result2=0;
    380                      if(result1%2!=0) result2=5;
    381                      result1/=2;
    382          
    383          
    384                     // char result3;
    385                     // ttimer=0;
    386                 //  }
    387          
    388                   //printf("\n%d.%d",result1,result2);
    389          
    390                     //Display
    391                     // line_lcd=0;
    392                     if (status.daily==1)  sprintf(string1,"TIMER ON");
    393                      else sprintf(string1,"TIMER OFF");
    394          
    395          
    396          
    397                       if (change)
    398                       {
    399                      sprintf(line1,"%d.%dC %s ",result1,result2,string1);
    400                         change=FALSE;
    401                       }
    402                      Display_Line(line1);
    403                    line_lcd=1;
    404                    printf("\n%02d:%02d:%02d",hours,minutes,seconds);
    405          
    406          
    407                     if(status.on) GPIO_WriteHigh(GPIOD, power_pin );
   \                     ??main_7:
   \   0000E5 A608                  LD        A, #0x8
   \   0000E7 8D000000              CALLF     ??Subroutine64_0
   \                     ??CrossCallReturnLabel_188:
   \   0000EB A601                  LD        A, #0x1
   \   0000ED 8D000000              CALLF     ADC1_Cmd
   \   0000F1 8D000000              CALLF     ?Subroutine13
   \                     ??CrossCallReturnLabel_37:
   \   0000F5 8D000000              CALLF     ?Subroutine13
   \                     ??CrossCallReturnLabel_36:
   \   0000F9 725F0000              CLR       L:line_lcd
   \   0000FD 8D000000              CALLF     ReadDS1307
   \   000101 A100                  CP        A, #0x0
   \   000103 2615                  JRNE      L:??main_8
   \   000105 C60000                LD        A, L:error
   \   000108 5F                    CLRW      X
   \   000109 97                    LD        XL, A
   \   00010A 89                    PUSHW     X
   \   00010B AE0000                LDW       X, #`?<Constant "\\n E2:%d">`
   \   00010E 8D000000              CALLF     printf
   \   000112 5B02                  ADD       SP, #0x2
   \   000114 35CC50E0              MOV       L:0x50e0, #0xcc
   \                     ??main_9:
   \   000118 20FE                  JRA       L:??main_9
   \                     ??main_8:
   \   00011A 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_66:
   \   00011E 2704                  JREQ      L:??main_10
   \   000120 8D000000              CALLF     Menu
   \                     ??main_10:
   \   000124 8D000000              CALLF     key_plus_on
   \   000128 A100                  CP        A, #0x0
   \   00012A 2704                  JREQ      L:??main_11
   \   00012C 8D000000              CALLF     Power_On
   \                     ??main_11:
   \   000130 8D000000              CALLF     key_minus_on
   \   000134 A100                  CP        A, #0x0
   \   000136 2704                  JREQ      L:??main_12
   \   000138 8D000000              CALLF     Power_Off
   \                     ??main_12:
   \   00013C CE0000                LDW       X, L:status
   \   00013F 9F                    LD        A, XL
   \   000140 A504                  BCP       A, #0x4
   \   000142 2739                  JREQ      L:??main_13
   \   000144 C60000                LD        A, L:hours
   \   000147 8D000000              CALLF     ?Subroutine25
   \                     ??CrossCallReturnLabel_212:
   \   00014B C60000                LD        A, L:minutes
   \   00014E 8D000000              CALLF     ?Subroutine41
   \                     ??CrossCallReturnLabel_209:
   \   000152 BF00                  LDW       S:?w0, X
   \   000154 CE0000                LDW       X, L:status
   \   000157 01                    RRWA      X, A
   \   000158 A4FE                  AND       A, #0xfe
   \   00015A 02                    RLWA      X, A
   \   00015B CF0000                LDW       L:status, X
   \   00015E CE0000                LDW       X, L:time_on
   \                     ??main_14:
   \   000161 B300                  CPW       X, S:?w0
   \   000163 260C                  JRNE      L:??main_15
   \   000165 CE0000                LDW       X, L:status
   \   000168 01                    RRWA      X, A
   \   000169 AA01                  OR        A, #0x1
   \   00016B 02                    RLWA      X, A
   \   00016C CF0000                LDW       L:status, X
   \   00016F 200C                  JRA       L:??main_13
   \                     ??main_15:
   \   000171 5C                    INCW      X
   \   000172 A305A1                CPW       X, #0x5a1
   \   000175 2601                  JRNE      L:??main_16
   \   000177 5F                    CLRW      X
   \                     ??main_16:
   \   000178 C30000                CPW       X, L:time_off
   \   00017B 26E4                  JRNE      L:??main_14
   \                     ??main_13:
   \   00017D 8D000000              CALLF     temperature
   \   000181 C70000                LD        L:result1, A
   \   000184 C10000                CP        A, L:result_old
   \   000187 2704                  JREQ      L:??main_17
   \   000189 35010000              MOV       L:change, #0x1
   \                     ??main_17:
   \   00018D C70000                LD        L:result_old, A
   \   000190 725F0000              CLR       L:result2
   \   000194 7201000004            BTJF      L:result1, #0x0, L:??main_18
   \   000199 35050000              MOV       L:result2, #0x5
   \                     ??main_18:
   \   00019D 44                    SRL       A
   \   00019E C70000                LD        L:result1, A
   \   0001A1 CE0000                LDW       X, L:status
   \   0001A4 9F                    LD        A, XL
   \   0001A5 A504                  BCP       A, #0x4
   \   0001A7 2706                  JREQ      L:??main_19
   \   0001A9 90AE0000              LDW       Y, #`?<Constant "TIMER ON">`
   \   0001AD 2004                  JRA       ??main_20
   \                     ??main_19:
   \   0001AF 90AE0000              LDW       Y, #`?<Constant "TIMER OFF">`
   \                     ??main_20:
   \   0001B3 AE0000                LDW       X, #string1
   \   0001B6 8D000000              CALLF     sprintf
   \   0001BA C60000                LD        A, L:change
   \   0001BD 2720                  JREQ      L:??main_21
   \   0001BF 4B00                  PUSH      #BYTE1(string1)
   \   0001C1 4B00                  PUSH      #BYTE2(string1)
   \   0001C3 C60000                LD        A, L:result2
   \   0001C6 5F                    CLRW      X
   \   0001C7 97                    LD        XL, A
   \   0001C8 89                    PUSHW     X
   \   0001C9 C60000                LD        A, L:result1
   \   0001CC 97                    LD        XL, A
   \   0001CD 89                    PUSHW     X
   \   0001CE 90AE0000              LDW       Y, #`?<Constant "%d.%dC %s ">`
   \   0001D2 AE0000                LDW       X, #line1
   \   0001D5 8D000000              CALLF     sprintf
   \   0001D9 5B06                  ADD       SP, #0x6
   \   0001DB 725F0000              CLR       L:change
   \                     ??main_21:
   \   0001DF AE0000                LDW       X, #line1
   \   0001E2 8D000000              CALLF     Display_Line
   \   0001E6 8D000000              CALLF     ?Subroutine32
   \                     ??CrossCallReturnLabel_90:
   \   0001EA 89                    PUSHW     X
   \   0001EB C60000                LD        A, L:minutes
   \   0001EE 97                    LD        XL, A
   \   0001EF 89                    PUSHW     X
   \   0001F0 C60000                LD        A, L:hours
   \   0001F3 97                    LD        XL, A
   \   0001F4 89                    PUSHW     X
   \   0001F5 AE0000                LDW       X, #`?<Constant "\\n%02d:%02d:%02d">`
   \   0001F8 8D000000              CALLF     printf
   \   0001FC 5B06                  ADD       SP, #0x6
   \   0001FE CE0000                LDW       X, L:status
   \   000201 9F                    LD        A, XL
   \   000202 A501                  BCP       A, #0x1
   \   000204 2703                  JREQ      ??lb_1
   \   000206 CC0000                JP        L:??main_7
    408                       else   GPIO_WriteLow(GPIOD, power_pin );
   \                     ??lb_1:
   \   000209 8D000000              CALLF     ?Subroutine27
    409          
    410          
    411          
    412              }
   \                     ??CrossCallReturnLabel_81:
   \   00020D CC0000                JP        L:??CrossCallReturnLabel_188
    413          
    414          
    415          
    416          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000 9097                  LD        YL, A
   \   000002                       REQUIRE ??Subroutine67_0
   \   000002                       ;               // Fall through to label ??Subroutine67_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine67_0:
   \   000000 90BF00                LDW       S:?w0, Y
   \   000003 72BB0000              ADDW      X, S:?w0
   \   000007 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000 35010000              MOV       L:line_lcd, #0x1
   \   000004 C60000                LD        A, L:seconds
   \   000007 5F                    CLRW      X
   \   000008 97                    LD        XL, A
   \   000009 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000 A608                  LD        A, #0x8
   \   000002 8D000000              CALLF     ?Subroutine58
   \                     ??CrossCallReturnLabel_151:
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000 AE500F                LDW       X, #0x500f
   \   000003 AC000000              JPF       GPIO_WriteLow

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000 905F                  CLRW      Y
   \   000002                       REQUIRE ??Subroutine68_0
   \   000002                       ;               // Fall through to label ??Subroutine68_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine68_0:
   \   000000 9097                  LD        YL, A
   \   000002 AE003C                LDW       X, #0x3c
   \   000005 BF00                  LDW       S:?w0, X
   \   000007 93                    LDW       X, Y
   \   000008 AC000000              JPF       L:?mul16_x_x_w0

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine13:
   \   000000 A601                  LD        A, #0x1
   \   000002 AE500F                LDW       X, #0x500f
   \   000005 8D000000              CALLF     GPIO_WriteReverse
   \   000009 AE1388                LDW       X, #0x1388
   \   00000C AC000000              JPF       Delay2

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine5:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 AC000000              JPF       FLASH_ReadByte
    417          

   \                                 In section .far_func.text, align 1, keep-with-next
    418          void Power_On()
    419          {
    420            status.on=1;
   \                     Power_On:
   \   000000 CE0000                LDW       X, L:status
   \   000003 01                    RRWA      X, A
   \   000004 AA01                  OR        A, #0x1
   \   000006 8D000000              CALLF     ?Subroutine34
    421            status.daily=0; //Off Daily timer
    422            Save_Status();
    423            change=TRUE;
    424          }
   \                     ??CrossCallReturnLabel_95:
   \   00000A 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000 02                    RLWA      X, A
   \   000001 CF0000                LDW       L:status, X
   \   000004 CE0000                LDW       X, L:status
   \   000007 01                    RRWA      X, A
   \   000008 A4FB                  AND       A, #0xfb
   \   00000A 02                    RLWA      X, A
   \   00000B CF0000                LDW       L:status, X
   \   00000E 8D000000              CALLF     Save_Status
   \   000012 35010000              MOV       L:change, #0x1
   \   000016 87                    RETF
    425          

   \                                 In section .far_func.text, align 1, keep-with-next
    426          void Power_Off()
    427          {
    428            status.on=0;
   \                     Power_Off:
   \   000000 CE0000                LDW       X, L:status
   \   000003 01                    RRWA      X, A
   \   000004 A4FE                  AND       A, #0xfe
   \   000006 8D000000              CALLF     ?Subroutine34
    429            status.daily=0; //Off Daily timer
    430            Save_Status();
    431            change=TRUE;
    432          }
   \                     ??CrossCallReturnLabel_94:
   \   00000A 87                    RETF
    433          

   \                                 In section .far_func.text, align 1, keep-with-next
    434          void InitI2C(void)
    435          {
    436             I2C_DeInit();
   \                     InitI2C:
   \   000000 8D000000              CALLF     I2C_DeInit
    437             I2C_Init(10000, 0xA2, I2C_DUTYCYCLE_2, I2C_ACK_CURR, I2C_ADDMODE_7BIT, 2);
   \   000004 35020000              MOV       S:?b6, #0x2
   \   000008 3F00                  CLR       S:?b5
   \   00000A 35010000              MOV       S:?b4, #0x1
   \   00000E 4F                    CLR       A
   \   00000F AE00A2                LDW       X, #0xa2
   \   000012 89                    PUSHW     X
   \   000013 AE2710                LDW       X, #0x2710
   \   000016 BF00                  LDW       S:?w1, X
   \   000018 5F                    CLRW      X
   \   000019 BF00                  LDW       S:?w0, X
   \   00001B 85                    POPW      X
   \   00001C 8D000000              CALLF     I2C_Init
    438             I2C_Cmd(ENABLE);
   \   000020 A601                  LD        A, #0x1
   \   000022 AC000000              JPF       I2C_Cmd
    439          }
    440          

   \                                 In section .far_func.text, align 1, keep-with-next
    441          bool I2C_Start(void)
    442          {
    443             I2C_GenerateSTART(ENABLE);
   \                     I2C_Start:
   \   000000 A601                  LD        A, #0x1
   \   000002 8D000000              CALLF     I2C_GenerateSTART
    444                 timeout=100;
   \   000006 35640000              MOV       L:timeout, #0x64
    445              	while(!(I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT))&&timeout);
   \                     ??I2C_Start_0:
   \   00000A AE0301                LDW       X, #0x301
   \   00000D 8D000000              CALLF     ?Subroutine47
   \                     ??CrossCallReturnLabel_128:
   \   000011 2605                  JRNE      L:??I2C_Start_1
   \   000013 C60000                LD        A, L:timeout
   \   000016 26F2                  JRNE      L:??I2C_Start_0
    446                  if (!timeout)
   \                     ??I2C_Start_1:
   \   000018 C60000                LD        A, L:timeout
   \   00001B 2606                  JRNE      L:??I2C_Start_2
    447                  {
    448                      error=1;
   \   00001D 35010000              MOV       L:error, #0x1
    449                     return FALSE;
   \   000021 4F                    CLR       A
   \   000022 87                    RETF
    450                  }
    451                    else return TRUE;
   \                     ??I2C_Start_2:
   \   000023 A601                  LD        A, #0x1
   \   000025 87                    RETF
    452          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000 8D000000              CALLF     I2C_CheckEvent
   \   000004 A100                  CP        A, #0x0
   \   000006 87                    RETF
    453          

   \                                 In section .far_func.text, align 1, keep-with-next
    454          bool I2C_WA(u8 address)
    455          {
    456            I2C_Send7bitAddress(address, I2C_DIRECTION_TX);
   \                     I2C_WA:
   \   000000 3F00                  CLR       S:?b0
   \   000002 8D000000              CALLF     I2C_Send7bitAddress
    457                 timeout=255;
   \   000006 35FF0000              MOV       L:timeout, #0xff
    458                  while(!(I2C_CheckEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))&&timeout);
   \                     ??I2C_WA_0:
   \   00000A AE0782                LDW       X, #0x782
   \   00000D 8D000000              CALLF     ?Subroutine47
   \                     ??CrossCallReturnLabel_127:
   \   000011 2605                  JRNE      L:??I2C_WA_1
   \   000013 C60000                LD        A, L:timeout
   \   000016 26F2                  JRNE      L:??I2C_WA_0
    459                   if (!timeout)
   \                     ??I2C_WA_1:
   \   000018 C60000                LD        A, L:timeout
   \   00001B 2606                  JRNE      L:??I2C_WA_2
    460                   {
    461                    error=2;
   \   00001D 35020000              MOV       L:error, #0x2
    462                     return FALSE ;
   \   000021 4F                    CLR       A
   \   000022 87                    RETF
    463                   }
    464                    else return TRUE;
   \                     ??I2C_WA_2:
   \   000023 A601                  LD        A, #0x1
   \   000025 87                    RETF
    465          }
    466          

   \                                 In section .far_func.text, align 1, keep-with-next
    467          bool I2C_RA(u8 address)
    468          {
    469            I2C_Send7bitAddress(address, I2C_DIRECTION_RX);
   \                     I2C_RA:
   \   000000 35010000              MOV       S:?b0, #0x1
   \   000004 8D000000              CALLF     I2C_Send7bitAddress
    470                 timeout=255;
   \   000008 35FF0000              MOV       L:timeout, #0xff
    471                  while(!(I2C_CheckEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))&&timeout);
   \                     ??I2C_RA_0:
   \   00000C AE0302                LDW       X, #0x302
   \   00000F 8D000000              CALLF     ?Subroutine47
   \                     ??CrossCallReturnLabel_129:
   \   000013 2605                  JRNE      L:??I2C_RA_1
   \   000015 C60000                LD        A, L:timeout
   \   000018 26F2                  JRNE      L:??I2C_RA_0
    472                   if (!timeout)
   \                     ??I2C_RA_1:
   \   00001A C60000                LD        A, L:timeout
   \   00001D 2606                  JRNE      L:??I2C_RA_2
    473                   {
    474                     error=3;
   \   00001F 35030000              MOV       L:error, #0x3
    475                     return FALSE ;
   \   000023 4F                    CLR       A
   \   000024 87                    RETF
    476                   }
    477                    else return TRUE;
   \                     ??I2C_RA_2:
   \   000025 A601                  LD        A, #0x1
   \   000027 87                    RETF
    478          }
    479          
    480          

   \                                 In section .far_func.text, align 1, keep-with-next
    481          bool I2C_WD(u8 data)
    482          {
    483           I2C_SendData(data);   // set register pointer 00h
   \                     I2C_WD:
   \   000000 8D000000              CALLF     I2C_SendData
    484             timeout=255;
   \   000004 35FF0000              MOV       L:timeout, #0xff
    485             while(!(I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))&&timeout);
   \                     ??I2C_WD_0:
   \   000008 AE0784                LDW       X, #0x784
   \   00000B 8D000000              CALLF     ?Subroutine47
   \                     ??CrossCallReturnLabel_126:
   \   00000F 2605                  JRNE      L:??I2C_WD_1
   \   000011 C60000                LD        A, L:timeout
   \   000014 26F2                  JRNE      L:??I2C_WD_0
    486              if (!timeout)
   \                     ??I2C_WD_1:
   \   000016 C60000                LD        A, L:timeout
   \   000019 2606                  JRNE      L:??I2C_WD_2
    487              {
    488                error=4;
   \   00001B 35040000              MOV       L:error, #0x4
    489                 return FALSE ;
   \   00001F 4F                    CLR       A
   \   000020 87                    RETF
    490              }
    491               else return TRUE;
   \                     ??I2C_WD_2:
   \   000021 A601                  LD        A, #0x1
   \   000023 87                    RETF
    492          }
    493          

   \                                 In section .far_func.text, align 1, keep-with-next
    494          u8 I2C_RD(void)
    495          {
    496           timeout=255;
   \                     I2C_RD:
   \   000000 35FF0000              MOV       L:timeout, #0xff
    497            while( !I2C_GetFlagStatus(I2C_FLAG_TRANSFERFINISHED)&& timeout);
   \                     ??I2C_RD_0:
   \   000004 AE0104                LDW       X, #0x104
   \   000007 8D000000              CALLF     I2C_GetFlagStatus
   \   00000B A100                  CP        A, #0x0
   \   00000D 2605                  JRNE      L:??I2C_RD_1
   \   00000F C60000                LD        A, L:timeout
   \   000012 26F0                  JRNE      L:??I2C_RD_0
    498           //while((!(I2C->SR1 & 0x40))&&timeout);
    499           if (!timeout)
   \                     ??I2C_RD_1:
   \   000014 C60000                LD        A, L:timeout
   \   000017 2606                  JRNE      L:??I2C_RD_2
    500           {
    501             error=5;
   \   000019 35050000              MOV       L:error, #0x5
    502             return FALSE;
   \   00001D 4F                    CLR       A
   \   00001E 87                    RETF
    503           }
    504           u8 data=I2C_ReceiveData();
    505           return data;
   \                     ??I2C_RD_2:
   \   00001F AC000000              JPF       I2C_ReceiveData
    506          }
    507          
    508            /*
    509          bool Init_DS1307(void)
    510          {
    511             // Test DS1307
    512              error=0;
    513              if (!I2C_Start()) return FALSE;
    514              if(!I2C_WA(0xD0)) return FALSE;
    515              if(!I2C_WD(0x00)) return FALSE;
    516              if(!I2C_WD(0x00)) return FALSE;
    517              I2C_GenerateSTOP(ENABLE);
    518          
    519              // timeout=100;  error=4;
    520              ///   while(!(I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))&&timeout);
    521              //    if (!timeout)return FALSE ;
    522               return TRUE;
    523          }
    524             */
    525          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000 4F                    CLR       A
   \   000001                       REQUIRE ??Subroutine66_0
   \   000001                       ;               // Fall through to label ??Subroutine66_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine66_0:
   \   000000 8D000000              CALLF     I2C_WD
   \   000004 A100                  CP        A, #0x0
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000 A6D0                  LD        A, #0xd0
   \   000002 8D000000              CALLF     I2C_WA
   \   000006 A100                  CP        A, #0x0
   \   000008 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000 725F0000              CLR       L:error
   \   000004 8D000000              CALLF     I2C_Start
   \   000008 A100                  CP        A, #0x0
   \   00000A 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
    526          bool  ReadDS1307(void)
    527          {
    528                 error=0;
   \                     ReadDS1307:
   \   000000 8D000000              CALLF     ?Subroutine44
    529                 if (!I2C_Start()) return FALSE;
   \                     ??CrossCallReturnLabel_119:
   \   000004 2602                  JRNE      L:??ReadDS1307_0
   \                     ??ReadDS1307_1:
   \   000006 4F                    CLR       A
   \   000007 87                    RETF
    530                 if(!I2C_WA(0xD0))return FALSE;
   \                     ??ReadDS1307_0:
   \   000008 8D000000              CALLF     ?Subroutine46
   \                     ??CrossCallReturnLabel_125:
   \   00000C 27F8                  JREQ      L:??ReadDS1307_1
    531                 if(!I2C_WD(0x00)) return FALSE;
   \   00000E 8D000000              CALLF     ?Subroutine49
   \                     ??CrossCallReturnLabel_202:
   \   000012 27F2                  JREQ      L:??ReadDS1307_1
    532                 I2C_GenerateSTOP(ENABLE);
   \   000014 8D000000              CALLF     ?Subroutine16
    533                 if (!I2C_Start()) return FALSE;
   \                     ??CrossCallReturnLabel_47:
   \   000018 27EC                  JREQ      L:??ReadDS1307_1
    534                 if(!I2C_RA(0xD0))return FALSE;
   \   00001A A6D0                  LD        A, #0xd0
   \   00001C 8D000000              CALLF     I2C_RA
   \   000020 A100                  CP        A, #0x0
   \   000022 27E2                  JREQ      L:??ReadDS1307_1
    535                 I2C_AcknowledgeConfig(I2C_ACK_CURR);
   \   000024 8D000000              CALLF     ?Subroutine12
    536                 seconds = bcd2hex(I2C_RD());
   \                     ??CrossCallReturnLabel_35:
   \   000028 C70000                LD        L:seconds, A
    537                 I2C_AcknowledgeConfig(I2C_ACK_CURR);
   \   00002B 8D000000              CALLF     ?Subroutine12
    538                 minutes = bcd2hex(I2C_RD());
   \                     ??CrossCallReturnLabel_34:
   \   00002F C70000                LD        L:minutes, A
    539                 I2C_AcknowledgeConfig(I2C_ACK_CURR);
   \   000032 8D000000              CALLF     ?Subroutine12
    540                 hours = bcd2hex(I2C_RD());
   \                     ??CrossCallReturnLabel_33:
   \   000036 C70000                LD        L:hours, A
    541                 I2C_AcknowledgeConfig(I2C_ACK_CURR);
   \   000039 8D000000              CALLF     ?Subroutine12
    542                 days = bcd2hex(I2C_RD());
   \                     ??CrossCallReturnLabel_32:
   \   00003D C70000                LD        L:days, A
    543                 I2C_AcknowledgeConfig(I2C_ACK_CURR);
   \   000040 8D000000              CALLF     ?Subroutine12
    544                 date = bcd2hex(I2C_RD());
   \                     ??CrossCallReturnLabel_31:
   \   000044 C70000                LD        L:`date`, A
    545                 I2C_AcknowledgeConfig(I2C_ACK_CURR);
   \   000047 8D000000              CALLF     ?Subroutine12
    546                 mounts = bcd2hex(I2C_RD());
   \                     ??CrossCallReturnLabel_30:
   \   00004B C70000                LD        L:mounts, A
    547                 I2C_AcknowledgeConfig(I2C_ACK_NONE);
   \   00004E 8D000000              CALLF     ?Subroutine20
    548                   I2C_GenerateSTOP(ENABLE);
    549                    years= bcd2hex(I2C_RD());
   \                     ??CrossCallReturnLabel_67:
   \   000052 8D000000              CALLF     I2C_RD
   \   000056 8D000000              CALLF     bcd2hex
   \   00005A C70000                LD        L:years, A
    550          
    551               //  I2C_AcknowledgeConfig(I2C_ACK_CURR);
    552               //   u8 data1 = I2C_RD();
    553                //Last read byte by I2C slave
    554               //  I2C_AcknowledgeConfig(I2C_ACK_NONE);
    555               //  I2C_GenerateSTOP(ENABLE);
    556               //  temp2= I2C_RD();
    557                 if( seconds & 0x80 )    //if not enable the oscillator ?
   \   00005D 720F000008            BTJF      L:seconds, #0x7, L:??ReadDS1307_2
    558                    {
    559                      seconds &= 0x7f;
   \   000062 721F0000              BRES      L:seconds, #0x7
    560                      Set_DS1307();
   \   000066 8D000000              CALLF     Set_DS1307
    561                    }
    562          
    563                 return TRUE;
   \                     ??ReadDS1307_2:
   \   00006A A601                  LD        A, #0x1
   \   00006C 87                    RETF
    564          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000 4F                    CLR       A
   \   000001 8D000000              CALLF     I2C_AcknowledgeConfig
   \   000005 A601                  LD        A, #0x1
   \   000007 AC000000              JPF       I2C_GenerateSTOP

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000 A601                  LD        A, #0x1
   \   000002 8D000000              CALLF     I2C_GenerateSTOP
   \   000006 8D000000              CALLF     I2C_Start
   \   00000A A100                  CP        A, #0x0
   \   00000C 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000 8D000000              CALLF     ?Subroutine53
   \                     ??CrossCallReturnLabel_141:
   \   000004 AC000000              JPF       bcd2hex

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000 A601                  LD        A, #0x1
   \   000002 8D000000              CALLF     I2C_AcknowledgeConfig
   \   000006 AC000000              JPF       I2C_RD
    565          

   \                                 In section .far_func.text, align 1, keep-with-next
    566          bool Check_DS1307(void)
    567          {
   \                     Check_DS1307:
   \   000000 3B0000                PUSH      S:?b8
    568             // Read  address 0x08 from DS1307 if not 0XAA clock is not set
    569                 error=0;
   \   000003 8D000000              CALLF     ?Subroutine44
    570                 if (!I2C_Start()) return FALSE;
   \                     ??CrossCallReturnLabel_118:
   \   000007 2603                  JRNE      L:??Check_DS1307_0
   \                     ??Check_DS1307_1:
   \   000009 4F                    CLR       A
   \   00000A 2030                  JRA       L:??Check_DS1307_2
    571                 if(!I2C_WA(0xD0)) return FALSE;
   \                     ??Check_DS1307_0:
   \   00000C 8D000000              CALLF     ?Subroutine46
   \                     ??CrossCallReturnLabel_124:
   \   000010 27F7                  JREQ      L:??Check_DS1307_1
    572                 if(!I2C_WD(0x08)) return FALSE;
   \   000012 A608                  LD        A, #0x8
   \   000014 8D000000              CALLF     ??Subroutine66_0
   \                     ??CrossCallReturnLabel_205:
   \   000018 27EF                  JREQ      L:??Check_DS1307_1
    573                 I2C_GenerateSTOP(ENABLE);
   \   00001A 8D000000              CALLF     ?Subroutine16
    574                  //Last read byte by I2C slave
    575                 if (!I2C_Start()) return FALSE;
   \                     ??CrossCallReturnLabel_46:
   \   00001E 27E9                  JREQ      L:??Check_DS1307_1
    576                 if(!I2C_RA(0xD0))return FALSE;
   \   000020 A6D0                  LD        A, #0xd0
   \   000022 8D000000              CALLF     I2C_RA
   \   000026 A100                  CP        A, #0x0
   \   000028 27DF                  JREQ      L:??Check_DS1307_1
    577                 I2C_AcknowledgeConfig(I2C_ACK_CURR);
   \   00002A 8D000000              CALLF     ?Subroutine53
    578                 u8 data = I2C_RD();
   \                     ??CrossCallReturnLabel_142:
   \   00002E B700                  LD        S:?b8, A
    579                 I2C_AcknowledgeConfig(I2C_ACK_NONE);
   \   000030 8D000000              CALLF     ?Subroutine20
    580                 I2C_GenerateSTOP(ENABLE);
    581                 if (data != 0xAA) return FALSE;
   \                     ??CrossCallReturnLabel_68:
   \   000034 B600                  LD        A, S:?b8
   \   000036 A1AA                  CP        A, #0xaa
   \   000038 26CF                  JRNE      L:??Check_DS1307_1
    582                 else return TRUE;
   \   00003A A601                  LD        A, #0x1
   \                     ??Check_DS1307_2:
   \   00003C 320000                POP       S:?b8
   \   00003F 87                    RETF
    583          }
    584          

   \                                 In section .far_func.text, align 1, keep-with-next
    585          bool Set_DS1307()
    586          {
    587                 // convert hex or decimal to bcd format
    588          
    589          
    590                 error=0;
   \                     Set_DS1307:
   \   000000 8D000000              CALLF     ?Subroutine44
    591                 if (!I2C_Start()) return FALSE;
   \                     ??CrossCallReturnLabel_117:
   \   000004 2602                  JRNE      L:??Set_DS1307_0
   \                     ??Set_DS1307_1:
   \   000006 4F                    CLR       A
   \   000007 87                    RETF
    592                 if(!I2C_WA(0xD0)) return FALSE;
   \                     ??Set_DS1307_0:
   \   000008 8D000000              CALLF     ?Subroutine46
   \                     ??CrossCallReturnLabel_123:
   \   00000C 27F8                  JREQ      L:??Set_DS1307_1
    593                 if(!I2C_WD(0x00)) return FALSE;
   \   00000E 8D000000              CALLF     ?Subroutine49
   \                     ??CrossCallReturnLabel_201:
   \   000012 27F2                  JREQ      L:??Set_DS1307_1
    594                 if(!I2C_WD(convert_tobcd(seconds))) return FALSE;
   \   000014 C60000                LD        A, L:seconds
   \   000017 8D000000              CALLF     ?Subroutine48
   \                     ??CrossCallReturnLabel_130:
   \   00001B 27E9                  JREQ      L:??Set_DS1307_1
    595                 if(!I2C_WD(convert_tobcd(minutes))) return FALSE;
   \   00001D C60000                LD        A, L:minutes
   \   000020 8D000000              CALLF     ?Subroutine48
   \                     ??CrossCallReturnLabel_131:
   \   000024 27E0                  JREQ      L:??Set_DS1307_1
    596                 if(!I2C_WD(convert_tobcd(hours))) return FALSE;
   \   000026 C60000                LD        A, L:hours
   \   000029 8D000000              CALLF     ?Subroutine48
   \                     ??CrossCallReturnLabel_132:
   \   00002D 27D7                  JREQ      L:??Set_DS1307_1
    597                 if(!I2C_WD(convert_tobcd(days))) return FALSE;
   \   00002F C60000                LD        A, L:days
   \   000032 8D000000              CALLF     ?Subroutine48
   \                     ??CrossCallReturnLabel_133:
   \   000036 27CE                  JREQ      L:??Set_DS1307_1
    598                 if(!I2C_WD(convert_tobcd(date))) return FALSE;
   \   000038 C60000                LD        A, L:`date`
   \   00003B 8D000000              CALLF     ?Subroutine48
   \                     ??CrossCallReturnLabel_134:
   \   00003F 27C5                  JREQ      L:??Set_DS1307_1
    599                 if(!I2C_WD(convert_tobcd(mounts))) return FALSE;
   \   000041 C60000                LD        A, L:mounts
   \   000044 8D000000              CALLF     ?Subroutine48
   \                     ??CrossCallReturnLabel_135:
   \   000048 27BC                  JREQ      L:??Set_DS1307_1
    600                 if(!I2C_WD(convert_tobcd(years)))return FALSE;
   \   00004A C60000                LD        A, L:years
   \   00004D 8D000000              CALLF     ?Subroutine48
   \                     ??CrossCallReturnLabel_136:
   \   000051 27B3                  JREQ      L:??Set_DS1307_1
    601                 if(!I2C_WD(DS_Control))return FALSE;
   \   000053 A610                  LD        A, #0x10
   \   000055 8D000000              CALLF     ??Subroutine66_0
   \                     ??CrossCallReturnLabel_203:
   \   000059 27AB                  JREQ      L:??Set_DS1307_1
    602                 if(!I2C_WD(0XAA)) return FALSE;  // Byte --> time is set by program
   \   00005B A6AA                  LD        A, #0xaa
   \   00005D 8D000000              CALLF     ??Subroutine66_0
   \                     ??CrossCallReturnLabel_204:
   \   000061 27A3                  JREQ      L:??Set_DS1307_1
    603                 I2C_GenerateSTOP(ENABLE);
   \   000063 A601                  LD        A, #0x1
   \   000065 8D000000              CALLF     I2C_GenerateSTOP
    604          
    605          
    606             return TRUE;
   \   000069 A601                  LD        A, #0x1
   \   00006B 87                    RETF
    607          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000 8D000000              CALLF     convert_tobcd
   \   000004 8D000000              CALLF     I2C_WD
   \   000008 A100                  CP        A, #0x0
   \   00000A 87                    RETF
    608          
    609          

   \                                 In section .far_func.text, align 1, keep-with-next
    610          u8 convert_tobcd(u8 data)
    611          {
   \                     convert_tobcd:
   \   000000 B700                  LD        S:?b1, A
    612             u8 data_second_decimal=data/10;
    613             u8 data_first_decimal=data - 10*data_second_decimal;
    614             data=16*data_second_decimal + data_first_decimal;
    615            return data;
   \   000002 A60A                  LD        A, #0xa
   \   000004 5F                    CLRW      X
   \   000005 01                    RRWA      X, A
   \   000006 B600                  LD        A, S:?b1
   \   000008 02                    RLWA      X, A
   \   000009 62                    DIV       X, A
   \   00000A 41                    EXG       A, XL
   \   00000B B700                  LD        S:?b0, A
   \   00000D A606                  LD        A, #0x6
   \   00000F 97                    LD        XL, A
   \   000010 B600                  LD        A, S:?b0
   \   000012 42                    MUL       X, A
   \   000013 9F                    LD        A, XL
   \   000014 BB00                  ADD       A, S:?b1
   \   000016 87                    RETF
    616          }
    617          

   \                                 In section .far_func.text, align 1, keep-with-next
    618          u8 bcd2hex(u8 bcd)
    619          {
   \                     bcd2hex:
   \   000000 B700                  LD        S:?b1, A
    620            u8 hex=0;
    621            hex=(bcd>>4)*10 +(bcd&0x0f);
    622            bcd=0;
    623            return hex ;
   \   000002 4E                    SWAP      A
   \   000003 A40F                  AND       A, #0xf
   \   000005 350A0000              MOV       S:?b0, #0xa
   \   000009 97                    LD        XL, A
   \   00000A B600                  LD        A, S:?b0
   \   00000C 42                    MUL       X, A
   \   00000D 41                    EXG       A, XL
   \   00000E B700                  LD        S:?b0, A
   \   000010 B600                  LD        A, S:?b1
   \   000012 A40F                  AND       A, #0xf
   \   000014 BB00                  ADD       A, S:?b0
   \   000016 87                    RETF
    624          }
    625          
    626          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000 B700                  LD        S:?b1, A
   \   000002 353B0000              MOV       S:?b0, #0x3b
   \   000006                       REQUIRE ??Subroutine62_0
   \   000006                       ;               // Fall through to label ??Subroutine62_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine62_0:
   \   000000 4F                    CLR       A
   \   000001 AC000000              JPF       adj

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000 8D000000              CALLF     ?Subroutine52
   \                     ??CrossCallReturnLabel_140:
   \   000004 AE03E8                LDW       X, #0x3e8
   \   000007 8D000000              CALLF     Delay1
   \   00000B 725F0000              CLR       L:line_lcd
   \   00000F 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000 A601                  LD        A, #0x1
   \   000002 AC000000              JPF       LCDInstr

   \                                 In section .far_func.text, align 1, keep-with-next
    627          bool Set_Clock()
    628          {
    629              //Clear Display
    630             LCDInstr(0x01);
   \                     Set_Clock:
   \   000000 8D000000              CALLF     ?Subroutine11
    631             Delay1(1000);
    632             line_lcd=0;
    633              printf("\nYears:");
   \                     ??CrossCallReturnLabel_26:
   \   000004 AE0000                LDW       X, #`?<Constant "\\nYears:">`
   \   000007 8D000000              CALLF     printf
    634                do
    635              {
    636               line_lcd=1;
   \                     ??Set_Clock_0:
   \   00000B 8D000000              CALLF     ?Subroutine33
    637               printf("\n%02d:%02d:%02d",years,mounts,date);
   \                     ??CrossCallReturnLabel_91:
   \   00000F 89                    PUSHW     X
   \   000010 C60000                LD        A, L:mounts
   \   000013 97                    LD        XL, A
   \   000014 89                    PUSHW     X
   \   000015 C60000                LD        A, L:years
   \   000018 97                    LD        XL, A
   \   000019 89                    PUSHW     X
   \   00001A AE0000                LDW       X, #`?<Constant "\\n%02d:%02d:%02d">`
   \   00001D 8D000000              CALLF     printf
   \   000021 5B06                  ADD       SP, #0x6
    638                 years=adj(0,99,years);
   \   000023 C60000                LD        A, L:years
   \   000026 B700                  LD        S:?b1, A
   \   000028 35630000              MOV       S:?b0, #0x63
   \   00002C 8D000000              CALLF     ??Subroutine62_0
    639              } while (!key_ok_on());
   \                     ??CrossCallReturnLabel_172:
   \   000030 C70000                LD        L:years, A
   \   000033 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_57:
   \   000037 27D2                  JREQ      L:??Set_Clock_0
    640          
    641               line_lcd=0;
   \   000039 725F0000              CLR       L:line_lcd
    642              printf("\nMounts:");
   \   00003D AE0000                LDW       X, #`?<Constant "\\nMounts:">`
   \   000040 8D000000              CALLF     printf
    643                do
    644              {
    645               line_lcd=1;
   \                     ??Set_Clock_1:
   \   000044 8D000000              CALLF     ?Subroutine33
    646               printf("\n%02d:%02d:%02d",years,mounts,date);
   \                     ??CrossCallReturnLabel_92:
   \   000048 89                    PUSHW     X
   \   000049 C60000                LD        A, L:mounts
   \   00004C 97                    LD        XL, A
   \   00004D 89                    PUSHW     X
   \   00004E C60000                LD        A, L:years
   \   000051 97                    LD        XL, A
   \   000052 89                    PUSHW     X
   \   000053 AE0000                LDW       X, #`?<Constant "\\n%02d:%02d:%02d">`
   \   000056 8D000000              CALLF     printf
   \   00005A 5B06                  ADD       SP, #0x6
    647                 mounts=adj(1,12,mounts);
   \   00005C C60000                LD        A, L:mounts
   \   00005F B700                  LD        S:?b1, A
   \   000061 350C0000              MOV       S:?b0, #0xc
   \   000065 A601                  LD        A, #0x1
   \   000067 8D000000              CALLF     adj
   \   00006B C70000                LD        L:mounts, A
    648              } while (!key_ok_on());
   \   00006E 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_58:
   \   000072 27D0                  JREQ      L:??Set_Clock_1
    649          
    650              LCDInstr(0x01);
   \   000074 8D000000              CALLF     ?Subroutine11
    651               Delay1(1000);
    652                line_lcd=0;
    653              printf("\nDate:");
   \                     ??CrossCallReturnLabel_27:
   \   000078 AE0000                LDW       X, #`?<Constant "\\nDate:">`
   \   00007B 8D000000              CALLF     printf
    654                do
    655              {
    656               line_lcd=1;
   \                     ??Set_Clock_2:
   \   00007F 8D000000              CALLF     ?Subroutine33
    657               printf("\n%02d:%02d:%02d",years,mounts,date);
   \                     ??CrossCallReturnLabel_93:
   \   000083 89                    PUSHW     X
   \   000084 C60000                LD        A, L:mounts
   \   000087 97                    LD        XL, A
   \   000088 89                    PUSHW     X
   \   000089 C60000                LD        A, L:years
   \   00008C 97                    LD        XL, A
   \   00008D 89                    PUSHW     X
   \   00008E AE0000                LDW       X, #`?<Constant "\\n%02d:%02d:%02d">`
   \   000091 8D000000              CALLF     printf
   \   000095 5B06                  ADD       SP, #0x6
    658                 date=adj(1,31,date);
   \   000097 C60000                LD        A, L:`date`
   \   00009A B700                  LD        S:?b1, A
   \   00009C 351F0000              MOV       S:?b0, #0x1f
   \   0000A0 A601                  LD        A, #0x1
   \   0000A2 8D000000              CALLF     adj
   \   0000A6 C70000                LD        L:`date`, A
    659              } while (!key_ok_on());
   \   0000A9 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_59:
   \   0000AD 27D0                  JREQ      L:??Set_Clock_2
    660          
    661          
    662              //Clear Display
    663             LCDInstr(0x01);
   \   0000AF 8D000000              CALLF     ?Subroutine11
    664             Delay1(1000);
    665             line_lcd=0;
    666              printf("\nDays:");
   \                     ??CrossCallReturnLabel_28:
   \   0000B3 AE0000                LDW       X, #`?<Constant "\\nDays:">`
   \   0000B6 8D000000              CALLF     printf
    667                do
    668              {
    669                line_lcd=1;
   \                     ??Set_Clock_3:
   \   0000BA 35010000              MOV       L:line_lcd, #0x1
    670               printf("\n%02d",days);
   \   0000BE C60000                LD        A, L:days
   \   0000C1 5F                    CLRW      X
   \   0000C2 97                    LD        XL, A
   \   0000C3 89                    PUSHW     X
   \   0000C4 AE0000                LDW       X, #`?<Constant "\\n%02d">`
   \   0000C7 8D000000              CALLF     printf
   \   0000CB 5B02                  ADD       SP, #0x2
    671                 days=adj(1,7,days);
   \   0000CD C60000                LD        A, L:days
   \   0000D0 B700                  LD        S:?b1, A
   \   0000D2 35070000              MOV       S:?b0, #0x7
   \   0000D6 A601                  LD        A, #0x1
   \   0000D8 8D000000              CALLF     adj
   \   0000DC C70000                LD        L:days, A
    672              } while (!key_ok_on());
   \   0000DF 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_60:
   \   0000E3 27D5                  JREQ      L:??Set_Clock_3
    673          
    674          
    675          
    676             //Clear Display
    677             LCDInstr(0x01);
   \   0000E5 8D000000              CALLF     ?Subroutine11
    678             Delay1(1000);
    679             line_lcd=0;
    680              printf("\nHours:");
   \                     ??CrossCallReturnLabel_29:
   \   0000E9 AE0000                LDW       X, #`?<Constant "\\nHours:">`
   \   0000EC 8D000000              CALLF     printf
    681                do
    682              {
    683                line_lcd=1;
   \                     ??Set_Clock_4:
   \   0000F0 8D000000              CALLF     ?Subroutine32
    684               printf("\n%02d:%02d:%02d",hours,minutes,seconds);
   \                     ??CrossCallReturnLabel_87:
   \   0000F4 89                    PUSHW     X
   \   0000F5 C60000                LD        A, L:minutes
   \   0000F8 97                    LD        XL, A
   \   0000F9 89                    PUSHW     X
   \   0000FA C60000                LD        A, L:hours
   \   0000FD 97                    LD        XL, A
   \   0000FE 89                    PUSHW     X
   \   0000FF AE0000                LDW       X, #`?<Constant "\\n%02d:%02d:%02d">`
   \   000102 8D000000              CALLF     printf
   \   000106 5B06                  ADD       SP, #0x6
    685                 hours=adj(0,23,hours);
   \   000108 C60000                LD        A, L:hours
   \   00010B B700                  LD        S:?b1, A
   \   00010D 35170000              MOV       S:?b0, #0x17
   \   000111 8D000000              CALLF     ??Subroutine62_0
    686              } while (!key_ok_on());
   \                     ??CrossCallReturnLabel_171:
   \   000115 C70000                LD        L:hours, A
   \   000118 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_61:
   \   00011C 27D2                  JREQ      L:??Set_Clock_4
    687          
    688               line_lcd=0;
   \   00011E 725F0000              CLR       L:line_lcd
    689               printf("\nMinutes:");
   \   000122 AE0000                LDW       X, #`?<Constant "\\nMinutes:">`
   \   000125 8D000000              CALLF     printf
    690                do
    691              {
    692                line_lcd=1;
   \                     ??Set_Clock_5:
   \   000129 8D000000              CALLF     ?Subroutine32
    693               printf("\n%02d:%02d:%02d",hours,minutes,seconds);
   \                     ??CrossCallReturnLabel_88:
   \   00012D 89                    PUSHW     X
   \   00012E C60000                LD        A, L:minutes
   \   000131 97                    LD        XL, A
   \   000132 89                    PUSHW     X
   \   000133 C60000                LD        A, L:hours
   \   000136 97                    LD        XL, A
   \   000137 89                    PUSHW     X
   \   000138 AE0000                LDW       X, #`?<Constant "\\n%02d:%02d:%02d">`
   \   00013B 8D000000              CALLF     printf
   \   00013F 5B06                  ADD       SP, #0x6
    694                 minutes=adj(0,59,minutes);
   \   000141 C60000                LD        A, L:minutes
   \   000144 8D000000              CALLF     ?Subroutine19
    695              } while (!key_ok_on());
   \                     ??CrossCallReturnLabel_176:
   \   000148 C70000                LD        L:minutes, A
   \   00014B 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_62:
   \   00014F 27D8                  JREQ      L:??Set_Clock_5
    696          
    697              line_lcd=0;
   \   000151 725F0000              CLR       L:line_lcd
    698              printf("\nSeconds:");
   \   000155 AE0000                LDW       X, #`?<Constant "\\nSeconds:">`
   \   000158 8D000000              CALLF     printf
    699              do
    700              {
    701                line_lcd=1;
   \                     ??Set_Clock_6:
   \   00015C 8D000000              CALLF     ?Subroutine32
    702               printf("\n%02d:%02d:%02d",hours,minutes,seconds);
   \                     ??CrossCallReturnLabel_89:
   \   000160 89                    PUSHW     X
   \   000161 C60000                LD        A, L:minutes
   \   000164 97                    LD        XL, A
   \   000165 89                    PUSHW     X
   \   000166 C60000                LD        A, L:hours
   \   000169 97                    LD        XL, A
   \   00016A 89                    PUSHW     X
   \   00016B AE0000                LDW       X, #`?<Constant "\\n%02d:%02d:%02d">`
   \   00016E 8D000000              CALLF     printf
   \   000172 5B06                  ADD       SP, #0x6
    703                 seconds=adj(0,59,seconds);
   \   000174 C60000                LD        A, L:seconds
   \   000177 8D000000              CALLF     ?Subroutine19
    704              } while (!key_ok_on());
   \                     ??CrossCallReturnLabel_175:
   \   00017B C70000                LD        L:seconds, A
   \   00017E 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_63:
   \   000182 27D8                  JREQ      L:??Set_Clock_6
    705          
    706                // Set parameter to DS1307 + time byte
    707                Set_DS1307();
   \   000184 8D000000              CALLF     Set_DS1307
    708          
    709                //bool k=Check_DS1307();
    710          
    711            return TRUE;
   \   000188 A601                  LD        A, #0x1
   \   00018A 87                    RETF
    712          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000 35010000              MOV       L:line_lcd, #0x1
   \   000004 C60000                LD        A, L:`date`
   \   000007 5F                    CLRW      X
   \   000008 97                    LD        XL, A
   \   000009 87                    RETF
    713          
    714          

   \                                 In section .far_func.text, align 1, keep-with-next
    715          u8 adj(u8 min,u8 max,u8 now)
    716          {
   \                     adj:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 B700                  LD        S:?b10, A
   \   000009 450000                MOV       S:?b8, S:?b0
   \   00000C 450000                MOV       S:?b9, S:?b1
    717             u8 adj=now;
    718             if (key_plus_on()) adj ++;
   \   00000F 8D000000              CALLF     key_plus_on
   \   000013 A100                  CP        A, #0x0
   \   000015 2705                  JREQ      L:??adj_0
   \   000017 B600                  LD        A, S:?b9
   \   000019 4C                    INC       A
   \   00001A B700                  LD        S:?b9, A
    719             if (adj >max) adj = min;
   \                     ??adj_0:
   \   00001C B600                  LD        A, S:?b8
   \   00001E B100                  CP        A, S:?b9
   \   000020 2403                  JRNC      L:??adj_1
   \   000022 450000                MOV       S:?b9, S:?b10
    720             if (key_minus_on()) adj --;
   \                     ??adj_1:
   \   000025 8D000000              CALLF     key_minus_on
   \   000029 A100                  CP        A, #0x0
   \   00002B 2705                  JREQ      L:??adj_2
   \   00002D B600                  LD        A, S:?b9
   \   00002F 4A                    DEC       A
   \   000030 B700                  LD        S:?b9, A
    721             if ( adj == 255) adj=max;
   \                     ??adj_2:
   \   000032 B600                  LD        A, S:?b9
   \   000034 A1FF                  CP        A, #0xff
   \   000036 2603                  JRNE      L:??adj_3
   \   000038 450000                MOV       S:?b9, S:?b8
    722             if (adj < min) adj=max;
   \                     ??adj_3:
   \   00003B B600                  LD        A, S:?b9
   \   00003D B100                  CP        A, S:?b10
   \   00003F 2403                  JRNC      L:??adj_4
   \   000041 450000                MOV       S:?b9, S:?b8
    723             return adj ;
   \                     ??adj_4:
   \   000044 B600                  LD        A, S:?b9
   \   000046 320000                POP       S:?b10
   \   000049 AC000000              JPF       L:?epilogue_w4
    724          }
    725          
    726          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000 AE5019                LDW       X, #0x5019
   \   000003 AC000000              JPF       GPIO_ReadInputData

   \                                 In section .far_func.text, align 1
    727          bool key_ok_on()
    728          {
    729            //Read Key OK
    730            if (!(GPIO_ReadInputData(GPIOF)& key_ok))
   \                     key_ok_on:
   \   000000 8D000000              CALLF     ?Subroutine54
   \                     ??CrossCallReturnLabel_145:
   \   000004 A510                  BCP       A, #0x10
   \   000006 261F                  JRNE      L:??key_ok_on_0
    731             {
    732               timer2=0;  // Key must be push for timer2 time
   \   000008 5F                    CLRW      X
   \   000009 CF0000                LDW       L:timer2, X
    733                while((timer2 < key_time_ok) && !(GPIO_ReadInputData(GPIOF)& key_ok) );;
   \                     ??key_ok_on_1:
   \   00000C CE0000                LDW       X, L:timer2
   \   00000F A33A98                CPW       X, #0x3a98
   \   000012 2408                  JRNC      L:??key_ok_on_2
   \   000014 8D000000              CALLF     ?Subroutine54
   \                     ??CrossCallReturnLabel_144:
   \   000018 A510                  BCP       A, #0x10
   \   00001A 27F0                  JREQ      L:??key_ok_on_1
    734                  if (timer2>=key_time_ok) return TRUE;
   \                     ??key_ok_on_2:
   \   00001C CE0000                LDW       X, L:timer2
   \   00001F A33A98                CPW       X, #0x3a98
   \   000022 2503                  JRC       L:??key_ok_on_0
   \   000024 A601                  LD        A, #0x1
   \   000026 87                    RETF
    735             }
    736          
    737            return FALSE;
   \                     ??key_ok_on_0:
   \   000027 4F                    CLR       A
   \   000028 87                    RETF
    738          }
    739          

   \                                 In section .far_func.text, align 1
    740           bool key_plus_on()
    741          {
    742            //Read Key OK
    743              if (!(GPIO_ReadInputData(GPIOA)& key_plus))
   \                     key_plus_on:
   \   000000 8D000000              CALLF     ?Subroutine7
   \                     ??CrossCallReturnLabel_15:
   \   000004 A502                  BCP       A, #0x2
   \   000006 261B                  JRNE      L:??key_plus_on_0
    744               {
    745               timer2=0;  // Key must be push for timer2 time
   \   000008 5F                    CLRW      X
   \   000009 CF0000                LDW       L:timer2, X
    746                while((timer2 < key_time) && !(GPIO_ReadInputData(GPIOA)& key_plus) );;
   \                     ??key_plus_on_1:
   \   00000C 8D000000              CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_40:
   \   000010 2408                  JRNC      L:??key_plus_on_2
   \   000012 8D000000              CALLF     ?Subroutine7
   \                     ??CrossCallReturnLabel_14:
   \   000016 A502                  BCP       A, #0x2
   \   000018 27F2                  JREQ      L:??key_plus_on_1
    747                  if (timer2>=key_time) return TRUE;
   \                     ??key_plus_on_2:
   \   00001A 8D000000              CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_41:
   \   00001E 2503                  JRC       L:??key_plus_on_0
   \   000020 A601                  LD        A, #0x1
   \   000022 87                    RETF
    748               }
    749          
    750            return FALSE;
   \                     ??key_plus_on_0:
   \   000023 4F                    CLR       A
   \   000024 87                    RETF
    751          }

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine14:
   \   000000 CE0000                LDW       X, L:timer2
   \   000003 A31F40                CPW       X, #0x1f40
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine7:
   \   000000 AE5000                LDW       X, #0x5000
   \   000003 AC000000              JPF       GPIO_ReadInputData
    752          

   \                                 In section .far_func.text, align 1
    753            bool key_minus_on()
    754          {
    755            //Read Key OK
    756             if (!(GPIO_ReadInputData(GPIOA)& key_minus))
   \                     key_minus_on:
   \   000000 8D000000              CALLF     ?Subroutine7
   \                     ??CrossCallReturnLabel_17:
   \   000004 A504                  BCP       A, #0x4
   \   000006 261B                  JRNE      L:??key_minus_on_0
    757               {
    758               timer2=0;  // Key must be push for timer2 time
   \   000008 5F                    CLRW      X
   \   000009 CF0000                LDW       L:timer2, X
    759                while((timer2 < key_time) && !(GPIO_ReadInputData(GPIOA)& key_minus) );;
   \                     ??key_minus_on_1:
   \   00000C 8D000000              CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_38:
   \   000010 2408                  JRNC      L:??key_minus_on_2
   \   000012 8D000000              CALLF     ?Subroutine7
   \                     ??CrossCallReturnLabel_16:
   \   000016 A504                  BCP       A, #0x4
   \   000018 27F2                  JREQ      L:??key_minus_on_1
    760                  if (timer2>=key_time) return TRUE;
   \                     ??key_minus_on_2:
   \   00001A 8D000000              CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_39:
   \   00001E 2503                  JRC       L:??key_minus_on_0
   \   000020 A601                  LD        A, #0x1
   \   000022 87                    RETF
    761               }
    762          
    763            return FALSE;
   \                     ??key_minus_on_0:
   \   000023 4F                    CLR       A
   \   000024 87                    RETF
    764          }
    765          
    766          

   \                                 In section .far_func.text, align 1, keep-with-next
    767          bool  key_ok_plus()
    768          {
   \                     key_ok_plus:
   \   000000 3B0000                PUSH      S:?b8
    769            if (!((GPIO_ReadInputData(GPIOF)& key_ok)|(GPIO_ReadInputData(GPIOA)& key_plus)))
   \   000003 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_0:
   \   000007 261A                  JRNE      L:??key_ok_plus_0
    770            {
    771                timer2=0;  // Key must be push for timer2 time
   \   000009 5F                    CLRW      X
   \   00000A CF0000                LDW       L:timer2, X
    772                while((timer2 < key_time) && !((GPIO_ReadInputData(GPIOF)& key_ok)|(GPIO_ReadInputData(GPIOA)& key_plus)));;
   \                     ??key_ok_plus_1:
   \   00000D 8D000000              CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_42:
   \   000011 2406                  JRNC      L:??key_ok_plus_2
   \   000013 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_1:
   \   000017 27F4                  JREQ      L:??key_ok_plus_1
    773                 if (timer2>=key_time) return TRUE;
   \                     ??key_ok_plus_2:
   \   000019 8D000000              CALLF     ?Subroutine14
   \                     ??CrossCallReturnLabel_43:
   \   00001D 2504                  JRC       L:??key_ok_plus_0
   \   00001F A601                  LD        A, #0x1
   \   000021 2001                  JRA       L:??key_ok_plus_3
    774            }
    775          
    776           return FALSE;
   \                     ??key_ok_plus_0:
   \   000023 4F                    CLR       A
   \                     ??key_ok_plus_3:
   \   000024 320000                POP       S:?b8
   \   000027 87                    RETF
    777          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000 8D000000              CALLF     ?Subroutine54
   \                     ??CrossCallReturnLabel_143:
   \   000004 B700                  LD        S:?b8, A
   \   000006 AE5000                LDW       X, #0x5000
   \   000009 8D000000              CALLF     GPIO_ReadInputData
   \   00000D A402                  AND       A, #0x2
   \   00000F 88                    PUSH      A
   \   000010 B600                  LD        A, S:?b8
   \   000012 A410                  AND       A, #0x10
   \   000014 B700                  LD        S:?b1, A
   \   000016 84                    POP       A
   \   000017 BA00                  OR        A, S:?b1
   \   000019 87                    RETF
    778          
    779          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000 CE0000                LDW       X, L:status
   \   000003 01                    RRWA      X, A
   \   000004 AA04                  OR        A, #0x4
   \   000006 02                    RLWA      X, A
   \   000007 CF0000                LDW       L:status, X
   \   00000A                       REQUIRE ??Subroutine61_0
   \   00000A                       ;               // Fall through to label ??Subroutine61_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine61_0:
   \   000000 8D000000              CALLF     EEPROM_INIT
   \   000004 CE0000                LDW       X, L:status
   \   000007 4F                    CLR       A
   \   000008 01                    RRWA      X, A
   \   000009 9F                    LD        A, XL
   \   00000A AE4000                LDW       X, #0x4000
   \   00000D 8D000000              CALLF     ?Subroutine50
   \                     ??CrossCallReturnLabel_170:
   \   000011 CE0000                LDW       X, L:status
   \   000014 9F                    LD        A, XL
   \   000015 AE4001                LDW       X, #0x4001
   \   000018 8D000000              CALLF     ?Subroutine50
   \                     ??CrossCallReturnLabel_169:
   \   00001C 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
    780          bool Set_Timer_On()
    781          {
    782          
    783             //clr
    784             LCDInstr(0x01);
   \                     Set_Timer_On:
   \   000000 8D000000              CALLF     ?Subroutine11
    785             Delay1(1000);
    786             line_lcd=0;
    787             printf("\nH On:");
   \                     ??CrossCallReturnLabel_24:
   \   000004 AE0000                LDW       X, #`?<Constant "\\nH On:">`
   \   000007 8D000000              CALLF     printf
    788            do
    789              {
    790               line_lcd=1;
   \                     ??Set_Timer_On_0:
   \   00000B 35010000              MOV       L:line_lcd, #0x1
    791               printf("\n%02d:%02d",daily_hour_on,daily_minute_on);
   \   00000F C60000                LD        A, L:daily_minute_on
   \   000012 5F                    CLRW      X
   \   000013 97                    LD        XL, A
   \   000014 89                    PUSHW     X
   \   000015 C60000                LD        A, L:daily_hour_on
   \   000018 97                    LD        XL, A
   \   000019 89                    PUSHW     X
   \   00001A AE0000                LDW       X, #`?<Constant "\\n%02d:%02d">`
   \   00001D 8D000000              CALLF     printf
   \   000021 5B04                  ADD       SP, #0x4
    792                 daily_hour_on=adj(0,23,daily_hour_on);
   \   000023 C60000                LD        A, L:daily_hour_on
   \   000026 B700                  LD        S:?b1, A
   \   000028 35170000              MOV       S:?b0, #0x17
   \   00002C 8D000000              CALLF     ??Subroutine62_0
    793              } while (!key_ok_on());
   \                     ??CrossCallReturnLabel_173:
   \   000030 C70000                LD        L:daily_hour_on, A
   \   000033 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_55:
   \   000037 27D2                  JREQ      L:??Set_Timer_On_0
    794          
    795             LCDInstr(0x01);
   \   000039 8D000000              CALLF     ?Subroutine11
    796             Delay1(1000);
    797             line_lcd=0;
    798             printf("\nMin On:");
   \                     ??CrossCallReturnLabel_25:
   \   00003D AE0000                LDW       X, #`?<Constant "\\nMin On:">`
   \   000040 8D000000              CALLF     printf
    799            do
    800              {
    801               line_lcd=1;
   \                     ??Set_Timer_On_1:
   \   000044 35010000              MOV       L:line_lcd, #0x1
    802               printf("\n%02d:%02d",daily_hour_on,daily_minute_on);
   \   000048 C60000                LD        A, L:daily_minute_on
   \   00004B 5F                    CLRW      X
   \   00004C 97                    LD        XL, A
   \   00004D 89                    PUSHW     X
   \   00004E C60000                LD        A, L:daily_hour_on
   \   000051 97                    LD        XL, A
   \   000052 89                    PUSHW     X
   \   000053 AE0000                LDW       X, #`?<Constant "\\n%02d:%02d">`
   \   000056 8D000000              CALLF     printf
   \   00005A 5B04                  ADD       SP, #0x4
    803                 daily_minute_on=adj(0,59,daily_minute_on);
   \   00005C C60000                LD        A, L:daily_minute_on
   \   00005F 8D000000              CALLF     ?Subroutine19
    804              } while (!key_ok_on());
   \                     ??CrossCallReturnLabel_177:
   \   000063 C70000                LD        L:daily_minute_on, A
   \   000066 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_56:
   \   00006A 27D8                  JREQ      L:??Set_Timer_On_1
    805          
    806             //Save data to eeprom
    807               status.daily=1;
   \   00006C 8D000000              CALLF     ?Subroutine1
    808               EEPROM_INIT();
    809              //u8 temp =*(u8*)(&status);
    810              // FLASH_ProgramByte(EEPROM_ADR_STATUS,*(u8*)(&status)); //save Status to eeprom
    811               FLASH_ProgramByte(EEPROM_ADR_STATUSH,(u8)(*(u16*)(&status)>>8));
    812               FLASH_ProgramByte(EEPROM_ADR_STATUSL,(u8)(*(u16*)(&status)));
    813               FLASH_ProgramByte(EEPROM_ADR_TIME_ON_HOURS,daily_hour_on);
   \                     ??CrossCallReturnLabel_165:
   \   000070 C60000                LD        A, L:daily_hour_on
   \   000073 AE4002                LDW       X, #0x4002
   \   000076 8D000000              CALLF     ?Subroutine35
    814               FLASH_ProgramByte(EEPROM_ADR_TIME_ON_MINUTES,daily_minute_on);
   \                     ??CrossCallReturnLabel_97:
   \   00007A C60000                LD        A, L:daily_minute_on
   \   00007D AE4003                LDW       X, #0x4003
   \   000080 8D000000              CALLF     ?Subroutine6
    815               FLASH_Lock(FLASH_MEMTYPE_DATA); //Locking  Flash Data
    816          
    817             return TRUE;
   \                     ??CrossCallReturnLabel_13:
   \   000084 87                    RETF
    818          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000 8D000000              CALLF     ?Subroutine50
   \                     ??CrossCallReturnLabel_168:
   \   000004 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 AC000000              JPF       FLASH_ProgramByte

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000 8D000000              CALLF     ?Subroutine50
   \                     ??CrossCallReturnLabel_167:
   \   000004 A6F7                  LD        A, #0xf7
   \   000006 8D000000              CALLF     FLASH_Lock
   \   00000A A601                  LD        A, #0x1
   \   00000C 87                    RETF
    819          

   \                                 In section .far_func.text, align 1, keep-with-next
    820          bool Set_Timer_Off()
    821          {
    822          
    823              LCDInstr(0x01);
   \                     Set_Timer_Off:
   \   000000 8D000000              CALLF     ?Subroutine11
    824              Delay1(1000);
    825              line_lcd=0;
    826              printf("\nH Off:");
   \                     ??CrossCallReturnLabel_22:
   \   000004 AE0000                LDW       X, #`?<Constant "\\nH Off:">`
   \   000007 8D000000              CALLF     printf
    827            do
    828              {
    829               line_lcd=1;
   \                     ??Set_Timer_Off_0:
   \   00000B 35010000              MOV       L:line_lcd, #0x1
    830               printf("\n%02d:%02d",daily_hour_off,daily_minute_off);
   \   00000F C60000                LD        A, L:daily_minute_off
   \   000012 5F                    CLRW      X
   \   000013 97                    LD        XL, A
   \   000014 89                    PUSHW     X
   \   000015 C60000                LD        A, L:daily_hour_off
   \   000018 97                    LD        XL, A
   \   000019 89                    PUSHW     X
   \   00001A AE0000                LDW       X, #`?<Constant "\\n%02d:%02d">`
   \   00001D 8D000000              CALLF     printf
   \   000021 5B04                  ADD       SP, #0x4
    831                 daily_hour_off=adj(0,23,daily_hour_off);
   \   000023 C60000                LD        A, L:daily_hour_off
   \   000026 B700                  LD        S:?b1, A
   \   000028 35170000              MOV       S:?b0, #0x17
   \   00002C 8D000000              CALLF     ??Subroutine62_0
    832              } while (!key_ok_on());
   \                     ??CrossCallReturnLabel_174:
   \   000030 C70000                LD        L:daily_hour_off, A
   \   000033 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_53:
   \   000037 27D2                  JREQ      L:??Set_Timer_Off_0
    833          
    834            LCDInstr(0x01);
   \   000039 8D000000              CALLF     ?Subroutine11
    835             Delay1(1000);
    836             line_lcd=0;
    837             printf("\nMin Off:");
   \                     ??CrossCallReturnLabel_23:
   \   00003D AE0000                LDW       X, #`?<Constant "\\nMin Off:">`
   \   000040 8D000000              CALLF     printf
    838            do
    839              {
    840               line_lcd=1;
   \                     ??Set_Timer_Off_1:
   \   000044 35010000              MOV       L:line_lcd, #0x1
    841               printf("\n%02d:%02d",daily_hour_off,daily_minute_off);
   \   000048 C60000                LD        A, L:daily_minute_off
   \   00004B 5F                    CLRW      X
   \   00004C 97                    LD        XL, A
   \   00004D 89                    PUSHW     X
   \   00004E C60000                LD        A, L:daily_hour_off
   \   000051 97                    LD        XL, A
   \   000052 89                    PUSHW     X
   \   000053 AE0000                LDW       X, #`?<Constant "\\n%02d:%02d">`
   \   000056 8D000000              CALLF     printf
   \   00005A 5B04                  ADD       SP, #0x4
    842                 daily_minute_off=adj(0,59,daily_minute_off);
   \   00005C C60000                LD        A, L:daily_minute_off
   \   00005F 8D000000              CALLF     ?Subroutine19
    843              } while (!key_ok_on());
   \                     ??CrossCallReturnLabel_178:
   \   000063 C70000                LD        L:daily_minute_off, A
   \   000066 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_54:
   \   00006A 27D8                  JREQ      L:??Set_Timer_Off_1
    844          
    845            //Save data to eeprom
    846               status.daily=1;
   \   00006C 8D000000              CALLF     ?Subroutine1
    847               EEPROM_INIT();
    848              //u8 temp =*(u8*)(&status);
    849              // FLASH_ProgramByte(EEPROM_ADR_STATUS,*(u8*)(&status)); //save Status to eeprom
    850               FLASH_ProgramByte(EEPROM_ADR_STATUSH,(u8)(*(u16*)(&status)>>8));
    851               FLASH_ProgramByte(EEPROM_ADR_STATUSL,(u8)(*(u16*)(&status)));
    852               FLASH_ProgramByte(EEPROM_ADR_TIME_OFF_HOURS,daily_hour_off);
   \                     ??CrossCallReturnLabel_164:
   \   000070 C60000                LD        A, L:daily_hour_off
   \   000073 AE4004                LDW       X, #0x4004
   \   000076 8D000000              CALLF     ?Subroutine35
    853               FLASH_ProgramByte(EEPROM_ADR_TIME_OFF_MINUTES,daily_minute_off);
   \                     ??CrossCallReturnLabel_96:
   \   00007A C60000                LD        A, L:daily_minute_off
   \   00007D AE4005                LDW       X, #0x4005
   \   000080 8D000000              CALLF     ?Subroutine6
    854               FLASH_Lock(FLASH_MEMTYPE_DATA); //Locking  Flash Data
    855          
    856               return TRUE;
   \                     ??CrossCallReturnLabel_12:
   \   000084 87                    RETF
    857          }
    858          
    859          /*
    860               //Computing time_long_on
    861          
    862               u8 hour=daily_hour_on;
    863               u8 minute=daily_minute_on;
    864               daily_long_on=0;
    865               do
    866               {
    867                    daily_long_on++;
    868                    minute++;
    869                    if (minute==60)
    870                    {
    871                      minute=0;
    872                      hour++;
    873                    }
    874                    if(hour==24) hour=0;
    875          
    876               } while ( !((hour==daily_hour_off) & (minute==daily_minute_off)));
    877          
    878                //Display daily_long_on
    879              LCDInstr(0x01);
    880              Delay1(1000);
    881              line_lcd=0;
    882              printf("\nLong :");
    883          
    884                do
    885              {
    886               line_lcd=1;
    887               printf("\n%d",daily_long_on);
    888                 //daily_long_on=adj(0,1440,daily_long_on);
    889              } while (!key_ok_on());
    890          
    891              time_on=daily_hour_on*60+daily_minute_on;
    892              time_off= daily_hour_off*60+daily_minute_off;
    893              //Save data to eeprom
    894                status.daily=1;
    895               EEPROM_INIT();
    896              //u8 temp =*(u8*)(&status);
    897              // FLASH_ProgramByte(EEPROM_ADR_STATUS,*(u8*)(&status)); //save Status to eeprom
    898               FLASH_ProgramByte(EEPROM_ADR_STATUSH,(u8)(*(u16*)(&status)>>8));
    899               FLASH_ProgramByte(EEPROM_ADR_STATUSL,(u8)(*(u16*)(&status)));
    900               FLASH_ProgramByte(EEPROM_ADR_TIME_ON_HOURS,daily_hour_on);
    901               FLASH_ProgramByte(EEPROM_ADR_TIME_ON_MINUTES,daily_minute_on);
    902               FLASH_ProgramByte(EEPROM_ADR_TIME_OFF_HOURS,daily_hour_off);
    903               FLASH_ProgramByte(EEPROM_ADR_TIME_OFF_MINUTES,daily_minute_off);
    904               FLASH_Lock(FLASH_MEMTYPE_DATA); //Locking  Flash Data
    905          
    906             return TRUE;
    907          
    908          }
    909            */
    910          

   \                                 In section .far_func.text, align 1, keep-with-next
    911          void Save_Status()
    912          {
    913            EEPROM_INIT();
   \                     Save_Status:
   \   000000 8D000000              CALLF     ??Subroutine61_0
    914            FLASH_ProgramByte(EEPROM_ADR_STATUSH,(u8)(*(u16*)(&status)>>8));
    915            FLASH_ProgramByte(EEPROM_ADR_STATUSL,(u8)(*(u16*)(&status)));
    916            FLASH_Lock(FLASH_MEMTYPE_DATA); //Locking  Flash Data
   \                     ??CrossCallReturnLabel_166:
   \   000004 A6F7                  LD        A, #0xf7
   \   000006 AC000000              JPF       FLASH_Lock
    917          }
    918          

   \                                 In section .far_func.text, align 1, keep-with-next
    919          bool Read_Allarm()
    920          {
    921             daily_hour_on=FLASH_ReadByte(EEPROM_ADR_TIME_ON_HOURS);
   \                     Read_Allarm:
   \   000000 AE4002                LDW       X, #0x4002
   \   000003 8D000000              CALLF     ?Subroutine5
   \                     ??CrossCallReturnLabel_11:
   \   000007 C70000                LD        L:daily_hour_on, A
    922              if(daily_hour_on > 24) return FALSE;
   \   00000A A119                  CP        A, #0x19
   \   00000C 2502                  JRC       L:??Read_Allarm_0
   \                     ??Read_Allarm_1:
   \   00000E 4F                    CLR       A
   \   00000F 87                    RETF
    923             daily_minute_on=FLASH_ReadByte(EEPROM_ADR_TIME_ON_MINUTES);
   \                     ??Read_Allarm_0:
   \   000010 AE4003                LDW       X, #0x4003
   \   000013 8D000000              CALLF     ?Subroutine5
   \                     ??CrossCallReturnLabel_10:
   \   000017 C70000                LD        L:daily_minute_on, A
    924              if(daily_minute_on > 59) return FALSE;
   \   00001A A13C                  CP        A, #0x3c
   \   00001C 24F0                  JRNC      L:??Read_Allarm_1
    925             daily_hour_off=FLASH_ReadByte(EEPROM_ADR_TIME_OFF_HOURS);
   \   00001E AE4004                LDW       X, #0x4004
   \   000021 8D000000              CALLF     ?Subroutine5
   \                     ??CrossCallReturnLabel_9:
   \   000025 C70000                LD        L:daily_hour_off, A
    926              if(daily_hour_off > 24) return FALSE;
   \   000028 A119                  CP        A, #0x19
   \   00002A 24E2                  JRNC      L:??Read_Allarm_1
    927             daily_minute_off=FLASH_ReadByte(EEPROM_ADR_TIME_OFF_MINUTES);
   \   00002C AE4005                LDW       X, #0x4005
   \   00002F 8D000000              CALLF     ?Subroutine5
   \                     ??CrossCallReturnLabel_8:
   \   000033 C70000                LD        L:daily_minute_off, A
    928              if(daily_hour_off > 59) return FALSE;
   \   000036 C60000                LD        A, L:daily_hour_off
   \   000039 A13C                  CP        A, #0x3c
   \   00003B 24D1                  JRNC      L:??Read_Allarm_1
    929               // Computting daily_long_on
    930                u8 hour=daily_hour_on;
   \   00003D C60000                LD        A, L:daily_hour_on
   \   000040 B700                  LD        S:?b0, A
    931               u8 minute=daily_minute_on;
   \   000042 C60000                LD        A, L:daily_minute_on
   \   000045 B700                  LD        S:?b1, A
    932               daily_long_on=0;
   \   000047 5F                    CLRW      X
   \   000048 CF0000                LDW       L:daily_long_on, X
    933               do
    934               {
    935                    daily_long_on++;
   \                     ??Read_Allarm_2:
   \   00004B CE0000                LDW       X, L:daily_long_on
   \   00004E 5C                    INCW      X
   \   00004F CF0000                LDW       L:daily_long_on, X
    936                    minute++;
   \   000052 B600                  LD        A, S:?b1
   \   000054 4C                    INC       A
   \   000055 B700                  LD        S:?b1, A
    937                    if (minute==60)
   \   000057 A13C                  CP        A, #0x3c
   \   000059 2607                  JRNE      L:??Read_Allarm_3
    938                    {
    939                      minute=0;
   \   00005B 3F00                  CLR       S:?b1
    940                      hour++;
   \   00005D B600                  LD        A, S:?b0
   \   00005F 4C                    INC       A
   \   000060 B700                  LD        S:?b0, A
    941                    }
    942                    if(hour==24) hour=0;
   \                     ??Read_Allarm_3:
   \   000062 B600                  LD        A, S:?b0
   \   000064 A118                  CP        A, #0x18
   \   000066 2602                  JRNE      L:??Read_Allarm_4
   \   000068 3F00                  CLR       S:?b0
    943          
    944               } while ( !((hour==daily_hour_off) & (minute==daily_minute_off)));
   \                     ??Read_Allarm_4:
   \   00006A C60000                LD        A, L:daily_hour_off
   \   00006D B100                  CP        A, S:?b0
   \   00006F 26DA                  JRNE      L:??Read_Allarm_2
   \   000071 C60000                LD        A, L:daily_minute_off
   \   000074 B100                  CP        A, S:?b1
   \   000076 26D3                  JRNE      L:??Read_Allarm_2
    945          
    946            return TRUE;
   \   000078 A601                  LD        A, #0x1
   \   00007A 87                    RETF
    947          }
    948          

   \                                 In section .far_func.text, align 1, keep-with-next
    949          void EEPROM_INIT()
    950          {
    951            FLASH_DeInit();
   \                     EEPROM_INIT:
   \   000000 8D000000              CALLF     FLASH_DeInit
    952            FLASH_Unlock(FLASH_MEMTYPE_DATA);
   \   000004 A6F7                  LD        A, #0xf7
   \   000006 8D000000              CALLF     FLASH_Unlock
    953            FLASH_SetProgrammingTime(FLASH_PROGRAMTIME_STANDARD);
   \   00000A 4F                    CLR       A
   \   00000B AC000000              JPF       FLASH_SetProgrammingTime
    954          
    955          
    956          
    957          }
    958          
    959          

   \                                 In section .far_func.text, align 1, keep-with-next
    960          void GpioConfiguration()
    961          {
    962          
    963            GPIO_Init(LCD_PORT,(GPIO_Pin_TypeDef)LCD_GPIO_PIN,GPIO_MODE_OUT_PP_HIGH_FAST);
   \                     GpioConfiguration:
   \   000000 35F00000              MOV       S:?b0, #0xf0
   \   000004 A6FE                  LD        A, #0xfe
   \   000006 AE500A                LDW       X, #0x500a
   \   000009 8D000000              CALLF     GPIO_Init
    964          
    965            // ADC PE6 NEW PB0
    966            GPIO_Init(GPIOB,GPIO_PIN_0,GPIO_MODE_IN_FL_NO_IT);
   \   00000D 3F00                  CLR       S:?b0
   \   00000F A601                  LD        A, #0x1
   \   000011 AE5005                LDW       X, #0x5005
   \   000014 8D000000              CALLF     GPIO_Init
    967          
    968            // PD6/UART2_RX   PD5/UART2_TX  No need to init  PD7 485 R/W;
    969            GPIO_Init(GPIOD,GPIO_PIN_7,GPIO_MODE_OUT_PP_HIGH_FAST);
   \   000018 35F00000              MOV       S:?b0, #0xf0
   \   00001C A680                  LD        A, #0x80
   \   00001E 8D000000              CALLF     ?Subroutine39
    970          
    971            //PD0 Led
    972            GPIO_Init(GPIOD,GPIO_PIN_0,GPIO_MODE_OUT_PP_HIGH_FAST);
   \                     ??CrossCallReturnLabel_107:
   \   000022 A601                  LD        A, #0x1
   \   000024 AE500F                LDW       X, #0x500f
   \   000027 8D000000              CALLF     ?Subroutine42
    973            //I2C
    974            GPIO_Init(GPIOB,GPIO_PIN_4 ,GPIO_MODE_OUT_OD_HIZ_FAST);
   \                     ??CrossCallReturnLabel_111:
   \   00002B A610                  LD        A, #0x10
   \   00002D AE5005                LDW       X, #0x5005
   \   000030 8D000000              CALLF     ?Subroutine42
    975            GPIO_Init(GPIOB,GPIO_PIN_5 ,GPIO_MODE_OUT_OD_HIZ_FAST);
   \                     ??CrossCallReturnLabel_112:
   \   000034 A620                  LD        A, #0x20
   \   000036 AE5005                LDW       X, #0x5005
   \   000039 8D000000              CALLF     ?Subroutine43
    976            // Remap Pins pb4,pb5  sda,scl ;
    977          
    978             //Init KEY OK,PLUS,MINUS
    979            GPIO_Init(GPIOF,key_ok,GPIO_MODE_IN_PU_NO_IT);
   \                     ??CrossCallReturnLabel_114:
   \   00003D A610                  LD        A, #0x10
   \   00003F AE5019                LDW       X, #0x5019
   \   000042 8D000000              CALLF     ?Subroutine43
    980            GPIO_Init(GPIOA,key_plus,GPIO_MODE_IN_PU_NO_IT);
   \                     ??CrossCallReturnLabel_115:
   \   000046 A602                  LD        A, #0x2
   \   000048 AE5000                LDW       X, #0x5000
   \   00004B 8D000000              CALLF     ?Subroutine43
    981            GPIO_Init(GPIOA,key_minus,GPIO_MODE_IN_PU_NO_IT);
   \                     ??CrossCallReturnLabel_116:
   \   00004F A604                  LD        A, #0x4
   \   000051 AE5000                LDW       X, #0x5000
   \   000054 8D000000              CALLF     ?Subroutine42
    982          
    983            //Init DS18b20 data pin
    984            GPIO_Init(GPIOD,ds18_data,GPIO_MODE_OUT_OD_HIZ_FAST);
   \                     ??CrossCallReturnLabel_113:
   \   000058 A604                  LD        A, #0x4
   \   00005A 8D000000              CALLF     ?Subroutine39
    985          
    986            // Power Pin
    987             GPIO_Init(GPIOD,power_pin,GPIO_MODE_OUT_PP_HIGH_FAST);
   \                     ??CrossCallReturnLabel_108:
   \   00005E A608                  LD        A, #0x8
   \   000060 AE500F                LDW       X, #0x500f
   \   000063 AC000000              JPF       GPIO_Init
    988          
    989          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000 8D000000              CALLF     GPIO_Init
   \   000004 35400000              MOV       S:?b0, #0x40
   \   000008 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000 8D000000              CALLF     GPIO_Init
   \   000004 35B00000              MOV       S:?b0, #0xb0
   \   000008 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000 AE500F                LDW       X, #0x500f
   \   000003 8D000000              CALLF     GPIO_Init
   \   000007 35F00000              MOV       S:?b0, #0xf0
   \   00000B 87                    RETF
    990          

   \                                 In section .far_func.text, align 1, keep-with-next
    991          void InitClk()
    992          {
    993            CLK_DeInit();
   \                     InitClk:
   \   000000 8D000000              CALLF     CLK_DeInit
    994            CLK_SYSCLKConfig(CLK_PRESCALER_CPUDIV1);    // CPU Prescalar = 1.
   \   000004 A680                  LD        A, #0x80
   \   000006 8D000000              CALLF     CLK_SYSCLKConfig
    995            CLK_SYSCLKConfig(CLK_PRESCALER_HSIDIV1);    // Prescalar = 1, 16 MHz.
   \   00000A 4F                    CLR       A
   \   00000B 8D000000              CALLF     CLK_SYSCLKConfig
    996            CLK_ClockSwitchConfig(CLK_SWITCHMODE_AUTO,  // Automatically switch
    997            CLK_SOURCE_HSI,       // Switch to internal timer.
    998            DISABLE,              // Disable the clock switch interrupt.
    999            CLK_CURRENTCLOCKSTATE_DISABLE);   // Disable the previous clock.
   \   00000F 3F00                  CLR       S:?b2
   \   000011 3F00                  CLR       S:?b1
   \   000013 35E10000              MOV       S:?b0, #0xe1
   \   000017 A601                  LD        A, #0x1
   \   000019 8D000000              CALLF     CLK_ClockSwitchConfig
   1000          
   1001            CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER2 , ENABLE);
   \   00001D 35010000              MOV       S:?b0, #0x1
   \   000021 A605                  LD        A, #0x5
   \   000023 8D000000              CALLF     ?Subroutine45
   1002            CLK_PeripheralClockConfig(CLK_PERIPHERAL_UART2,ENABLE);
   \                     ??CrossCallReturnLabel_120:
   \   000027 A603                  LD        A, #0x3
   \   000029 8D000000              CALLF     ?Subroutine45
   1003            CLK_PeripheralClockConfig(CLK_PERIPHERAL_ADC,ENABLE);
   \                     ??CrossCallReturnLabel_121:
   \   00002D A613                  LD        A, #0x13
   \   00002F 8D000000              CALLF     ?Subroutine45
   1004            CLK_PeripheralClockConfig(CLK_PERIPHERAL_I2C,ENABLE);
   \                     ??CrossCallReturnLabel_122:
   \   000033 4F                    CLR       A
   \   000034 AC000000              JPF       CLK_PeripheralClockConfig
   1005          
   1006          
   1007          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000 8D000000              CALLF     CLK_PeripheralClockConfig
   \   000004 35010000              MOV       S:?b0, #0x1
   \   000008 87                    RETF
   1008          
   1009          

   \                                 In section .far_func.text, align 1, keep-with-next
   1010          void InitAdc()
   1011          {
   1012               ADC1_DeInit();
   \                     InitAdc:
   \   000000 8D000000              CALLF     ADC1_DeInit
   1013               ADC1_StartConversion();
   \   000004 8D000000              CALLF     ADC1_StartConversion
   1014               /*
   1015               ADC1_Init(ADC1_CONVERSIONMODE_SINGLE,
   1016                          ADC1_CHANNEL_0,
   1017                          ADC1_PRESSEL_FCPU_D4,
   1018                           ADC1_EXTTRIG_TIM,
   1019          
   1020                 */
   1021               ADC1_PrescalerConfig(ADC1_PRESSEL_FCPU_D3);
   \   000008 A610                  LD        A, #0x10
   \   00000A 8D000000              CALLF     ADC1_PrescalerConfig
   1022               ADC1_ConversionConfig( ADC1_CONVERSIONMODE_SINGLE,
   1023                                      ADC1_CHANNEL_0,
   1024                                      ADC1_ALIGN_RIGHT
   1025                                     );
   \   00000E 35080000              MOV       S:?b1, #0x8
   \   000012 3F00                  CLR       S:?b0
   \   000014 4F                    CLR       A
   \   000015 8D000000              CALLF     ADC1_ConversionConfig
   1026          
   1027          
   1028               ADC1_SchmittTriggerConfig(ADC1_SCHMITTTRIG_CHANNEL0,DISABLE);
   \   000019 3F00                  CLR       S:?b0
   \   00001B 4F                    CLR       A
   \   00001C 8D000000              CALLF     ADC1_SchmittTriggerConfig
   1029          
   1030          
   1031               //ADC1_Cmd (ENABLE);
   1032               //ADC1->CR1 |= ADC1_CR1_ADON ;
   1033               ADC1_StartConversion();
   \   000020 8D000000              CALLF     ADC1_StartConversion
   1034               ADC1_ITConfig (ADC1_IT_EOCIE,ENABLE);
   \   000024 A601                  LD        A, #0x1
   \   000026 AE0020                LDW       X, #0x20
   \   000029 AC000000              JPF       ADC1_ITConfig
   1035          
   1036          }
   1037          
   1038          /*
   1039          void InitUart()
   1040          {
   1041             UART2_DeInit();
   1042             UART2_Init((u32)9600,
   1043                        UART2_WORDLENGTH_8D,
   1044                        UART2_STOPBITS_1,
   1045                        UART2_PARITY_NO,
   1046                        UART2_SYNCMODE_CLOCK_DISABLE,
   1047                        UART2_MODE_TXRX_ENABLE
   1048                          );
   1049          
   1050             UART2_ITConfig( UART2_IT_RXNE,ENABLE);
   1051             UART2_Cmd(ENABLE);
   1052          
   1053            // UART2_ITConfig(UART2_IT_RXNE,ENABLE);
   1054          }
   1055            */
   1056          

   \                                 In section .far_func.text, align 1, keep-with-next
   1057          void SendChar( u8 Char)
   1058          {
   1059             UART2->DR = Char;
   \                     SendChar:
   \   000000 C75241                LD        L:0x5241, A
   1060            while (UART2_GetFlagStatus(UART2_FLAG_TXE) == RESET);;
   \                     ??SendChar_0:
   \   000003 AE0080                LDW       X, #0x80
   \   000006 8D000000              CALLF     UART2_GetFlagStatus
   \   00000A A100                  CP        A, #0x0
   \   00000C 27F5                  JREQ      L:??SendChar_0
   1061          }
   \   00000E 87                    RETF
   1062            /*
   1063          void Send_Hello()
   1064          {
   1065            GPIO_WriteHigh(GPIOD,GPIO_PIN_7); //R_W Line
   1066             Delay1(10);
   1067             sprintf(data,"Hello");
   1068              u8 i=0;
   1069            do
   1070           {
   1071            SendChar(data[i++]);
   1072           } while (data[i]!=0);
   1073            while (UART2_GetFlagStatus(UART2_FLAG_TC) == RESET);;  //Wait to send last byte
   1074            GPIO_WriteLow(GPIOD,GPIO_PIN_7); //R_W Line
   1075          
   1076          
   1077          
   1078          }
   1079              */
   1080          
   1081          
   1082              /*
   1083          
   1084          void SendData()
   1085          {
   1086           GPIO_WriteHigh(GPIOD,GPIO_PIN_7); //R_W Line
   1087            Delay1(10);
   1088            u8 i=0;
   1089            sprintf(data,"%d %c",adcdata,0x0d);
   1090           do
   1091           {
   1092             SendChar(data[i++]);
   1093          
   1094           } while (data[i]!=0);
   1095             while (UART2_GetFlagStatus(UART2_FLAG_TC) == RESET);;  //Wait to send last byte
   1096            GPIO_WriteLow(GPIOD,GPIO_PIN_7); //R_W Line
   1097            rx_data=0;
   1098          }
   1099          */
   1100          

   \                                 In section .far_func.text, align 1, keep-with-next
   1101          void LCDDataOut(u8 data)
   1102          {
   \                     LCDDataOut:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1103            (data&0x1)? GPIO_WriteHigh(LCD_PORT,DATA4):GPIO_WriteLow(LCD_PORT,DATA4);
   \   000005 A501                  BCP       A, #0x1
   \   000007 2708                  JREQ      L:??LCDDataOut_0
   \   000009 A610                  LD        A, #0x10
   \   00000B 8D000000              CALLF     ?Subroutine24
   \                     ??CrossCallReturnLabel_77:
   \   00000F 2006                  JRA       L:??CrossCallReturnLabel_160
   \                     ??LCDDataOut_0:
   \   000011 A610                  LD        A, #0x10
   \   000013 8D000000              CALLF     ??Subroutine60_0
   1104            (data&0x2)? GPIO_WriteHigh(LCD_PORT,DATA5):GPIO_WriteLow(LCD_PORT,DATA5);
   \                     ??CrossCallReturnLabel_160:
   \   000017 B600                  LD        A, S:?b8
   \   000019 A502                  BCP       A, #0x2
   \   00001B 2708                  JREQ      L:??LCDDataOut_1
   \   00001D A620                  LD        A, #0x20
   \   00001F 8D000000              CALLF     ?Subroutine24
   \                     ??CrossCallReturnLabel_76:
   \   000023 2006                  JRA       L:??CrossCallReturnLabel_161
   \                     ??LCDDataOut_1:
   \   000025 A620                  LD        A, #0x20
   \   000027 8D000000              CALLF     ??Subroutine60_0
   1105            (data&0x4)? GPIO_WriteHigh(LCD_PORT,DATA6):GPIO_WriteLow(LCD_PORT,DATA6);
   \                     ??CrossCallReturnLabel_161:
   \   00002B B600                  LD        A, S:?b8
   \   00002D A504                  BCP       A, #0x4
   \   00002F 2708                  JREQ      L:??LCDDataOut_2
   \   000031 A640                  LD        A, #0x40
   \   000033 8D000000              CALLF     ?Subroutine24
   \                     ??CrossCallReturnLabel_75:
   \   000037 2006                  JRA       L:??CrossCallReturnLabel_162
   \                     ??LCDDataOut_2:
   \   000039 A640                  LD        A, #0x40
   \   00003B 8D000000              CALLF     ??Subroutine60_0
   1106            (data&0x8)? GPIO_WriteHigh(LCD_PORT,DATA7):GPIO_WriteLow(LCD_PORT,DATA7);
   \                     ??CrossCallReturnLabel_162:
   \   00003F B600                  LD        A, S:?b8
   \   000041 A508                  BCP       A, #0x8
   \   000043 2708                  JREQ      L:??LCDDataOut_3
   \   000045 A680                  LD        A, #0x80
   \   000047 8D000000              CALLF     ?Subroutine24
   \                     ??CrossCallReturnLabel_74:
   \   00004B 2006                  JRA       L:??CrossCallReturnLabel_163
   \                     ??LCDDataOut_3:
   \   00004D A680                  LD        A, #0x80
   \   00004F 8D000000              CALLF     ??Subroutine60_0
   1107          }
   \                     ??CrossCallReturnLabel_163:
   \   000053 320000                POP       S:?b8
   \   000056 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000 AE500A                LDW       X, #0x500a
   \   000003 AC000000              JPF       GPIO_WriteHigh

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine60_0:
   \   000000 8D000000              CALLF     ?Subroutine55
   \                     ??CrossCallReturnLabel_200:
   \   000004 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000 AE500A                LDW       X, #0x500a
   \   000003 AC000000              JPF       GPIO_WriteLow
   1108          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000 A604                  LD        A, #0x4
   \   000002                       REQUIRE ??Subroutine60_0
   \   000002                       ;               // Fall through to label ??Subroutine60_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000 8D000000              CALLF     ?Subroutine55
   \                     ??CrossCallReturnLabel_198:
   \   000004                       REQUIRE ??Subroutine65_0
   \   000004                       ;               // Fall through to label ??Subroutine65_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine65_0:
   \   000000 A602                  LD        A, #0x2
   \   000002 8D000000              CALLF     ?Subroutine55
   \                     ??CrossCallReturnLabel_197:
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   1109          void InitLcd()
   1110          {
   1111           LCD_EN(0);
   \                     InitLcd:
   \   000000 A608                  LD        A, #0x8
   \   000002 8D000000              CALLF     ?Subroutine22
   1112            LCD_RW(0);
   1113            LCD_RS(0);
   \                     ??CrossCallReturnLabel_194:
   \   000006 8D000000              CALLF     ?Subroutine23
   1114            Delay1(4000); // 40ms
   \                     ??CrossCallReturnLabel_158:
   \   00000A AE0FA0                LDW       X, #0xfa0
   \   00000D 8D000000              CALLF     Delay1
   1115          
   1116            LCDInstrNibble(0x03);
   \   000011 8D000000              CALLF     ?Subroutine21
   1117             Delay1(10);
   1118            LCDInstrNibble(0x03);
   \                     ??CrossCallReturnLabel_71:
   \   000015 8D000000              CALLF     ?Subroutine21
   1119             Delay1(10);
   1120            LCDInstrNibble(0x03);
   \                     ??CrossCallReturnLabel_70:
   \   000019 8D000000              CALLF     ?Subroutine21
   1121             Delay1(10);
   1122          
   1123             //Line 4
   1124            LCDInstrNibble(0x02);
   \                     ??CrossCallReturnLabel_69:
   \   00001D A602                  LD        A, #0x2
   \   00001F 8D000000              CALLF     LCDInstrNibble
   1125            LCDInstrNibble(0x02);
   \   000023 A602                  LD        A, #0x2
   \   000025 8D000000              CALLF     LCDInstrNibble
   1126            LCDInstrNibble(0x08);
   \   000029 A608                  LD        A, #0x8
   \   00002B 8D000000              CALLF     LCDInstrNibble
   1127            Delay1(100);
   \   00002F AE0064                LDW       X, #0x64
   \   000032 8D000000              CALLF     Delay1
   1128          
   1129            LCDInstr(0x0C);
   \   000036 A60C                  LD        A, #0xc
   \   000038 8D000000              CALLF     LCDInstr
   1130            Delay1(10);
   \   00003C AE000A                LDW       X, #0xa
   \   00003F 8D000000              CALLF     Delay1
   1131          
   1132            LCDInstr(0x01) ;
   \   000043 8D000000              CALLF     ?Subroutine15
   1133            Delay1(250);
   1134          
   1135            LCDInstr(0x06);
   \                     ??CrossCallReturnLabel_44:
   \   000047 A606                  LD        A, #0x6
   \   000049 8D000000              CALLF     LCDInstr
   1136            Delay1(10);
   \   00004D AE000A                LDW       X, #0xa
   \   000050 AC000000              JPF       Delay1
   1137          
   1138          
   1139          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000 A603                  LD        A, #0x3
   \   000002 8D000000              CALLF     LCDInstrNibble
   \   000006 AE000A                LDW       X, #0xa
   \   000009 AC000000              JPF       Delay1

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000 8D000000              CALLF     ?Subroutine52
   \                     ??CrossCallReturnLabel_137:
   \   000004 AE00FA                LDW       X, #0xfa
   \   000007 AC000000              JPF       Delay1
   1140          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000 8D000000              CALLF     ??Subroutine65_0
   \                     ??CrossCallReturnLabel_195:
   \   000004 B600                  LD        A, S:?b8
   \   000006 4E                    SWAP      A
   \   000007 8D000000              CALLF     ?Subroutine30
   \                     ??CrossCallReturnLabel_155:
   \   00000B                       REQUIRE ??Subroutine59_0
   \   00000B                       ;               // Fall through to label ??Subroutine59_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine59_0:
   \   000000 B600                  LD        A, S:?b8
   \   000002 8D000000              CALLF     ?Subroutine30
   \                     ??CrossCallReturnLabel_154:
   \   000006 320000                POP       S:?b8
   \   000009 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000 A40F                  AND       A, #0xf
   \   000002 8D000000              CALLF     LCDDataOut
   \   000006 AC000000              JPF       PulseEnable

   \                                 In section .far_func.text, align 1, keep-with-next
   1141          void LCDInstr(u8 Instr)
   1142          {
   \                     LCDInstr:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1143            LCD_RS(0);
   \   000005 8D000000              CALLF     ?Subroutine23
   1144            LCD_RW(0);
   \                     ??CrossCallReturnLabel_156:
   \   000009 2000                  JRA       ?Subroutine0
   1145            LCDDataOut(Instr>>4);
   1146            PulseEnable();
   1147            LCDDataOut(Instr & 0x0F);
   1148            PulseEnable();
   1149          }
   1150          

   \                                 In section .far_func.text, align 1, keep-with-next
   1151          void LCDData(u8 Data)
   1152          {
   \                     LCDData:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1153            LCD_RS(1);
   \   000005 A604                  LD        A, #0x4
   \   000007 8D000000              CALLF     ?Subroutine24
   1154            LCD_RW(0);
   \                     ??CrossCallReturnLabel_73:
   \   00000B                       REQUIRE ?Subroutine0
   \   00000B                       ;               // Fall through to label ?Subroutine0
   1155            LCDDataOut(Data>>4);
   1156            PulseEnable() ;
   1157            LCDDataOut(Data & 0x0F) ;
   1158            PulseEnable();
   1159          }
   1160          

   \                                 In section .far_func.text, align 1, keep-with-next
   1161          void LCDInstrNibble(u8 Instr)
   1162          {
   \                     LCDInstrNibble:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1163            LCD_RS(0);
   \   000005 A604                  LD        A, #0x4
   \   000007 8D000000              CALLF     ?Subroutine22
   1164            LCD_RW(0);
   1165            LCDDataOut(Instr & 0x0F);
   \                     ??CrossCallReturnLabel_193:
   \   00000B AC000000              JPF       ??Subroutine59_0
   1166            PulseEnable();
   1167          }
   1168          

   \                                 In section .far_func.text, align 1, keep-with-next
   1169          void PulseEnable(void)
   1170          {
   1171            LCD_EN(0);
   \                     PulseEnable:
   \   000000 8D000000              CALLF     ?Subroutine4
   1172             Delay1(1);
   1173            LCD_EN(1);
   1174             Delay1(1);
   1175            LCD_EN(0);
   \                     ??CrossCallReturnLabel_4:
   \   000004 A608                  LD        A, #0x8
   \   000006 8D000000              CALLF     ??Subroutine60_0
   1176             Delay1(1);
   \                     ??CrossCallReturnLabel_159:
   \   00000A 5F                    CLRW      X
   \   00000B 5C                    INCW      X
   \   00000C AC000000              JPF       Delay1
   1177          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000 A608                  LD        A, #0x8
   \   000002 8D000000              CALLF     ?Subroutine55
   \                     ??CrossCallReturnLabel_199:
   \   000006 8D000000              CALLF     ?Subroutine51
   \                     ??CrossCallReturnLabel_184:
   \   00000A A608                  LD        A, #0x8
   \   00000C AE500A                LDW       X, #0x500a
   \   00000F 8D000000              CALLF     GPIO_WriteHigh
   \   000013 8D000000              CALLF     ?Subroutine51
   \                     ??CrossCallReturnLabel_183:
   \   000017 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000 5F                    CLRW      X
   \   000001 5C                    INCW      X
   \   000002 AC000000              JPF       Delay1
   1178          

   \                                 In section .far_func.text, align 1, keep-with-next
   1179          void LCD_Busy(void)
   1180          {
   1181             //set Port D7 as Input
   1182             GPIO_Init(LCD_PORT,DATA7,GPIO_MODE_IN_PU_NO_IT);
   \                     LCD_Busy:
   \   000000 35400000              MOV       S:?b0, #0x40
   \   000004 A680                  LD        A, #0x80
   \   000006 AE500A                LDW       X, #0x500a
   \   000009 8D000000              CALLF     GPIO_Init
   1183             //Set Read
   1184             LCD_RW(1);
   \   00000D A602                  LD        A, #0x2
   \   00000F 8D000000              CALLF     ?Subroutine24
   1185             LCD_RS(0);
   \                     ??CrossCallReturnLabel_72:
   \   000013 8D000000              CALLF     ?Subroutine23
   1186             // Read Busy Flag
   1187                timer2=0;
   \                     ??CrossCallReturnLabel_157:
   \   000017 5F                    CLRW      X
   \   000018 CF0000                LDW       L:timer2, X
   1188             do
   1189             {
   1190             // Enable set
   1191               LCD_EN(0);
   \                     ??LCD_Busy_0:
   \   00001B 8D000000              CALLF     ?Subroutine4
   1192                Delay1(1);
   1193               LCD_EN(1);
   1194                Delay1(1);
   1195             } while (GPIO_ReadInputPin(LCD_PORT, DATA7));
   \                     ??CrossCallReturnLabel_5:
   \   00001F A680                  LD        A, #0x80
   \   000021 AE500A                LDW       X, #0x500a
   \   000024 8D000000              CALLF     GPIO_ReadInputPin
   \   000028 A100                  CP        A, #0x0
   \   00002A 26EF                  JRNE      L:??LCD_Busy_0
   1196                k=timer2;
   \   00002C CE0000                LDW       X, L:timer2
   \   00002F CF0000                LDW       L:k, X
   1197                //Clear read
   1198              LCD_RW(0);
   \   000032 8D000000              CALLF     ??Subroutine65_0
   1199             //set Port D7 as Output
   1200             GPIO_Init(LCD_PORT,DATA7,GPIO_MODE_OUT_PP_HIGH_FAST);
   \                     ??CrossCallReturnLabel_196:
   \   000036 35F00000              MOV       S:?b0, #0xf0
   \   00003A A680                  LD        A, #0x80
   \   00003C AE500A                LDW       X, #0x500a
   \   00003F AC000000              JPF       GPIO_Init
   1201          
   1202          }
   1203          
   1204          

   \                                 In section .far_func.text, align 1, keep-with-next
   1205          void LCD(u8 data)
   1206           {
   \                     LCD:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
   1207             //  static u8 linet=0;
   1208          
   1209          
   1210               if (data =='\n')     //r
   \   000005 A10A                  CP        A, #0xa
   \   000007 2658                  JRNE      L:??CrossCallReturnLabel_182
   1211               {
   1212          
   1213                   switch(line_lcd)
   \   000009 C60000                LD        A, L:line_lcd
   \   00000C 270B                  JREQ      L:??LCD_0
   \   00000E 4A                    DEC       A
   \   00000F 2710                  JREQ      L:??LCD_1
   \   000011 4A                    DEC       A
   \   000012 2719                  JREQ      L:??LCD_2
   \   000014 4A                    DEC       A
   \   000015 2722                  JREQ      L:??LCD_3
   \   000017 202A                  JRA       L:??LCD_4
   1214                   {
   1215                   case 0:
   1216                     LCDInstr(0x80 | 0x00);
   \                     ??LCD_0:
   \   000019 A680                  LD        A, #0x80
   \   00001B 8D000000              CALLF     ?Subroutine56
   1217                     count=0;
   1218                     break;
   \                     ??CrossCallReturnLabel_147:
   \   00001F 2022                  JRA       L:??LCD_4
   1219                   case 1:
   1220                     LCDInstr(0x80 | 0x40);
   \                     ??LCD_1:
   \   000021 A6C0                  LD        A, #0xc0
   \   000023 8D000000              CALLF     LCDInstr
   1221                     count=20;
   \   000027 35140000              MOV       L:count, #0x14
   1222                     break;
   \   00002B 2016                  JRA       L:??LCD_4
   1223                   case 2:
   1224                     LCDInstr(0x80 | 0x14);
   \                     ??LCD_2:
   \   00002D A694                  LD        A, #0x94
   \   00002F 8D000000              CALLF     LCDInstr
   1225                     count=40;
   \   000033 35280000              MOV       L:count, #0x28
   1226                     break;
   \   000037 200A                  JRA       L:??LCD_4
   1227                   case 3:
   1228                     LCDInstr(0x80 | 0x54);
   \                     ??LCD_3:
   \   000039 A6D4                  LD        A, #0xd4
   \   00003B 8D000000              CALLF     LCDInstr
   1229                     count=60;
   \   00003F 353C0000              MOV       L:count, #0x3c
   1230                     break;
   1231                   //default:
   1232                    //  LCDInstr(0x80 |0x40);    //Line 1
   1233                    }
   1234                   line_lcd++;
   \                     ??LCD_4:
   \   000043 C60000                LD        A, L:line_lcd
   \   000046 4C                    INC       A
   \   000047 C70000                LD        L:line_lcd, A
   1235                   if (line_lcd>=5)
   \   00004A A105                  CP        A, #0x5
   \   00004C 250F                  JRC       L:??LCD_5
   1236                   {
   1237                    line_lcd=1;   //line >=5
   \   00004E 35010000              MOV       L:line_lcd, #0x1
   1238                    LCDInstr(0x01); //Clear LCD
   \   000052 8D000000              CALLF     ?Subroutine52
   1239                    Delay1(2500);
   \                     ??CrossCallReturnLabel_139:
   \   000056 AE09C4                LDW       X, #0x9c4
   \   000059 8D000000              CALLF     Delay1
   1240                   }
   1241          
   1242                   Delay1(1);
   \                     ??LCD_5:
   \   00005D 8D000000              CALLF     ??Subroutine63_0
   1243          
   1244          
   1245               }
   1246          
   1247          
   1248               if (count==20)
   \                     ??CrossCallReturnLabel_182:
   \   000061 C60000                LD        A, L:count
   \   000064 A114                  CP        A, #0x14
   \   000066 260A                  JRNE      L:??LCD_6
   1249                {
   1250                  LCDInstr(0x80 | 0x40);
   \   000068 A6C0                  LD        A, #0xc0
   \                     ??LCD_7:
   \   00006A 8D000000              CALLF     LCDInstr
   1251                  Delay1(1);
   \                     ??LCD_8:
   \   00006E 5F                    CLRW      X
   \   00006F 5C                    INCW      X
   \   000070 2023                  JRA       ??LCD_9
   1252                }
   1253                   else if(count==40)
   \                     ??LCD_6:
   \   000072 A128                  CP        A, #0x28
   \   000074 2604                  JRNE      L:??LCD_10
   1254                  {
   1255                    LCDInstr(0x80 | 0x14);
   \   000076 A694                  LD        A, #0x94
   \   000078 20F0                  JRA       ??LCD_7
   1256                    Delay1(1);
   1257                  }
   1258                    else if(count==60)
   \                     ??LCD_10:
   \   00007A A13C                  CP        A, #0x3c
   \   00007C 2608                  JRNE      L:??LCD_11
   1259                    {
   1260                      LCDInstr(0x80 | 0x54);
   \   00007E A6D4                  LD        A, #0xd4
   \   000080 8D000000              CALLF     ?Subroutine56
   1261                      count=0;
   1262                      Delay1(1);
   \                     ??CrossCallReturnLabel_148:
   \   000084 20E8                  JRA       ??LCD_8
   1263                    }
   1264                      else if(count >80)
   \                     ??LCD_11:
   \   000086 A151                  CP        A, #0x51
   \   000088 250F                  JRC       L:??LCD_12
   1265                        {
   1266                          count=0;
   \   00008A 725F0000              CLR       L:count
   1267                          LCDInstr(0x01); //Clear LCD
   \   00008E 8D000000              CALLF     ?Subroutine52
   1268                          Delay1(250);
   \                     ??CrossCallReturnLabel_138:
   \   000092 AE00FA                LDW       X, #0xfa
   \                     ??LCD_9:
   \   000095 8D000000              CALLF     Delay1
   1269                        }
   1270          
   1271          
   1272              /*
   1273                   line++;
   1274                   if (line>3)
   1275                   {
   1276                     line=1;  //Line 0 for Time
   1277                   }
   1278                 switch(line)
   1279                   {
   1280                   case 1 :LCDInstr(0x80 | 0x40);break;  //Line 1
   1281                   case 2 :LCDInstr(0x80 | 0x14);break;  //Line 2
   1282                   case 3 :LCDInstr(0x80 | 0x54);break;  //Line 3
   1283                   default : LCDInstr(0x80 | 0x40); // Line 1
   1284                   }
   1285                   Delay(1);
   1286                   count=0;
   1287                }
   1288          
   1289               */
   1290          
   1291               if (data > 0x1b)   //Display only valid data
   \                     ??LCD_12:
   \   000099 B600                  LD        A, S:?b8
   \   00009B A11C                  CP        A, #0x1c
   \   00009D 250B                  JRC       L:??LCD_13
   1292               {
   1293                 LCDData(data);
   \   00009F 8D000000              CALLF     ?Subroutine10
   1294                  Delay1(1);
   1295                 count++;
   \                     ??CrossCallReturnLabel_180:
   \   0000A3 C60000                LD        A, L:count
   \   0000A6 4C                    INC       A
   \   0000A7 C70000                LD        L:count, A
   1296               }
   1297           }
   \                     ??LCD_13:
   \   0000AA 320000                POP       S:?b8
   \   0000AD 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000 8D000000              CALLF     LCDInstr
   \   000004 725F0000              CLR       L:count
   \   000008 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000 8D000000              CALLF     LCDData
   \   000004                       REQUIRE ??Subroutine63_0
   \   000004                       ;               // Fall through to label ??Subroutine63_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ??Subroutine63_0:
   \   000000 8D000000              CALLF     ?Subroutine51
   \                     ??CrossCallReturnLabel_185:
   \   000004 87                    RETF
   1298          

   \                                 In section .far_func.text, align 1, keep-with-next
   1299          void InitDelayTimer()
   1300          {
   1301             //Timer 2 use for Delay  long Delay is 40ms for lcd
   1302             //Tclock 16/8=2Mhz  /20 10us
   1303                 TIM2_DeInit();
   \                     InitDelayTimer:
   \   000000 8D000000              CALLF     TIM2_DeInit
   1304                 TIM2_TimeBaseInit(TIM2_PRESCALER_2,0X0050);
   \   000004 AE0050                LDW       X, #0x50
   \   000007 A601                  LD        A, #0x1
   \   000009 8D000000              CALLF     TIM2_TimeBaseInit
   1305                 //TIM2_PrescalerConfig(TIM2_PRESCALER_1, TIM2_PSCRELOADMODE_IMMEDIATE);
   1306                 TIM2_ITConfig(TIM2_IT_UPDATE, ENABLE);
   \   00000D 35010000              MOV       S:?b0, #0x1
   \   000011 A601                  LD        A, #0x1
   \   000013 8D000000              CALLF     TIM2_ITConfig
   1307            //Enable TIM2
   1308                 TIM2_Cmd(ENABLE);
   \   000017 A601                  LD        A, #0x1
   \   000019 AC000000              JPF       TIM2_Cmd
   1309          
   1310          }
   1311          

   \                                 In section .far_func.text, align 1, keep-with-next
   1312          bool DS18_Write(u8 data)
   1313          {
   \                     DS18_Write:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b9, A
   1314            disableInterrupts();
   \   000006 9B                    SIM
   1315            for ( u8 i=0;i<8;i++)
   \   000007 3F00                  CLR       S:?b8
   1316            {
   1317             DS18(0);
   \                     ??DS18_Write_0:
   \   000009 8D000000              CALLF     ?Subroutine26
   1318             Delay_us(1); //Delay1(0); //Start time slot 4,5 us
   1319             if( data & (1<<i)) DS18(1)
   \                     ??CrossCallReturnLabel_79:
   \   00000D 5F                    CLRW      X
   \   00000E 5C                    INCW      X
   \   00000F B600                  LD        A, S:?b8
   \   000011 8D000000              CALLF     L:?sll16_x_x_a
   \   000015 9F                    LD        A, XL
   \   000016 B500                  BCP       A, S:?b9
   \   000018 2704                  JREQ      L:??CrossCallReturnLabel_192
   \   00001A 8D000000              CALLF     ?Subroutine28
   1320               //else DS18(0);
   1321             Delay_us(160);  // 60us end time slot
   \                     ??CrossCallReturnLabel_192:
   \   00001E AE00A0                LDW       X, #0xa0
   \   000021 8D000000              CALLF     Delay_us
   1322             DS18(1);
   \   000025 8D000000              CALLF     ?Subroutine28
   1323             //Delay1(0);
   1324            }
   \                     ??CrossCallReturnLabel_191:
   \   000029 B600                  LD        A, S:?b8
   \   00002B 4C                    INC       A
   \   00002C B700                  LD        S:?b8, A
   \   00002E A108                  CP        A, #0x8
   \   000030 25D7                  JRC       L:??DS18_Write_0
   1325            enableInterrupts();
   \   000032 9A                    RIM
   1326            return TRUE;
   \   000033 A601                  LD        A, #0x1
   \   000035 AC000000              JPF       L:?epilogue_w4
   1327          
   1328          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000 A604                  LD        A, #0x4
   \   000002                       REQUIRE ??Subroutine64_0
   \   000002                       ;               // Fall through to label ??Subroutine64_0

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000 8D000000              CALLF     ?Subroutine57
   \                     ??CrossCallReturnLabel_150:
   \   000004 5F                    CLRW      X
   \   000005 5C                    INCW      X
   \   000006 AC000000              JPF       Delay_us

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000 A604                  LD        A, #0x4
   \   000002 8D000000              CALLF     ?Subroutine58
   \                     ??CrossCallReturnLabel_153:
   \   000006 87                    RETF
   1329          
   1330          

   \                                 In section .far_func.text, align 1, keep-with-next
   1331          u8  DS18_Read()
   1332          {
   \                     DS18_Read:
   \   000000 8D000000              CALLF     L:?push_w4
   1333              //Init DS18b20 data pin as Input
   1334          
   1335            u8 data=0;
   \   000004 3F00                  CLR       S:?b9
   1336              disableInterrupts();
   \   000006 9B                    SIM
   1337            for (u8 i=0;i<8;i++)
   \   000007 3F00                  CLR       S:?b8
   1338            {
   1339              DS18(0);
   \                     ??DS18_Read_0:
   \   000009 8D000000              CALLF     ?Subroutine26
   1340              Delay_us(1); //Start time slot 4,5 us
   1341              DS18(1);
   \                     ??CrossCallReturnLabel_78:
   \   00000D 8D000000              CALLF     ?Subroutine28
   1342              Delay_us(35); // Wait for ds18b20 set bit 15us
   \                     ??CrossCallReturnLabel_189:
   \   000011 AE0023                LDW       X, #0x23
   \   000014 8D000000              CALLF     Delay_us
   1343              //Delay1(0);
   1344             data +=((1<<i)*(GPIO_ReadInputPin(GPIOD,ds18_data)&&ds18_data));
   \   000018 8D000000              CALLF     ?Subroutine29
   \                     ??CrossCallReturnLabel_83:
   \   00001C 2706                  JREQ      L:??DS18_Read_1
   \   00001E 35010000              MOV       S:?b0, #0x1
   \   000022 2002                  JRA       L:??DS18_Read_2
   \                     ??DS18_Read_1:
   \   000024 3F00                  CLR       S:?b0
   \                     ??DS18_Read_2:
   \   000026 5F                    CLRW      X
   \   000027 5C                    INCW      X
   \   000028 B600                  LD        A, S:?b8
   \   00002A 8D000000              CALLF     L:?sll16_x_x_a
   \   00002E B600                  LD        A, S:?b0
   \   000030 42                    MUL       X, A
   \   000031 9F                    LD        A, XL
   \   000032 BB00                  ADD       A, S:?b9
   \   000034 B700                  LD        S:?b9, A
   1345              Delay_us(120); // Wait 60 us until end of read slot  45us
   \   000036 AE0078                LDW       X, #0x78
   \   000039 8D000000              CALLF     Delay_us
   1346              //  DS18(1);  // Next bit
   1347             // Delay1(0);
   1348          
   1349            }
   \   00003D B600                  LD        A, S:?b8
   \   00003F 4C                    INC       A
   \   000040 B700                  LD        S:?b8, A
   \   000042 A108                  CP        A, #0x8
   \   000044 25C3                  JRC       L:??DS18_Read_0
   1350              enableInterrupts();
   \   000046 9A                    RIM
   1351              //Init DS18b20 data pin
   1352             // GPIO_Init(GPIOD,ds18_data,GPIO_MODE_OUT_OD_HIZ_FAST);
   1353             return data;
   \   000047 B600                  LD        A, S:?b9
   \   000049 AC000000              JPF       L:?epilogue_w4
   1354          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000 A604                  LD        A, #0x4
   \   000002 AE500F                LDW       X, #0x500f
   \   000005 8D000000              CALLF     GPIO_ReadInputPin
   \   000009 A100                  CP        A, #0x0
   \   00000B 87                    RETF
   1355          

   \                                 In section .far_func.text, align 1, keep-with-next
   1356          bool DS18_Reset()
   1357          {
   1358             //Init Reset Pulse
   1359              DS18(0);
   \                     DS18_Reset:
   \   000000 8D000000              CALLF     ?Subroutine57
   1360              Delay1(25);    //25=524us
   \                     ??CrossCallReturnLabel_149:
   \   000004 AE0019                LDW       X, #0x19
   \   000007 8D000000              CALLF     Delay1
   1361              DS18(1);
   \   00000B 8D000000              CALLF     ?Subroutine28
   1362              //Delay1(1);
   1363              timer2=0;
   \                     ??CrossCallReturnLabel_190:
   \   00000F 5F                    CLRW      X
   \   000010 CF0000                LDW       L:timer2, X
   1364              while ((timer2 < 10000) && (GPIO_ReadInputPin(GPIOD, ds18_data)));;   //Wait for ack from DS18B20
   \                     ??DS18_Reset_0:
   \   000013 8D000000              CALLF     ?Subroutine17
   \                     ??CrossCallReturnLabel_48:
   \   000017 2406                  JRNC      L:??DS18_Reset_1
   \   000019 8D000000              CALLF     ?Subroutine29
   \                     ??CrossCallReturnLabel_82:
   \   00001D 26F4                  JRNE      L:??DS18_Reset_0
   1365              if (timer2>=10000) return FALSE;
   \                     ??DS18_Reset_1:
   \   00001F 8D000000              CALLF     ?Subroutine17
   \                     ??CrossCallReturnLabel_49:
   \   000023 2502                  JRC       L:??DS18_Reset_2
   \   000025 4F                    CLR       A
   \   000026 87                    RETF
   1366              // Delay1(10);
   1367              Delay1(20);    //25=524us
   \                     ??DS18_Reset_2:
   \   000027 AE0014                LDW       X, #0x14
   \   00002A 8D000000              CALLF     Delay1
   1368          
   1369              return TRUE;
   \   00002E A601                  LD        A, #0x1
   \   000030 87                    RETF
   1370          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000 CE0000                LDW       X, L:timer2
   \   000003 A32710                CPW       X, #0x2710
   \   000006 87                    RETF
   1371          

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000 8D000000              CALLF     DS18_Reset
   \   000004 A100                  CP        A, #0x0
   \   000006 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   1372          u8 temperature ()
   1373          {
   \                     temperature:
   \   000000 8D000000              CALLF     L:?push_w4
   1374          
   1375             //Init Reset Pulse
   1376               if(!DS18_Reset()) return FALSE;
   \   000004 8D000000              CALLF     ?Subroutine38
   \                     ??CrossCallReturnLabel_105:
   \   000008 2605                  JRNE      L:??temperature_0
   \                     ??temperature_1:
   \   00000A 4F                    CLR       A
   \   00000B AC000000              JPF       L:?epilogue_w4
   1377             //Skip ROM Command 0xCC
   1378              DS18_Write(0xCC);
   \                     ??temperature_0:
   \   00000F 8D000000              CALLF     ?Subroutine37
   1379             //Function command  CONVERT T [44h]
   1380              DS18_Write(0x44);
   1381              //Wait util end convert
   1382              timer2=0;
   1383               while ((timer2 < 10000) && !(DS18_Read()));;
   \                     ??CrossCallReturnLabel_101:
   \   000013 8D000000              CALLF     ?Subroutine17
   \                     ??CrossCallReturnLabel_51:
   \   000017 2408                  JRNC      L:??temperature_2
   \   000019 8D000000              CALLF     DS18_Read
   \   00001D A100                  CP        A, #0x0
   \   00001F 27F2                  JREQ      L:??CrossCallReturnLabel_101
   1384                if (timer2>10000) return FALSE;
   \                     ??temperature_2:
   \   000021 CE0000                LDW       X, L:timer2
   \   000024 A32711                CPW       X, #0x2711
   \   000027 24E1                  JRNC      L:??temperature_1
   1385               //u8 temp8=timer2;
   1386              //Init Reset Pulse
   1387              if(!DS18_Reset()) return FALSE;
   \   000029 8D000000              CALLF     ?Subroutine38
   \                     ??CrossCallReturnLabel_106:
   \   00002D 27DB                  JREQ      L:??temperature_1
   1388              // Skip ROM Command 0xCC
   1389              DS18_Write(0xCC);
   \   00002F 8D000000              CALLF     ?Subroutine36
   1390              //Function command READ SCRATCHPAD [BEh]
   1391              DS18_Write(0xBE);
   1392               u8 temp1=DS18_Read();
   1393               u8 temp2=DS18_Read();
   1394              DS18_Reset();
   \                     ??CrossCallReturnLabel_99:
   \   000033 8D000000              CALLF     DS18_Reset
   1395                u16 result = temp2*256+temp1;
   1396                temp1= (u8)(result>>3);
   1397               return temp1;
   \   000037 8D000000              CALLF     ?Subroutine3
   \                     ??CrossCallReturnLabel_3:
   \   00003B AC000000              JPF       L:?epilogue_w4
   1398          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000 A6CC                  LD        A, #0xcc
   \   000002 8D000000              CALLF     DS18_Write
   \   000006 A644                  LD        A, #0x44
   \   000008 8D000000              CALLF     DS18_Write
   \   00000C 5F                    CLRW      X
   \   00000D CF0000                LDW       L:timer2, X
   \   000010 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000 A6CC                  LD        A, #0xcc
   \   000002 8D000000              CALLF     DS18_Write
   \   000006 A6BE                  LD        A, #0xbe
   \   000008 8D000000              CALLF     DS18_Write
   \   00000C 8D000000              CALLF     DS18_Read
   \   000010 B700                  LD        S:?b8, A
   \   000012 8D000000              CALLF     DS18_Read
   \   000016 B700                  LD        S:?b9, A
   \   000018 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000 5F                    CLRW      X
   \   000001 41                    EXG       A, XL
   \   000002 B600                  LD        A, S:?b9
   \   000004 41                    EXG       A, XL
   \   000005 4F                    CLR       A
   \   000006 02                    RLWA      X, A
   \   000007 905F                  CLRW      Y
   \   000009 B600                  LD        A, S:?b8
   \   00000B 61                    EXG       A, YL
   \   00000C 90BF00                LDW       S:?w0, Y
   \   00000F 72BB0000              ADDW      X, S:?w0
   \   000013 54                    SRLW      X
   \   000014 54                    SRLW      X
   \   000015 54                    SRLW      X
   \   000016 9F                    LD        A, XL
   \   000017 87                    RETF
   1399          

   \                                 In section .far_func.text, align 1, keep-with-next
   1400          bool Read_DS18()
   1401          {
   \                     Read_DS18:
   \   000000 8D000000              CALLF     L:?push_w4
   1402          
   1403             //Init Reset Pulse
   1404               if(!DS18_Reset()) return FALSE;
   \   000004 8D000000              CALLF     ?Subroutine38
   \                     ??CrossCallReturnLabel_103:
   \   000008 2605                  JRNE      L:??Read_DS18_0
   \                     ??Read_DS18_1:
   \   00000A 4F                    CLR       A
   \   00000B AC000000              JPF       L:?epilogue_w4
   1405             //Skip ROM Command 0xCC
   1406              DS18_Write(0xCC);
   \                     ??Read_DS18_0:
   \   00000F 8D000000              CALLF     ?Subroutine37
   1407             //Function command  CONVERT T [44h]
   1408              DS18_Write(0x44);
   1409              //Wait util end convert
   1410              timer2=0;
   1411               while ((timer2 < 10000) && !(DS18_Read()));;
   \                     ??CrossCallReturnLabel_100:
   \   000013 8D000000              CALLF     ?Subroutine17
   \                     ??CrossCallReturnLabel_50:
   \   000017 2408                  JRNC      L:??Read_DS18_2
   \   000019 8D000000              CALLF     DS18_Read
   \   00001D A100                  CP        A, #0x0
   \   00001F 27F2                  JREQ      L:??CrossCallReturnLabel_100
   1412                if (timer2>10000) return FALSE;
   \                     ??Read_DS18_2:
   \   000021 CE0000                LDW       X, L:timer2
   \   000024 A32711                CPW       X, #0x2711
   \   000027 24E1                  JRNC      L:??Read_DS18_1
   1413               //u8 temp8=timer2;
   1414              //Init Reset Pulse
   1415              if(!DS18_Reset()) return FALSE;
   \   000029 8D000000              CALLF     ?Subroutine38
   \                     ??CrossCallReturnLabel_104:
   \   00002D 27DB                  JREQ      L:??Read_DS18_1
   1416              // Skip ROM Command 0xCC
   1417              DS18_Write(0xCC);
   \   00002F 8D000000              CALLF     ?Subroutine36
   1418              //Function command READ SCRATCHPAD [BEh]
   1419              DS18_Write(0xBE);
   1420               u8 temp1=DS18_Read();
   1421               u8 temp2=DS18_Read();
   1422               u8 temp3=DS18_Read();
   \                     ??CrossCallReturnLabel_98:
   \   000033 8D000000              CALLF     ?Subroutine40
   1423               u8 temp4=DS18_Read();
   1424               u8 temp5=DS18_Read();
   1425               u8 temp6=DS18_Read();
   \                     ??CrossCallReturnLabel_110:
   \   000037 8D000000              CALLF     ?Subroutine40
   1426               u8 temp7=DS18_Read();
   1427               u8 temp8=DS18_Read();
   1428               u8 temp9=DS18_Read();
   \                     ??CrossCallReturnLabel_109:
   \   00003B 8D000000              CALLF     DS18_Read
   1429          
   1430               DS18_Reset();
   \   00003F 8D000000              CALLF     DS18_Reset
   1431          
   1432                line_lcd=0;
   \   000043 725F0000              CLR       L:line_lcd
   1433                result2=0;
   \   000047 725F0000              CLR       L:result2
   1434                u16 result = temp2*256+temp1;
   1435                result1= (u8)(result>>3);
   \   00004B 8D000000              CALLF     ?Subroutine3
   \                     ??CrossCallReturnLabel_2:
   \   00004F C70000                LD        L:result1, A
   1436                if(result1%2!=0) result2=5;
   \   000052 7201000004            BTJF      L:result1, #0x0, L:??Read_DS18_3
   \   000057 35050000              MOV       L:result2, #0x5
   1437                result1 /=2;
   \                     ??Read_DS18_3:
   \   00005B 44                    SRL       A
   \   00005C C70000                LD        L:result1, A
   1438          
   1439          
   1440                printf("\n%d.%d",result1,result2);
   \   00005F C60000                LD        A, L:result2
   \   000062 5F                    CLRW      X
   \   000063 97                    LD        XL, A
   \   000064 89                    PUSHW     X
   \   000065 C60000                LD        A, L:result1
   \   000068 97                    LD        XL, A
   \   000069 89                    PUSHW     X
   \   00006A AE0000                LDW       X, #`?<Constant "\\n%d.%d">`
   \   00006D 8D000000              CALLF     printf
   \   000071 5B04                  ADD       SP, #0x4
   1441               // printf("\n%02x%02x%02x",temp1,temp2,temp5);
   1442               //line_lcd=1;
   1443               // printf("\n%02x%02x%02x",temp7,temp8,temp9);
   1444               // while (!key_ok_on());
   1445          
   1446               //u8 temp3=DS18_Read();
   1447          
   1448              return TRUE;
   \   000073 A601                  LD        A, #0x1
   \   000075 AC000000              JPF       L:?epilogue_w4
   1449          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000 8D000000              CALLF     DS18_Read
   \   000004 8D000000              CALLF     DS18_Read
   \   000008 AC000000              JPF       DS18_Read
   1450          

   \                                 In section .far_func.text, align 1, keep-with-next
   1451          bool DS18Set ()
   1452          {
   1453               //Init Reset Pulse
   1454              if(!DS18_Reset()) return FALSE;
   \                     DS18Set:
   \   000000 8D000000              CALLF     ?Subroutine38
   \                     ??CrossCallReturnLabel_102:
   \   000004 2602                  JRNE      L:??DS18Set_0
   \   000006 4F                    CLR       A
   \   000007 87                    RETF
   1455             //Skip ROM Command 0xCC
   1456              DS18_Write(0xCC);
   \                     ??DS18Set_0:
   \   000008 A6CC                  LD        A, #0xcc
   \   00000A 8D000000              CALLF     DS18_Write
   1457             //Function command  WRITE SCRATCHPAD 0x4E
   1458              DS18_Write(0x4E);
   \   00000E A64E                  LD        A, #0x4e
   \   000010 8D000000              CALLF     DS18_Write
   1459             //Write 3 bytes last is config reg
   1460              DS18_Write(125);
   \   000014 A67D                  LD        A, #0x7d
   \   000016 8D000000              CALLF     DS18_Write
   1461              DS18_Write(0xDC); //-55
   \   00001A A6DC                  LD        A, #0xdc
   \   00001C 8D000000              CALLF     DS18_Write
   1462              DS18_Write(0x1F);
   \   000020 A61F                  LD        A, #0x1f
   \   000022 8D000000              CALLF     DS18_Write
   1463          
   1464          
   1465          
   1466          
   1467            return TRUE;
   \   000026 A601                  LD        A, #0x1
   \   000028 87                    RETF
   1468          }
   1469          
   1470          
   1471          
   1472          
   1473           /*
   1474          u16 Average()
   1475          {
   1476           //Find average in measure
   1477            u8 i=0;
   1478            u16 Summa=0;
   1479            do
   1480            {
   1481             Summa+=measure[i++];
   1482            } while ( measure[i]!=0);
   1483             if(i!=0) Summa=Summa/i;
   1484             return Summa;
   1485          }
   1486             */
   1487          

   \                                 In section .far_func.text, align 1, keep-with-next
   1488          PUTCHAR_PROTOTYPE
   1489          {
   \                     fputc:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
   1490            /* Place your implementation of fputc here */
   1491            /* e.g. write a character to the USART */
   1492                //USART_SendData(USART3, (u8) ch);
   1493               LCD(ch);
   \   000006 B600                  LD        A, S:?b9
   \   000008 8D000000              CALLF     LCD
   1494             /* Loop until the end of transmission */
   1495              //while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET);;
   1496            return ch;
   \   00000C BE00                  LDW       X, S:?w4
   \   00000E AC000000              JPF       L:?epilogue_w4
   1497          }
   1498          
   1499          

   \                                 In section .far_func.text, align 1, keep-with-next
   1500          void Delay1(u16 Delay)
   1501          {
   \                     Delay1:
   \   000000 BF00                  LDW       S:?w0, X
   1502              //1 = 40us,2=60us,3=80us,10=200us, 15=320us,
   1503            timer1=0;
   \   000002 5F                    CLRW      X
   \   000003 CF0000                LDW       L:timer1, X
   1504            while ( timer1 < Delay); ;
   \                     ??Delay1_0:
   \   000006 CE0000                LDW       X, L:timer1
   \   000009 B300                  CPW       X, S:?w0
   \   00000B 25F9                  JRC       L:??Delay1_0
   1505          }
   \   00000D 87                    RETF
   1506          

   \                                 In section .far_func.text, align 1, keep-with-next
   1507           void Delay2(u16 Delay)
   1508          {
   \                     Delay2:
   \   000000 BF00                  LDW       S:?w0, X
   1509            timer2=0;
   \   000002 5F                    CLRW      X
   \   000003 CF0000                LDW       L:timer2, X
   1510            while ( timer2 < Delay); ;
   \                     ??Delay2_0:
   \   000006 CE0000                LDW       X, L:timer2
   \   000009 B300                  CPW       X, S:?w0
   \   00000B 25F9                  JRC       L:??Delay2_0
   1511          }
   \   00000D 87                    RETF
   1512          
   1513          

   \                                 In section .far_func.text, align 1, keep-with-next
   1514          void Delay_us (u16 time) //1:3.2us,100:39us,200:77us,35:15.2us,120:45us,160:60us
   1515          {
   1516            //disableInterrupts();
   1517            do
   1518              {
   1519                time--;
   \                     Delay_us:
   \                     ??Delay_us_0:
   \   000000 5A                    DECW      X
   1520                nop();
   \   000001 9D                    NOP
   1521              }
   1522              while (time);
   \   000002 5D                    TNZW      X
   \   000003 26FB                  JRNE      L:??Delay_us_0
   1523            //enableInterrupts();
   1524          }
   \   000005 87                    RETF
   1525          
   1526          
   1527          
   1528          /*
   1529          void Delay12 (u16 Delay)
   1530          {
   1531            timer2=0;
   1532            while ( timer2 < Delay); ;
   1533          }
   1534          */
   1535          
   1536          
   1537          #ifdef USE_FULL_ASSERT
   1538          
   1539          /**
   1540            * @brief  Reports the name of the source file and the source line number
   1541            *   where the assert_param error has occurred.
   1542            * @param file: pointer to the source file name
   1543            * @param line: assert_param error line source number
   1544            * @retval : None
   1545            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1546          void assert_failed(u8* file, u32 line)
   1547          {
   1548            /* User can add his own implementation to report the file name and line number,
   1549               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
   1550          
   1551            /* Infinite loop */
   1552            while (1)
   \                     assert_failed:
   \                     ??assert_failed_0:
   \   000000 20FE                  JRA       L:??assert_failed_0
   1553            {
   1554          
   1555            }
   1556          }
   1557          #endif
   1558          
   1559          

   \                                 In section .far_func.text, align 1, keep-with-next
   1560          void Display_Line(char* line)
   1561          {
   \                     Display_Line:
   \   000000 8D000000              CALLF     L:?push_l2
   1562            char current_char= *line++;
   \   000004 F6                    LD        A, (X)
   \   000005 B700                  LD        S:?b11, A
   \   000007 5C                    INCW      X
   \   000008 BF00                  LDW       S:?w4, X
   1563            u8 count;
   1564              //Set Cursor to First Line
   1565             LCDInstr(0x80 | 0x00);
   \   00000A A680                  LD        A, #0x80
   \   00000C 8D000000              CALLF     LCDInstr
   1566             count=0;
   \   000010 3F00                  CLR       S:?b10
   1567             Delay1(1);
   \   000012 8D000000              CALLF     ??Subroutine63_0
   1568            do
   1569            {
   1570          
   1571              if (current_char > 0x1b)   //Display only valid data
   \                     ??CrossCallReturnLabel_181:
   \   000016 B600                  LD        A, S:?b11
   \   000018 A11C                  CP        A, #0x1c
   \   00001A 2509                  JRC       L:??Display_Line_0
   1572               {
   1573                 LCDData(current_char);
   \   00001C 8D000000              CALLF     ?Subroutine10
   1574                  Delay1(1);
   1575                 count++;
   \                     ??CrossCallReturnLabel_179:
   \   000020 B600                  LD        A, S:?b10
   \   000022 4C                    INC       A
   \   000023 B700                  LD        S:?b10, A
   1576               }
   1577               current_char=*line++;
   \                     ??Display_Line_0:
   \   000025 92C600                LD        A, [S:?w4.w]
   \   000028 B700                  LD        S:?b11, A
   \   00002A BE00                  LDW       X, S:?w4
   \   00002C 5C                    INCW      X
   \   00002D BF00                  LDW       S:?w4, X
   1578            }  while ((current_char != 0x00) && (count<7));
   \   00002F 3D00                  TNZ       S:?b11
   \   000031 2706                  JREQ      L:??Display_Line_1
   \   000033 B600                  LD        A, S:?b10
   \   000035 A107                  CP        A, #0x7
   \   000037 25DD                  JRC       L:??CrossCallReturnLabel_181
   1579          
   1580             Rotate_Line(line1);
   \                     ??Display_Line_1:
   \   000039 AE0000                LDW       X, #line1
   \   00003C 8D000000              CALLF     Rotate_Line
   1581          
   1582          }
   \   000040 AC000000              JPF       L:?epilogue_l2
   1583          

   \                                 In section .far_func.text, align 1, keep-with-next
   1584          void Rotate_Line( char * line)
   1585          {
   1586          
   1587             char temp_first = *line;
   \                     Rotate_Line:
   \   000000 F6                    LD        A, (X)
   \   000001 B700                  LD        S:?b0, A
   1588             char temp_next;
   1589          
   1590             do
   1591             {
   1592                temp_next=*(line+1);
   1593               *line++=temp_next;
   \                     ??Rotate_Line_0:
   \   000003 9093                  LDW       Y, X
   \   000005 905C                  INCW      Y
   \   000007 90F6                  LD        A, (Y)
   \   000009 F7                    LD        (X), A
   \   00000A 93                    LDW       X, Y
   1594                //line++;
   1595                //temp_next=*line;
   1596               //*line=*line++;
   1597             } while (*line !=0);
   \   00000B 7D                    TNZ       (X)
   \   00000C 26F5                  JRNE      L:??Rotate_Line_0
   1598             line--;
   1599             *line=temp_first;
   \   00000E 5A                    DECW      X
   \   00000F B600                  LD        A, S:?b0
   \   000011 F7                    LD        (X), A
   1600          
   1601          }
   \   000012 87                    RETF
   1602          

   \                                 In section .far_func.text, align 1, keep-with-next
   1603          void Clear_Line1 ()
   1604          {
   \                     Clear_Line1:
   \   000000 3B0000                PUSH      S:?b8
   1605               //Set Cursor to First Line
   1606             LCDInstr(0x80 | 0x00);
   \   000003 A680                  LD        A, #0x80
   \   000005 8D000000              CALLF     ?Subroutine9
   1607             count=0;
   1608             Delay1(1);
   1609              u8 count=0;
   1610             do
   1611             {
   1612               LCDData(' ');
   \                     ??CrossCallReturnLabel_21:
   \   000009 8D000000              CALLF     ?Subroutine8
   1613                  Delay1(1);
   1614                  count++;
   1615             }while (count<8);
   \                     ??CrossCallReturnLabel_19:
   \   00000D 26FA                  JRNE      L:??CrossCallReturnLabel_21
   1616          
   1617          
   1618          }
   \   00000F 320000                POP       S:?b8
   \   000012 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000 8D000000              CALLF     ?Subroutine56
   \                     ??CrossCallReturnLabel_146:
   \   000004 8D000000              CALLF     ?Subroutine51
   \                     ??CrossCallReturnLabel_187:
   \   000008 35080000              MOV       S:?b8, #0x8
   \   00000C 87                    RETF

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000 A620                  LD        A, #0x20
   \   000002 8D000000              CALLF     LCDData
   \   000006 8D000000              CALLF     ?Subroutine51
   \                     ??CrossCallReturnLabel_186:
   \   00000A B600                  LD        A, S:?b8
   \   00000C 4A                    DEC       A
   \   00000D B700                  LD        S:?b8, A
   \   00000F 87                    RETF
   1619          

   \                                 In section .far_func.text, align 1, keep-with-next
   1620          void Clear_Line2 ()
   1621          {
   \                     Clear_Line2:
   \   000000 3B0000                PUSH      S:?b8
   1622               //Set Cursor to Second  Line
   1623             LCDInstr(0x80 | 0x40);
   \   000003 A6C0                  LD        A, #0xc0
   \   000005 8D000000              CALLF     ?Subroutine9
   1624             count=0;
   1625             Delay1(1);
   1626              u8 count=0;
   1627             do
   1628             {
   1629               LCDData(' ');
   \                     ??CrossCallReturnLabel_20:
   \   000009 8D000000              CALLF     ?Subroutine8
   1630                  Delay1(1);
   1631                  count++;
   1632             }while (count<8);
   \                     ??CrossCallReturnLabel_18:
   \   00000D 26FA                  JRNE      L:??CrossCallReturnLabel_20
   1633          
   1634          
   1635          }
   \   00000F 320000                POP       S:?b8
   \   000012 87                    RETF
   1636          
   1637          
   1638          
   1639          
   1640          

   \                                 In section .far_func.text, align 1, keep-with-next
   1641          void Menu (void)
   1642          {
   1643           // Clear Display
   1644              LCDInstr(0x01); //Clear LCD
   \                     Menu:
   \   000000 8D000000              CALLF     ?Subroutine15
   1645              Delay1(250);
   1646           /* First Line 1. Time On 2. Time off 3.Timer ON/OFF 4.Exit
   1647              Wait for Plus,Minius or OK
   1648              If plus next option from Menu on the end EXIT
   1649              If minus previous option from Menu  on the end EXIT
   1650              If OK enter to menu option
   1651              If time out about 20s exit from Menu
   1652           */
   1653          
   1654          First_Menu:
   1655              line_lcd=0;
   \                     ??CrossCallReturnLabel_45:
   \   000004 725F0000              CLR       L:line_lcd
   1656              printf("\nTime ON");
   \   000008 AE0000                LDW       X, #`?<Constant "\\nTime ON">`
   \   00000B 8D000000              CALLF     ?Subroutine31
   1657              line_lcd=1;
   1658              printf("\n%02d:%02d",daily_hour_on,daily_minute_on);
   \                     ??CrossCallReturnLabel_84:
   \   00000F C60000                LD        A, L:daily_minute_on
   \   000012 5F                    CLRW      X
   \   000013 97                    LD        XL, A
   \   000014 89                    PUSHW     X
   \   000015 C60000                LD        A, L:daily_hour_on
   \   000018 97                    LD        XL, A
   \   000019 89                    PUSHW     X
   \   00001A AE0000                LDW       X, #`?<Constant "\\n%02d:%02d">`
   \   00001D 8D000000              CALLF     printf
   \   000021 5B04                  ADD       SP, #0x4
   1659               //Wait for key or timer end
   1660          
   1661                /*
   1662              u8 select= Key_Press();
   1663              if (select==1) Set_Timer_On(); // Set Timer_On
   1664               else if (select==3) nop();// Menu Exit
   1665                else if (select==2)  //Dislpay next select
   1666                {
   1667                   line_lcd=1;
   1668                   printf("/nTimer OFF");
   1669                   line_lcd=2;
   1670                   printf("\n%02d:%02d",daily_hour_off,daily_minute_off);
   1671                }
   1672                  */
   1673          
   1674          
   1675                  switch (Key_Press())
   \   000023 8D000000              CALLF     Key_Press
   \   000027 4A                    DEC       A
   \   000028 2708                  JREQ      L:??Menu_0
   \   00002A 4A                    DEC       A
   \   00002B 270B                  JREQ      L:??Menu_1
   \   00002D 4A                    DEC       A
   \   00002E 273C                  JREQ      L:??Menu_2
   \   000030 205A                  JRA       L:??Menu_3
   1676                  {
   1677                  case 1: Set_Timer_On();
   \                     ??Menu_0:
   \   000032 8D000000              CALLF     Set_Timer_On
   1678                   break;
   \   000036 2054                  JRA       L:??Menu_3
   1679                  case 2: goto Second_Menu ;
   1680                   break;
   1681                  case 3: goto Exit_Menu;
   1682                   break;
   1683                  }
   1684                  goto exit;
   1685          
   1686          Second_Menu:
   1687              line_lcd=0;
   \                     ??Menu_1:
   \   000038 725F0000              CLR       L:line_lcd
   1688              printf("\nTime Off");
   \   00003C AE0000                LDW       X, #`?<Constant "\\nTime Off">`
   \   00003F 8D000000              CALLF     ?Subroutine31
   1689              line_lcd=1;
   1690              printf("\n%02d:%02d",daily_hour_off,daily_minute_off);
   \                     ??CrossCallReturnLabel_85:
   \   000043 C60000                LD        A, L:daily_minute_off
   \   000046 5F                    CLRW      X
   \   000047 97                    LD        XL, A
   \   000048 89                    PUSHW     X
   \   000049 C60000                LD        A, L:daily_hour_off
   \   00004C 97                    LD        XL, A
   \   00004D 89                    PUSHW     X
   \   00004E AE0000                LDW       X, #`?<Constant "\\n%02d:%02d">`
   \   000051 8D000000              CALLF     printf
   \   000055 5B04                  ADD       SP, #0x4
   1691                switch (Key_Press())
   \   000057 8D000000              CALLF     Key_Press
   \   00005B 4A                    DEC       A
   \   00005C 2708                  JREQ      L:??Menu_4
   \   00005E 4A                    DEC       A
   \   00005F 270B                  JREQ      L:??Menu_2
   \   000061 4A                    DEC       A
   \   000062 27A0                  JREQ      L:??CrossCallReturnLabel_45
   \   000064 2026                  JRA       L:??Menu_3
   1692                  {
   1693                  case 1: Set_Timer_Off();
   \                     ??Menu_4:
   \   000066 8D000000              CALLF     Set_Timer_Off
   1694                   break;
   \   00006A 2020                  JRA       L:??Menu_3
   1695                  case 2: goto Exit_Menu ;
   1696                   break;
   1697                  case 3: goto First_Menu;
   1698                   break;
   1699                  }
   1700               goto exit;
   1701          
   1702          Exit_Menu:
   1703              line_lcd=0;
   \                     ??Menu_2:
   \   00006C 725F0000              CLR       L:line_lcd
   1704              printf("\nExit OK ");
   \   000070 AE0000                LDW       X, #`?<Constant "\\nExit OK ">`
   \   000073 8D000000              CALLF     ?Subroutine31
   1705              line_lcd=1;
   1706              printf("\n+/-     ");
   \                     ??CrossCallReturnLabel_86:
   \   000077 AE0000                LDW       X, #`?<Constant "\\n+/-     ">`
   \   00007A 8D000000              CALLF     printf
   1707                 switch (Key_Press())
   \   00007E 8D000000              CALLF     Key_Press
   \   000082 A002                  SUB       A, #0x2
   \   000084 2603                  JRNE      ??lb_0
   \   000086 CC0000                JP        L:??CrossCallReturnLabel_45
   \                     ??lb_0:
   \   000089 4A                    DEC       A
   \   00008A 27AC                  JREQ      L:??Menu_1
   1708                  {
   1709                  case 1: goto exit ;
   1710                   break;
   1711                  case 2: goto First_Menu ;
   1712                   break;
   1713                  case 3: goto Second_Menu;
   1714                   break;
   1715                  }
   1716          
   1717          exit:
   1718             Clear_Line1();
   \                     ??Menu_3:
   \   00008C 8D000000              CALLF     Clear_Line1
   1719             Clear_Line2();
   \   000090 AC000000              JPF       Clear_Line2
   1720          
   1721          }

   \                                 In section .far_func.text, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000 8D000000              CALLF     printf
   \   000004 35010000              MOV       L:line_lcd, #0x1
   \   000008 87                    RETF
   1722          
   1723          

   \                                 In section .far_func.text, align 1
   1724          u8 Key_Press(void)
   1725          {
   1726             u8 key_press =0;
   1727             timer2=0;
   \                     Key_Press:
   \   000000 5F                    CLRW      X
   \   000001 CF0000                LDW       L:timer2, X
   1728             do {
   1729                if (key_ok_on()) key_press=1;
   \                     ??Key_Press_0:
   \   000004 8D000000              CALLF     ?Subroutine18
   \                     ??CrossCallReturnLabel_52:
   \   000008 2703                  JREQ      L:??Key_Press_1
   \   00000A A601                  LD        A, #0x1
   \   00000C 87                    RETF
   1730                 else if (key_plus_on())key_press=2;
   \                     ??Key_Press_1:
   \   00000D 8D000000              CALLF     key_plus_on
   \   000011 A100                  CP        A, #0x0
   \   000013 2703                  JREQ      L:??Key_Press_2
   \   000015 A602                  LD        A, #0x2
   \   000017 87                    RETF
   1731                  else if (key_minus_on())key_press=3;
   \                     ??Key_Press_2:
   \   000018 8D000000              CALLF     key_minus_on
   \   00001C A100                  CP        A, #0x0
   \   00001E 27E4                  JREQ      L:??Key_Press_0
   \   000020 A603                  LD        A, #0x3
   1732             } while ( !key_press);    //timer2<=time_menu) &&
   1733          
   1734             return key_press;
   \   000022 87                    RETF
   1735          }

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nDS_Err_I">`:
   \   000000 0A44535F4572          DC8 "\012DS_Err_I"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\n E2:%d">`:
   \   000000 0A2045323A25          DC8 "\012 E2:%d"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\n E:%d">`:
   \   000000 0A20453A2564          DC8 "\012 E:%d"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nSetClock">`:
   \   000000 0A536574436C          DC8 "\012SetClock"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "TIMER ON">`:
   \   000000 54494D455220          DC8 "TIMER ON"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "TIMER OFF">`:
   \   000000 54494D455220          DC8 "TIMER OFF"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "%d.%dC %s ">`:
   \   000000 25642E256443          DC8 "%d.%dC %s "

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\n%02d:%02d:%02d">`:
   \   000000 0A253032643A          DC8 "\012%02d:%02d:%02d"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nYears:">`:
   \   000000 0A5965617273          DC8 "\012Years:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nMounts:">`:
   \   000000 0A4D6F756E74          DC8 "\012Mounts:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nDate:">`:
   \   000000 0A446174653A          DC8 "\012Date:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nDays:">`:
   \   000000 0A446179733A          DC8 "\012Days:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\n%02d">`:
   \   000000 0A2530326400          DC8 "\012%02d"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nHours:">`:
   \   000000 0A486F757273          DC8 "\012Hours:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nMinutes:">`:
   \   000000 0A4D696E7574          DC8 "\012Minutes:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nSeconds:">`:
   \   000000 0A5365636F6E          DC8 "\012Seconds:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nH On:">`:
   \   000000 0A48204F6E3A          DC8 "\012H On:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\n%02d:%02d">`:
   \   000000 0A253032643A          DC8 "\012%02d:%02d"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nMin On:">`:
   \   000000 0A4D696E204F          DC8 "\012Min On:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nH Off:">`:
   \   000000 0A48204F6666          DC8 "\012H Off:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nMin Off:">`:
   \   000000 0A4D696E204F          DC8 "\012Min Off:"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\n%d.%d">`:
   \   000000 0A25642E2564          DC8 "\012%d.%d"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nTime ON">`:
   \   000000 0A54696D6520          DC8 "\012Time ON"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nTime Off">`:
   \   000000 0A54696D6520          DC8 "\012Time Off"

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\nExit OK ">`:
   \   000000 0A4578697420          DC8 "\012Exit OK "

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "\\n+/-     ">`:
   \   000000 0A2B2F2D2020          DC8 "\012+/-     "
   1736          
   1737          
   1738          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     timer1                            2
     timer2                            2
     timeout                           1
     adcdata                           2
     rx_data                           1
     line_lcd                          1
     count                             1
     seconds                           1
     minutes                           1
     hours                             1
     days                              1
     date                              1
     mounts                            1
     years                             1
     error                             1
     temp_flag                         1
     temp2                             1
     daily_hour_on                     1
     daily_minute_on                   1
     daily_hour_off                    1
     daily_minute_off                  1
     daily_long_on                     2
     time_on                           2
     time_off                          2
     ttimer                            1
     result1                           1
     result2                           1
     result_old                        1
     l                                 1
     status_check                      2
     test1                             1
     test2                             1
     line1                            40
     string1                          10
     change                            1
     result                            4
     k                                 2
     status                            2
     ?Subroutine18                     7
     ??Subroutine64_0                  7
     main                            528
     ?Subroutine41                     2
     ??Subroutine67_0                  8
     ?Subroutine32                    10
     ?Subroutine27                     7
     ?Subroutine58                     7
     ?Subroutine25                     2
     ??Subroutine68_0                 12
     ?Subroutine13                    16
     ?Subroutine5                      9
     Power_On                         11
     ?Subroutine34                    23
     Power_Off                        11
     InitI2C                          38
     I2C_Start                        38
     ?Subroutine47                     7
     I2C_WA                           38
     I2C_RA                           40
     I2C_WD                           36
     I2C_RD                           35
     ?Subroutine49                     1
     ??Subroutine66_0                  7
     ?Subroutine46                     9
     ?Subroutine44                    11
     ReadDS1307                      109
     ?Subroutine20                    11
     ?Subroutine16                    13
     ?Subroutine12                     8
     ?Subroutine53                    10
     Check_DS1307                     64
     Set_DS1307                      108
     ?Subroutine48                    11
     convert_tobcd                    23
     bcd2hex                          23
     ?Subroutine19                     6
     ??Subroutine62_0                  5
     ?Subroutine11                    16
     ?Subroutine52                     6
     Set_Clock                       395
     ?Subroutine33                    10
     adj                              77
     ?Subroutine54                     7
     key_ok_on                        41
     key_plus_on                      37
     ?Subroutine14                     7
     ?Subroutine7                      7
     key_minus_on                     37
     key_ok_plus                      40
     ?Subroutine2                     26
     ?Subroutine1                     10
     ??Subroutine61_0                 29
     Set_Timer_On                    133
     ?Subroutine35                     5
     ?Subroutine50                     9
     ?Subroutine6                     13
     Set_Timer_Off                   133
     Save_Status                      10
     Read_Allarm                     123
     EEPROM_INIT                      15
     GpioConfiguration               103
     ?Subroutine43                     9
     ?Subroutine42                     9
     ?Subroutine39                    12
     InitClk                          56
     ?Subroutine45                     9
     InitAdc                          45
     SendChar                         15
     LCDDataOut                       87
     ?Subroutine24                     7
     ??Subroutine60_0                  5
     ?Subroutine55                     7
     ?Subroutine23                     2
     ?Subroutine22                     4
     ??Subroutine65_0                  7
     InitLcd                          84
     ?Subroutine21                    13
     ?Subroutine15                    11
     ?Subroutine0                     11
     ??Subroutine59_0                 10
     ?Subroutine30                    10
     LCDInstr                         11
     LCDData                          11
     LCDInstrNibble                   15
     PulseEnable                      16
     ?Subroutine4                     24
     ?Subroutine51                     6
     LCD_Busy                         67
     LCD                             174
     ?Subroutine56                     9
     ?Subroutine10                     4
     ??Subroutine63_0                  5
     InitDelayTimer                   29
     DS18_Write                       57
     ?Subroutine28                     2
     ?Subroutine26                    10
     ?Subroutine57                     7
     DS18_Read                        77
     ?Subroutine29                    12
     DS18_Reset                       49
     ?Subroutine17                     7
     ?Subroutine38                     7
     temperature                      63
     ?Subroutine37                    17
     ?Subroutine36                    25
     ?Subroutine3                     24
     Read_DS18                       121
     ?Subroutine40                    12
     DS18Set                          41
     fputc                            18
     Delay1                           14
     Delay2                           14
     Delay_us                          6
     assert_failed                     2
     Display_Line                     68
     Rotate_Line                      19
     Clear_Line1                      19
     ?Subroutine9                     13
     ?Subroutine8                     16
     Clear_Line2                      19
     Menu                            148
     ?Subroutine31                     9
     Key_Press                        35
     ?<Constant "\nDS_Err_I">         10
     ?<Constant "\n E2:%d">            8
     ?<Constant "\n E:%d">             7
     ?<Constant "\nSetClock">         10
     ?<Constant "TIMER ON">            9
     ?<Constant "TIMER OFF">          10
     ?<Constant "%d.%dC %s ">         11
     ?<Constant "\n%02d:%02d:%02d">   16
     ?<Constant "\nYears:">            8
     ?<Constant "\nMounts:">           9
     ?<Constant "\nDate:">             7
     ?<Constant "\nDays:">             7
     ?<Constant "\n%02d">              6
     ?<Constant "\nHours:">            8
     ?<Constant "\nMinutes:">         10
     ?<Constant "\nSeconds:">         10
     ?<Constant "\nH On:">             7
     ?<Constant "\n%02d:%02d">        11
     ?<Constant "\nMin On:">           9
     ?<Constant "\nH Off:">            8
     ?<Constant "\nMin Off:">         10
     ?<Constant "\n%d.%d">             7
     ?<Constant "\nTime ON">           9
     ?<Constant "\nTime Off">         10
     ?<Constant "\nExit OK ">         10
     ?<Constant "\n+/-     ">         10

 
 4 315 bytes in section .far_func.text
    95 bytes in section .near.bss
     3 bytes in section .near.data
   237 bytes in section .near.rodata
 
 4 315 bytes of CODE  memory
   237 bytes of CONST memory
    98 bytes of DATA  memory

Errors: none
Warnings: none
