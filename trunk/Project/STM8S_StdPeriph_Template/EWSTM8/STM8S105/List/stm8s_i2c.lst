###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             11/Sep/2013  20:03:35 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s_ #
#                    i2c.c                                                    #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s #
#                    _i2c.c" -e -Ohz --debug --code_model medium              #
#                    --data_model medium -o "C:\Documents and                 #
#                    Settings\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\Obj\"       #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\stm8\LIB\dlstm8mmf.h" -D STM8S105 -lC      #
#                    "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\ST #
#                    M8S105\List\" -lA "C:\Documents and                      #
#                    Settings\Administrator\Desktop\stm8s105k-controller\Proj #
#                    ect\STM8S_StdPeriph_Template\EWSTM8\STM8S105\List\" -I   #
#                    "C:\Documents and Settings\Administrator\Desktop\stm8s10 #
#                    5k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\.. #
#                    \" -I "C:\Documents and Settings\Administrator\Desktop\s #
#                    tm8s105k-controller\Project\STM8S_StdPeriph_Template\EWS #
#                    TM8\..\..\..\Libraries\STM8S_StdPeriph_Driver\inc\"      #
#                    --vregs 16                                               #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\STM #
#                    8S105\List\stm8s_i2c.lst                                 #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\stm8s105 #
#                    k-controller\Project\STM8S_StdPeriph_Template\EWSTM8\STM #
#                    8S105\Obj\stm8s_i2c.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\stm8s105k-controller\Libraries\STM8S_StdPeriph_Driver\src\stm8s_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_i2c.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the I2C peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_i2c.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /* Private typedef -----------------------------------------------------------*/
     29          
     30          /** @defgroup I2C_Private_Defines
     31            * @{
     32            */
     33          /* I2C register mask */
     34          #define REGISTER_Mask               ((uint16_t)0x3000)
     35          #define REGISTER_SR1_Index          ((uint16_t)0x0100)
     36          #define REGISTER_SR2_Index          ((uint16_t)0x0200)
     37          /* I2C Interrupt Enable mask */
     38          #define ITEN_Mask                   ((uint16_t)0x0700)
     39          /* I2C FLAG mask */
     40          #define FLAG_Mask                   ((uint16_t)0x00FF)
     41          /**
     42            * @}
     43            */
     44          
     45          /* Private macro -------------------------------------------------------------*/
     46          /* Private variables ---------------------------------------------------------*/
     47          /* Private function prototypes -----------------------------------------------*/
     48          /* Private functions ---------------------------------------------------------*/
     49          
     50          
     51          /**
     52            * @addtogroup I2C_Public_Functions
     53            * @{
     54            */
     55          
     56          /**
     57            * @brief  Deinitializes the I2C peripheral registers to their default reset values.
     58            * @param  None
     59            * @retval None
     60            */

   \                                 In section .far_func.text, align 1
     61          void I2C_DeInit(void)
     62          {
     63            I2C->CR1 = I2C_CR1_RESET_VALUE;
   \                     I2C_DeInit:
   \   000000 725F5210              CLR       L:0x5210
     64            I2C->CR2 = I2C_CR2_RESET_VALUE;
   \   000004 725F5211              CLR       L:0x5211
     65            I2C->FREQR = I2C_FREQR_RESET_VALUE;
   \   000008 725F5212              CLR       L:0x5212
     66            I2C->OARL = I2C_OARL_RESET_VALUE;
   \   00000C 725F5213              CLR       L:0x5213
     67            I2C->OARH = I2C_OARH_RESET_VALUE;
   \   000010 725F5214              CLR       L:0x5214
     68            I2C->ITR = I2C_ITR_RESET_VALUE;
   \   000014 725F521A              CLR       L:0x521a
     69            I2C->CCRL = I2C_CCRL_RESET_VALUE;
   \   000018 725F521B              CLR       L:0x521b
     70            I2C->CCRH = I2C_CCRH_RESET_VALUE;
   \   00001C 725F521C              CLR       L:0x521c
     71            I2C->TRISER = I2C_TRISER_RESET_VALUE;
   \   000020 3502521D              MOV       L:0x521d, #0x2
     72          }
   \   000024 87                    RETF
     73          
     74          /**
     75            * @brief  Initializes the I2C according to the specified parameters in standard
     76            *         or fast mode.
     77            * @param  OutputClockFrequencyHz : Specifies the output clock frequency in Hz.
     78            * @param  OwnAddress : Specifies the own address.
     79            * @param  I2C_DutyCycle : Specifies the duty cycle to apply in fast mode.
     80            *         This parameter can be any of the  @ref I2C_DutyCycle_TypeDef enumeration.
     81            * @note   This parameter don't have impact when the OutputClockFrequency lower
     82            *         than 100KHz.
     83            * @param  Ack : Specifies the acknowledge mode to apply.
     84            *         This parameter can be any of the  @ref I2C_Ack_TypeDef enumeration.
     85            * @param  AddMode : Specifies the acknowledge address to apply.
     86            *         This parameter can be any of the  @ref I2C_AddMode_TypeDef enumeration.
     87            * @param  InputClockFrequencyMHz : Specifies the input clock frequency in MHz.
     88            * @retval None
     89            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine0:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w0, X
   \   000005 AE0000                LDW       X, #`?<Constant "C:\\\\Documents and Sett...">`
   \   000008 AC000000              JPF       assert_failed

   \                                 In section .far_func.text, align 1
     90          void I2C_Init(uint32_t OutputClockFrequencyHz, uint16_t OwnAddress, 
     91                        I2C_DutyCycle_TypeDef I2C_DutyCycle, I2C_Ack_TypeDef Ack, 
     92                        I2C_AddMode_TypeDef AddMode, uint8_t InputClockFrequencyMHz )
     93          {
   \                     I2C_Init:
   \   000000 8D000000              CALLF     L:?push_l2
   \   000004 8D000000              CALLF     L:?push_l3
   \   000008 89                    PUSHW     X
   \   000009 88                    PUSH      A
   \   00000A 3B0000                PUSH      S:?b4
   \   00000D 3B0000                PUSH      S:?b5
   \   000010 3B0000                PUSH      S:?b6
   \   000013 5201                  SUB       SP, #0x1
   \   000015 8D000000              CALLF     L:?mov_l2_l0
     94            uint16_t result = 0x0004;
     95            uint16_t tmpval = 0;
     96            uint8_t tmpccrh = 0;
   \   000019 4F                    CLR       A
   \   00001A 6B01                  LD        (0x1,SP), A
     97          
     98            /* Check the parameters */
     99            assert_param(IS_I2C_ACK_OK(Ack));
   \   00001C 0D04                  TNZ       (0x4,SP)
   \   00001E 2711                  JREQ      L:??CrossCallReturnLabel_5
   \   000020 7B04                  LD        A, (0x4,SP)
   \   000022 A101                  CP        A, #0x1
   \   000024 270B                  JREQ      L:??CrossCallReturnLabel_5
   \   000026 A102                  CP        A, #0x2
   \   000028 2707                  JREQ      L:??CrossCallReturnLabel_5
   \   00002A AE0063                LDW       X, #0x63
   \   00002D 8D000000              CALLF     ?Subroutine0
    100            assert_param(IS_I2C_ADDMODE_OK(AddMode));
   \                     ??CrossCallReturnLabel_5:
   \   000031 0D03                  TNZ       (0x3,SP)
   \   000033 270D                  JREQ      L:??CrossCallReturnLabel_4
   \   000035 7B03                  LD        A, (0x3,SP)
   \   000037 A180                  CP        A, #0x80
   \   000039 2707                  JREQ      L:??CrossCallReturnLabel_4
   \   00003B AE0064                LDW       X, #0x64
   \   00003E 8D000000              CALLF     ?Subroutine0
    101            assert_param(IS_I2C_OWN_ADDRESS_OK(OwnAddress));
   \                     ??CrossCallReturnLabel_4:
   \   000042 1E06                  LDW       X, (0x6,SP)
   \   000044 A30400                CPW       X, #0x400
   \   000047 2507                  JRC       L:??CrossCallReturnLabel_3
   \   000049 AE0065                LDW       X, #0x65
   \   00004C 8D000000              CALLF     ?Subroutine0
    102            assert_param(IS_I2C_DUTYCYCLE_OK(I2C_DutyCycle));  
   \                     ??CrossCallReturnLabel_3:
   \   000050 0D05                  TNZ       (0x5,SP)
   \   000052 270D                  JREQ      L:??CrossCallReturnLabel_2
   \   000054 7B05                  LD        A, (0x5,SP)
   \   000056 A140                  CP        A, #0x40
   \   000058 2707                  JREQ      L:??CrossCallReturnLabel_2
   \   00005A AE0066                LDW       X, #0x66
   \   00005D 8D000000              CALLF     ?Subroutine0
    103            assert_param(IS_I2C_INPUT_CLOCK_FREQ_OK(InputClockFrequencyMHz));
   \                     ??CrossCallReturnLabel_2:
   \   000061 7B02                  LD        A, (0x2,SP)
   \   000063 4A                    DEC       A
   \   000064 A110                  CP        A, #0x10
   \   000066 2507                  JRC       L:??CrossCallReturnLabel_1
   \   000068 AE0067                LDW       X, #0x67
   \   00006B 8D000000              CALLF     ?Subroutine0
    104            assert_param(IS_I2C_OUTPUT_CLOCK_FREQ_OK(OutputClockFrequencyHz));
   \                     ??CrossCallReturnLabel_1:
   \   00006F BE00                  LDW       X, S:?w4
   \   000071 2602                  JRNE      L:??I2C_Init_0
   \   000073 BE00                  LDW       X, S:?w5
   \                     ??I2C_Init_0:
   \   000075 270E                  JREQ      L:??I2C_Init_1
   \   000077 BE00                  LDW       X, S:?w4
   \   000079 A30006                CPW       X, #0x6
   \   00007C 2605                  JRNE      L:??I2C_Init_2
   \   00007E BE00                  LDW       X, S:?w5
   \   000080 A31A81                CPW       X, #0x1a81
   \                     ??I2C_Init_2:
   \   000083 2507                  JRC       L:??CrossCallReturnLabel_0
   \                     ??I2C_Init_1:
   \   000085 AE0068                LDW       X, #0x68
   \   000088 8D000000              CALLF     ?Subroutine0
    105          
    106          
    107            /*------------------------- I2C FREQ Configuration ------------------------*/
    108            /* Clear frequency bits */
    109            I2C->FREQR &= (uint8_t)(~I2C_FREQR_FREQ);
   \                     ??CrossCallReturnLabel_0:
   \   00008C C65212                LD        A, L:0x5212
   \   00008F A4C0                  AND       A, #0xc0
   \   000091 C75212                LD        L:0x5212, A
    110            /* Write new value */
    111            I2C->FREQR |= InputClockFrequencyMHz;
   \   000094 7B02                  LD        A, (0x2,SP)
   \   000096 CA5212                OR        A, L:0x5212
   \   000099 C75212                LD        L:0x5212, A
    112          
    113            /*--------------------------- I2C CCR Configuration ------------------------*/
    114            /* Disable I2C to configure TRISER */
    115            I2C->CR1 &= (uint8_t)(~I2C_CR1_PE);
   \   00009C 72115210              BRES      L:0x5210, #0x0
    116          
    117            /* Clear CCRH & CCRL */
    118            I2C->CCRH &= (uint8_t)(~(I2C_CCRH_FS | I2C_CCRH_DUTY | I2C_CCRH_CCR));
   \   0000A0 C6521C                LD        A, L:0x521c
   \   0000A3 A430                  AND       A, #0x30
   \   0000A5 C7521C                LD        L:0x521c, A
    119            I2C->CCRL &= (uint8_t)(~I2C_CCRL_CCR);
   \   0000A8 C6521B                LD        A, L:0x521b
   \   0000AB 725F521B              CLR       L:0x521b
    120          
    121            /* Detect Fast or Standard mode depending on the Output clock frequency selected */
    122            if (OutputClockFrequencyHz > I2C_MAX_STANDARD_FREQ) /* FAST MODE */
   \   0000AF 7B02                  LD        A, (0x2,SP)
   \   0000B1 5F                    CLRW      X
   \   0000B2 97                    LD        XL, A
   \   0000B3 BF00                  LDW       S:?w1, X
   \   0000B5 5F                    CLRW      X
   \   0000B6 BF00                  LDW       S:?w0, X
   \   0000B8 AE4240                LDW       X, #0x4240
   \   0000BB BF00                  LDW       S:?w3, X
   \   0000BD AE000F                LDW       X, #0xf
   \   0000C0 BF00                  LDW       S:?w2, X
   \   0000C2 8D000000              CALLF     L:?mul32_l0_l0_l1
   \   0000C6 8D000000              CALLF     L:?mov_l3_l0
   \   0000CA BE00                  LDW       X, S:?w4
   \   0000CC A30001                CPW       X, #0x1
   \   0000CF 2605                  JRNE      L:??I2C_Init_3
   \   0000D1 BE00                  LDW       X, S:?w5
   \   0000D3 A386A1                CPW       X, #0x86a1
   \                     ??I2C_Init_3:
   \   0000D6 253F                  JRC       L:??I2C_Init_4
    123            {
    124              /* Set F/S bit for fast mode */
    125              tmpccrh = I2C_CCRH_FS;
   \   0000D8 A680                  LD        A, #0x80
   \   0000DA 6B01                  LD        (0x1,SP), A
    126          
    127              if (I2C_DutyCycle == I2C_DUTYCYCLE_2)
   \   0000DC 0D05                  TNZ       (0x5,SP)
   \   0000DE 2609                  JRNE      L:??I2C_Init_5
    128              {
    129                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    130                result = (uint16_t) ((InputClockFrequencyMHz * 1000000) / (OutputClockFrequencyHz * 3));
   \   0000E0 AE0003                LDW       X, #0x3
   \   0000E3 8D000000              CALLF     ?Subroutine1
    131              }
   \                     ??CrossCallReturnLabel_23:
   \   0000E7 200B                  JRA       L:??I2C_Init_6
    132              else /* I2C_DUTYCYCLE_16_9 */
    133              {
    134                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    135                result = (uint16_t) ((InputClockFrequencyMHz * 1000000) / (OutputClockFrequencyHz * 25));
   \                     ??I2C_Init_5:
   \   0000E9 AE0019                LDW       X, #0x19
   \   0000EC 8D000000              CALLF     ?Subroutine1
    136                /* Set DUTY bit */
    137                tmpccrh |= I2C_CCRH_DUTY;
   \                     ??CrossCallReturnLabel_24:
   \   0000F0 A6C0                  LD        A, #0xc0
   \   0000F2 6B01                  LD        (0x1,SP), A
    138              }
    139          
    140              /* Verify and correct CCR value if below minimum value */
    141              if (result < (uint16_t)0x01)
   \                     ??I2C_Init_6:
   \   0000F4 BE00                  LDW       X, S:?w1
   \   0000F6 2604                  JRNE      L:??I2C_Init_7
    142              {
    143                /* Set the minimum allowed value */
    144                result = (uint16_t)0x0001;
   \   0000F8 5F                    CLRW      X
   \   0000F9 5C                    INCW      X
   \   0000FA BF00                  LDW       S:?w1, X
    145              }
    146          
    147              /* Set Maximum Rise Time: 300ns max in Fast Mode
    148              = [300ns/(1/InputClockFrequencyMHz.10e6)]+1
    149              = [(InputClockFrequencyMHz * 3)/10]+1 */
    150              tmpval = ((InputClockFrequencyMHz * 3) / 10) + 1;
    151              I2C->TRISER = (uint8_t)tmpval;
   \                     ??I2C_Init_7:
   \   0000FC 7B02                  LD        A, (0x2,SP)
   \   0000FE 5F                    CLRW      X
   \   0000FF 97                    LD        XL, A
   \   000100 9093                  LDW       Y, X
   \   000102 AE0003                LDW       X, #0x3
   \   000105 BF00                  LDW       S:?w0, X
   \   000107 93                    LDW       X, Y
   \   000108 8D000000              CALLF     L:?mul16_x_x_w0
   \   00010C 90AE000A              LDW       Y, #0xa
   \   000110 8D000000              CALLF     L:?sdiv16_x_x_y
   \   000114 9F                    LD        A, XL
   \   000115 201C                  JRA       ??I2C_Init_8
    152          
    153            }
    154            else /* STANDARD MODE */
    155            {
    156          
    157              /* Calculate standard mode speed */
    158              result = (uint16_t)((InputClockFrequencyMHz * 1000000) / (OutputClockFrequencyHz << (uint8_t)1));
   \                     ??I2C_Init_4:
   \   000117 8D000000              CALLF     L:?mov_l0_l2
   \   00011B A601                  LD        A, #0x1
   \   00011D 8D000000              CALLF     L:?sll32_l0_l0_a
   \   000121 8D000000              CALLF     ?Subroutine2
    159          
    160              /* Verify and correct CCR value if below minimum value */
    161              if (result < (uint16_t)0x0004)
   \                     ??CrossCallReturnLabel_25:
   \   000125 BE00                  LDW       X, S:?w1
   \   000127 A30004                CPW       X, #0x4
   \   00012A 2405                  JRNC      L:??I2C_Init_9
    162              {
    163                /* Set the minimum allowed value */
    164                result = (uint16_t)0x0004;
   \   00012C AE0004                LDW       X, #0x4
   \   00012F BF00                  LDW       S:?w1, X
    165              }
    166          
    167              /* Set Maximum Rise Time: 1000ns max in Standard Mode
    168              = [1000ns/(1/InputClockFrequencyMHz.10e6)]+1
    169              = InputClockFrequencyMHz+1 */
    170              I2C->TRISER = (uint8_t)(InputClockFrequencyMHz + (uint8_t)1);
   \                     ??I2C_Init_9:
   \   000131 7B02                  LD        A, (0x2,SP)
   \                     ??I2C_Init_8:
   \   000133 4C                    INC       A
   \   000134 C7521D                LD        L:0x521d, A
    171          
    172            }
    173          
    174            /* Write CCR with new calculated value */
    175            I2C->CCRL = (uint8_t)result;
   \   000137 B600                  LD        A, S:?b3
   \   000139 C7521B                LD        L:0x521b, A
    176            I2C->CCRH = (uint8_t)((uint8_t)((uint8_t)(result >> 8) & I2C_CCRH_CCR) | tmpccrh);
   \   00013C BE00                  LDW       X, S:?w1
   \   00013E 4F                    CLR       A
   \   00013F 01                    RRWA      X, A
   \   000140 9F                    LD        A, XL
   \   000141 A40F                  AND       A, #0xf
   \   000143 1A01                  OR        A, (0x1,SP)
   \   000145 C7521C                LD        L:0x521c, A
    177          
    178            /* Enable I2C */
    179            I2C->CR1 |= I2C_CR1_PE;
   \   000148 72105210              BSET      L:0x5210, #0x0
    180          
    181            /* Configure I2C acknowledgement */
    182            I2C_AcknowledgeConfig(Ack);
   \   00014C 7B04                  LD        A, (0x4,SP)
   \   00014E 8D000000              CALLF     I2C_AcknowledgeConfig
    183          
    184            /*--------------------------- I2C OAR Configuration ------------------------*/
    185            I2C->OARL = (uint8_t)(OwnAddress);
   \   000152 7B07                  LD        A, (0x7,SP)
   \   000154 C75213                LD        L:0x5213, A
    186            I2C->OARH = (uint8_t)((uint8_t)(AddMode | I2C_OARH_ADDCONF) |
    187                             (uint8_t)((OwnAddress & (uint16_t)0x0300) >> (uint8_t)7));
   \   000157 1E06                  LDW       X, (0x6,SP)
   \   000159 58                    SLLW      X
   \   00015A 4F                    CLR       A
   \   00015B 49                    RLC       A
   \   00015C 01                    RRWA      X, A
   \   00015D 9F                    LD        A, XL
   \   00015E A406                  AND       A, #0x6
   \   000160 1A03                  OR        A, (0x3,SP)
   \   000162 AA40                  OR        A, #0x40
   \   000164 C75214                LD        L:0x5214, A
    188          }
   \   000167 5B07                  ADD       SP, #0x7
   \   000169 AC000000              JPF       L:?epilogue_l2_l3

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine1:
   \   000000 BF00                  LDW       S:?w3, X
   \   000002 5F                    CLRW      X
   \   000003 BF00                  LDW       S:?w2, X
   \   000005 8D000000              CALLF     L:?mov_l0_l2
   \   000009 8D000000              CALLF     L:?mul32_l0_l0_l1
   \   00000D 8D000000              CALLF     ?Subroutine2
   \                     ??CrossCallReturnLabel_26:
   \   000011 87                    RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine2:
   \   000000 8D000000              CALLF     L:?mov_l1_l0
   \   000004 8D000000              CALLF     L:?mov_l0_l3
   \   000008 AC000000              JPF       L:?udiv32_l0_l0_l1
    189          
    190          /**
    191            * @brief  Enables or disables the I2C peripheral.
    192            * @param  NewState : Indicate the new I2C peripheral state.
    193            *         This parameter can be any of the @ref FunctionalState enumeration.
    194            * @retval None
    195            */

   \                                 In section .far_func.text, align 1
    196          void I2C_Cmd(FunctionalState NewState)
    197          {
    198          
    199            /* Check function parameters */
    200            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     I2C_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??I2C_Cmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_6
   \   000007 AE00C8                LDW       X, #0xc8
   \   00000A 8D000000              CALLF     ?Subroutine0
    201          
    202            if (NewState != DISABLE)
    203            {
    204              /* Enable I2C peripheral */
    205              I2C->CR1 |= I2C_CR1_PE;
   \                     ??CrossCallReturnLabel_6:
   \   00000E 72105210              BSET      L:0x5210, #0x0
   \   000012 87                    RETF
    206            }
    207            else /* NewState == DISABLE */
    208            {
    209              /* Disable I2C peripheral */
    210              I2C->CR1 &= (uint8_t)(~I2C_CR1_PE);
   \                     ??I2C_Cmd_0:
   \   000013 72115210              BRES      L:0x5210, #0x0
    211            }
    212          }
   \   000017 87                    RETF
    213          
    214          /**
    215            * @brief  Enables or disables the I2C General Call feature.
    216            * @param  NewState : State of the General Call feature.
    217            *         This parameter can be any of the @ref FunctionalState enumeration.
    218            * @retval None
    219            */

   \                                 In section .far_func.text, align 1
    220          void I2C_GeneralCallCmd(FunctionalState NewState)
    221          {
    222          
    223            /* Check function parameters */
    224            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     I2C_GeneralCallCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??I2C_GeneralCallCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_7
   \   000007 AE00E0                LDW       X, #0xe0
   \   00000A 8D000000              CALLF     ?Subroutine0
    225          
    226            if (NewState != DISABLE)
    227            {
    228              /* Enable General Call */
    229              I2C->CR1 |= I2C_CR1_ENGC;
   \                     ??CrossCallReturnLabel_7:
   \   00000E 721C5210              BSET      L:0x5210, #0x6
   \   000012 87                    RETF
    230            }
    231            else /* NewState == DISABLE */
    232            {
    233              /* Disable General Call */
    234              I2C->CR1 &= (uint8_t)(~I2C_CR1_ENGC);
   \                     ??I2C_GeneralCallCmd_0:
   \   000013 721D5210              BRES      L:0x5210, #0x6
    235            }
    236          }
   \   000017 87                    RETF
    237          
    238          /**
    239            * @brief  Generates I2C communication START condition.
    240            * @note   CCR must be programmed, i.e. I2C_Init function must have been called
    241            *         with a valid I2C_ClockSpeed
    242            * @param  NewState : Enable or disable the start condition.
    243            *         This parameter can be any of the @ref FunctionalState enumeration.
    244            * @retval None
    245            */

   \                                 In section .far_func.text, align 1
    246          void I2C_GenerateSTART(FunctionalState NewState)
    247          {
    248          
    249            /* Check function parameters */
    250            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     I2C_GenerateSTART:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??I2C_GenerateSTART_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_8
   \   000007 AE00FA                LDW       X, #0xfa
   \   00000A 8D000000              CALLF     ?Subroutine0
    251          
    252            if (NewState != DISABLE)
    253            {
    254              /* Generate a START condition */
    255              I2C->CR2 |= I2C_CR2_START;
   \                     ??CrossCallReturnLabel_8:
   \   00000E 72105211              BSET      L:0x5211, #0x0
   \   000012 87                    RETF
    256            }
    257            else /* NewState == DISABLE */
    258            {
    259              /* Disable the START condition generation */
    260              I2C->CR2 &= (uint8_t)(~I2C_CR2_START);
   \                     ??I2C_GenerateSTART_0:
   \   000013 72115211              BRES      L:0x5211, #0x0
    261            }
    262          }
   \   000017 87                    RETF
    263          
    264          /**
    265            * @brief  Generates I2C communication STOP condition.
    266            * @param   NewState : Enable or disable the stop condition.
    267            *          This parameter can be any of the @ref FunctionalState enumeration.
    268            * @retval None
    269            */

   \                                 In section .far_func.text, align 1
    270          void I2C_GenerateSTOP(FunctionalState NewState)
    271          {
    272          
    273            /* Check function parameters */
    274            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     I2C_GenerateSTOP:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??I2C_GenerateSTOP_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_9
   \   000007 AE0112                LDW       X, #0x112
   \   00000A 8D000000              CALLF     ?Subroutine0
    275          
    276            if (NewState != DISABLE)
    277            {
    278              /* Generate a STOP condition */
    279              I2C->CR2 |= I2C_CR2_STOP;
   \                     ??CrossCallReturnLabel_9:
   \   00000E 72125211              BSET      L:0x5211, #0x1
   \   000012 87                    RETF
    280            }
    281            else /* NewState == DISABLE */
    282            {
    283              /* Disable the STOP condition generation */
    284              I2C->CR2 &= (uint8_t)(~I2C_CR2_STOP);
   \                     ??I2C_GenerateSTOP_0:
   \   000013 72135211              BRES      L:0x5211, #0x1
    285            }
    286          }
   \   000017 87                    RETF
    287          
    288          /**
    289            * @brief  Enables or disables I2C software reset.
    290            * @param  NewState : Specifies the new state of the I2C software reset.
    291            *         This parameter can be any of the @ref FunctionalState enumeration.
    292            * @retval None
    293            */

   \                                 In section .far_func.text, align 1
    294          void I2C_SoftwareResetCmd(FunctionalState NewState)
    295          {
    296            /* Check function parameters */
    297            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     I2C_SoftwareResetCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??I2C_SoftwareResetCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_10
   \   000007 AE0129                LDW       X, #0x129
   \   00000A 8D000000              CALLF     ?Subroutine0
    298          
    299            if (NewState != DISABLE)
    300            {
    301              /* Peripheral under reset */
    302              I2C->CR2 |= I2C_CR2_SWRST;
   \                     ??CrossCallReturnLabel_10:
   \   00000E 721E5211              BSET      L:0x5211, #0x7
   \   000012 87                    RETF
    303            }
    304            else /* NewState == DISABLE */
    305            {
    306              /* Peripheral not under reset */
    307              I2C->CR2 &= (uint8_t)(~I2C_CR2_SWRST);
   \                     ??I2C_SoftwareResetCmd_0:
   \   000013 721F5211              BRES      L:0x5211, #0x7
    308            }
    309          }
   \   000017 87                    RETF
    310          
    311          /**
    312            * @brief  Enables or disables the I2C clock stretching.
    313            * @param  NewState : Specifies the new state of the I2C Clock stretching.
    314            *         This parameter can be any of the @ref FunctionalState enumeration.
    315            * @retval None
    316            */
    317          

   \                                 In section .far_func.text, align 1
    318          void I2C_StretchClockCmd(FunctionalState NewState)
    319          {
    320            /* Check function parameters */
    321            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     I2C_StretchClockCmd:
   \   000000 4D                    TNZ       A
   \   000001 2710                  JREQ      L:??I2C_StretchClockCmd_0
   \   000003 A101                  CP        A, #0x1
   \   000005 2707                  JREQ      L:??CrossCallReturnLabel_11
   \   000007 AE0141                LDW       X, #0x141
   \   00000A 8D000000              CALLF     ?Subroutine0
    322          
    323            if (NewState != DISABLE)
    324            {
    325              /* Clock Stretching Enable */
    326              I2C->CR1 &= (uint8_t)(~I2C_CR1_NOSTRETCH);
   \                     ??CrossCallReturnLabel_11:
   \   00000E 721F5210              BRES      L:0x5210, #0x7
   \   000012 87                    RETF
    327          
    328            }
    329            else /* NewState == DISABLE */
    330            {
    331              /* Clock Stretching Disable (Slave mode) */
    332              I2C->CR1 |= I2C_CR1_NOSTRETCH;
   \                     ??I2C_StretchClockCmd_0:
   \   000013 721E5210              BSET      L:0x5210, #0x7
    333            }
    334          }
   \   000017 87                    RETF
    335          
    336          /**
    337            * @brief  Enable or Disable the I2C acknowledge and position acknowledge feature.
    338            * @note   This function must be called before data reception start
    339            * @param  Ack : Specifies the acknowledge mode to apply.
    340            *         This parameter can be any of the  @ref I2C_Ack_TypeDef enumeration.
    341            * @retval None
    342            */

   \                                 In section .far_func.text, align 1
    343          void I2C_AcknowledgeConfig(I2C_Ack_TypeDef Ack)
    344          {
   \                     I2C_AcknowledgeConfig:
   \   000000 3B0000                PUSH      S:?b8
   \   000003 B700                  LD        S:?b8, A
    345          
    346            /* Check function parameters */
    347            assert_param(IS_I2C_ACK_OK(Ack));
   \   000005 271F                  JREQ      L:??I2C_AcknowledgeConfig_0
   \   000007 A101                  CP        A, #0x1
   \   000009 270B                  JREQ      L:??CrossCallReturnLabel_12
   \   00000B A102                  CP        A, #0x2
   \   00000D 2707                  JREQ      L:??CrossCallReturnLabel_12
   \   00000F AE015B                LDW       X, #0x15b
   \   000012 8D000000              CALLF     ?Subroutine0
    348          
    349            if (Ack == I2C_ACK_NONE)
    350            {
    351              /* Disable the acknowledgement */
    352              I2C->CR2 &= (uint8_t)(~I2C_CR2_ACK);
    353            }
    354            else
    355            {
    356              /* Enable the acknowledgement */
    357              I2C->CR2 |= I2C_CR2_ACK;
   \                     ??CrossCallReturnLabel_12:
   \   000016 72145211              BSET      L:0x5211, #0x2
    358          
    359              if (Ack == I2C_ACK_CURR)
   \   00001A B600                  LD        A, S:?b8
   \   00001C A101                  CP        A, #0x1
   \   00001E 260C                  JRNE      L:??I2C_AcknowledgeConfig_1
    360              {
    361                /* Configure (N)ACK on current byte */
    362                I2C->CR2 &= (uint8_t)(~I2C_CR2_POS);
   \   000020 72175211              BRES      L:0x5211, #0x3
   \   000024 200A                  JRA       L:??I2C_AcknowledgeConfig_2
    363              }
   \                     ??I2C_AcknowledgeConfig_0:
   \   000026 72155211              BRES      L:0x5211, #0x2
   \   00002A 2004                  JRA       L:??I2C_AcknowledgeConfig_2
    364              else
    365              {
    366                /* Configure (N)ACK on next byte */
    367                I2C->CR2 |= I2C_CR2_POS;
   \                     ??I2C_AcknowledgeConfig_1:
   \   00002C 72165211              BSET      L:0x5211, #0x3
    368              }
    369            }
    370          }
   \                     ??I2C_AcknowledgeConfig_2:
   \   000030 320000                POP       S:?b8
   \   000033 87                    RETF
    371          
    372          /**
    373            * @brief  Enables or disables the specified I2C interrupt.
    374            * @param  ITName : Name of the interrupt to enable or disable.
    375            *         This parameter can be any of the  @ref I2C_IT_TypeDef enumeration.
    376            * @param  NewState : State of the interrupt to apply.
    377            *         This parameter can be any of the @ref FunctionalState enumeration.
    378            * @retval None
    379            */

   \                                 In section .far_func.text, align 1
    380          void I2C_ITConfig(I2C_IT_TypeDef I2C_IT, FunctionalState NewState)
    381          {
   \                     I2C_ITConfig:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    382          
    383            /* Check functions parameters */
    384            assert_param(IS_I2C_INTERRUPT_OK(I2C_IT));
   \   000009 A101                  CP        A, #0x1
   \   00000B 271F                  JREQ      L:??CrossCallReturnLabel_14
   \   00000D A102                  CP        A, #0x2
   \   00000F 271B                  JREQ      L:??CrossCallReturnLabel_14
   \   000011 A104                  CP        A, #0x4
   \   000013 2717                  JREQ      L:??CrossCallReturnLabel_14
   \   000015 A103                  CP        A, #0x3
   \   000017 2713                  JREQ      L:??CrossCallReturnLabel_14
   \   000019 A105                  CP        A, #0x5
   \   00001B 270F                  JREQ      L:??CrossCallReturnLabel_14
   \   00001D A106                  CP        A, #0x6
   \   00001F 270B                  JREQ      L:??CrossCallReturnLabel_14
   \   000021 A107                  CP        A, #0x7
   \   000023 2707                  JREQ      L:??CrossCallReturnLabel_14
   \   000025 AE0180                LDW       X, #0x180
   \   000028 8D000000              CALLF     ?Subroutine0
    385            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_14:
   \   00002C 3D00                  TNZ       S:?b9
   \   00002E 2714                  JREQ      L:??I2C_ITConfig_0
   \   000030 B600                  LD        A, S:?b9
   \   000032 A101                  CP        A, #0x1
   \   000034 2707                  JREQ      L:??CrossCallReturnLabel_13
   \   000036 AE0181                LDW       X, #0x181
   \   000039 8D000000              CALLF     ?Subroutine0
    386          
    387            if (NewState != DISABLE)
    388            {
    389              /* Enable the selected I2C interrupts */
    390              I2C->ITR |= (uint8_t)I2C_IT;
   \                     ??CrossCallReturnLabel_13:
   \   00003D B600                  LD        A, S:?b8
   \   00003F CA521A                OR        A, L:0x521a
   \   000042 2007                  JRA       ??I2C_ITConfig_1
    391            }
    392            else /* NewState == DISABLE */
    393            {
    394              /* Disable the selected I2C interrupts */
    395              I2C->ITR &= (uint8_t)(~(uint8_t)I2C_IT);
   \                     ??I2C_ITConfig_0:
   \   000044 3300                  CPL       S:?b8
   \   000046 B600                  LD        A, S:?b8
   \   000048 C4521A                AND       A, L:0x521a
   \                     ??I2C_ITConfig_1:
   \   00004B C7521A                LD        L:0x521a, A
    396            }
    397          }
   \   00004E AC000000              JPF       L:?epilogue_w4
    398          
    399          /**
    400            * @brief  Selects the specified I2C fast mode duty cycle.
    401            * @param  I2C_DutyCycle : Specifies the duty cycle to apply.
    402            *         This parameter can be any of the @ref I2C_DutyCycle_TypeDef enumeration.
    403            * @retval None
    404            */

   \                                 In section .far_func.text, align 1
    405          void I2C_FastModeDutyCycleConfig(I2C_DutyCycle_TypeDef I2C_DutyCycle)
    406          {
    407          
    408            /* Check function parameters */
    409            assert_param(IS_I2C_DUTYCYCLE_OK(I2C_DutyCycle));
   \                     I2C_FastModeDutyCycleConfig:
   \   000000 4D                    TNZ       A
   \   000001 270B                  JREQ      L:??CrossCallReturnLabel_15
   \   000003 A140                  CP        A, #0x40
   \   000005 270C                  JREQ      L:??I2C_FastModeDutyCycleConfig_0
   \   000007 AE0199                LDW       X, #0x199
   \   00000A 8D000000              CALLF     ?Subroutine0
    410          
    411            if (I2C_DutyCycle == I2C_DUTYCYCLE_16_9)
    412            {
    413              /* I2C fast mode Tlow/Thigh = 16/9 */
    414              I2C->CCRH |= I2C_CCRH_DUTY;
    415            }
    416            else /* I2C_DUTYCYCLE_2 */
    417            {
    418              /* I2C fast mode Tlow/Thigh = 2 */
    419              I2C->CCRH &= (uint8_t)(~I2C_CCRH_DUTY);
   \                     ??CrossCallReturnLabel_15:
   \   00000E 721D521C              BRES      L:0x521c, #0x6
    420            }
    421          }
   \   000012 87                    RETF
   \                     ??I2C_FastModeDutyCycleConfig_0:
   \   000013 721C521C              BSET      L:0x521c, #0x6
   \   000017 87                    RETF
    422          
    423          /**
    424            * @brief  Returns the most recent received data.
    425            * @param  None
    426            * @retval uint8_t : The value of the received byte data.
    427            */

   \                                 In section .far_func.text, align 1
    428          uint8_t I2C_ReceiveData(void)
    429          {
    430            /* Return the data present in the DR register */
    431            return ((uint8_t)I2C->DR);
   \                     I2C_ReceiveData:
   \   000000 C65216                LD        A, L:0x5216
   \   000003 87                    RETF
    432          }
    433          
    434          /**
    435            * @brief  Transmits the 7-bit address (to select the) slave device.
    436            * @param   Address : Specifies the slave address which will be transmitted.
    437            * @param   Direction : Specifies whether the I2C device will be a Transmitter or a Receiver.
    438            * This parameter can be any of the @ref I2C_Direction_TypeDef enumeration.
    439            * @retval None
    440            */

   \                                 In section .far_func.text, align 1
    441          void I2C_Send7bitAddress(uint8_t Address, I2C_Direction_TypeDef Direction)
    442          {
   \                     I2C_Send7bitAddress:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 B700                  LD        S:?b8, A
   \   000006 450000                MOV       S:?b9, S:?b0
    443            /* Check function parameters */
    444            assert_param(IS_I2C_ADDRESS_OK(Address));
   \   000009 A501                  BCP       A, #0x1
   \   00000B 2707                  JREQ      L:??CrossCallReturnLabel_17
   \   00000D AE01BC                LDW       X, #0x1bc
   \   000010 8D000000              CALLF     ?Subroutine0
    445            assert_param(IS_I2C_DIRECTION_OK(Direction));
   \                     ??CrossCallReturnLabel_17:
   \   000014 3D00                  TNZ       S:?b9
   \   000016 270D                  JREQ      L:??CrossCallReturnLabel_16
   \   000018 B600                  LD        A, S:?b9
   \   00001A A101                  CP        A, #0x1
   \   00001C 2707                  JREQ      L:??CrossCallReturnLabel_16
   \   00001E AE01BD                LDW       X, #0x1bd
   \   000021 8D000000              CALLF     ?Subroutine0
    446          
    447            /* Clear bit0 (direction) just in case */
    448            Address &= (uint8_t)0xFE;
    449          
    450            /* Send the Address + Direction */
    451            I2C->DR = (uint8_t)(Address | (uint8_t)Direction);
   \                     ??CrossCallReturnLabel_16:
   \   000025 B600                  LD        A, S:?b8
   \   000027 A4FE                  AND       A, #0xfe
   \   000029 BA00                  OR        A, S:?b9
   \   00002B C75216                LD        L:0x5216, A
    452          }
   \   00002E AC000000              JPF       L:?epilogue_w4
    453          
    454          /**
    455            * @brief  Send a byte by writing in the DR register.
    456            * @param   Data : Byte to be sent.
    457            * @retval None
    458            */

   \                                 In section .far_func.text, align 1
    459          void I2C_SendData(uint8_t Data)
    460          {
    461            /* Write in the DR register the data to be sent */
    462            I2C->DR = Data;
   \                     I2C_SendData:
   \   000000 C75216                LD        L:0x5216, A
    463          }
   \   000003 87                    RETF
    464          
    465          /**
    466           * @brief
    467           ****************************************************************************************
    468           *
    469           *                         I2C State Monitoring Functions
    470           *
    471           ****************************************************************************************
    472           * This I2C driver provides three different ways for I2C state monitoring
    473           *  depending on the application requirements and constraints:
    474           *
    475           *
    476           * 1) Basic state monitoring:
    477           *    Using I2C_CheckEvent() function:
    478           *    It compares the status registers (SR1, SR2 and SR3) content to a given event
    479           *    (can be the combination of one or more flags).
    480           *    It returns SUCCESS if the current status includes the given flags
    481           *    and returns ERROR if one or more flags are missing in the current status.
    482           *    - When to use:
    483           *      - This function is suitable for most applications as well as for startup
    484           *      activity since the events are fully described in the product reference manual
    485           *      (RM0016).
    486           *      - It is also suitable for users who need to define their own events.
    487           *    - Limitations:
    488           *      - If an error occurs (ie. error flags are set besides to the monitored flags),
    489           *        the I2C_CheckEvent() function may return SUCCESS despite the communication
    490           *        hold or corrupted real state.
    491           *        In this case, it is advised to use error interrupts to monitor the error
    492           *        events and handle them in the interrupt IRQ handler.
    493           *
    494           *        @note
    495           *        For error management, it is advised to use the following functions:
    496           *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    497           *          - I2C_IRQHandler() which is called when the I2C interurpts occur.
    498           *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into the
    499           *           I2C_IRQHandler() function in order to determine which error occured.
    500           *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
    501           *            and/or I2C_GenerateStop() in order to clear the error flag and
    502           *            source and return to correct communication status.
    503           *
    504           *
    505           *  2) Advanced state monitoring:
    506           *     Using the function I2C_GetLastEvent() which returns the image of both SR1
    507           *     & SR3 status registers in a single word (uint16_t) (Status Register 3 value
    508           *     is shifted left by 8 bits and concatenated to Status Register 1).
    509           *     - When to use:
    510           *       - This function is suitable for the same applications above but it allows to
    511           *         overcome the limitations of I2C_GetFlagStatus() function (see below).
    512           *         The returned value could be compared to events already defined in the
    513           *         library (stm8s_i2c.h) or to custom values defined by user.
    514           *       - This function is suitable when multiple flags are monitored at the same time.
    515           *       - At the opposite of I2C_CheckEvent() function, this function allows user to
    516           *         choose when an event is accepted (when all events flags are set and no
    517           *         other flags are set or just when the needed flags are set like
    518           *         I2C_CheckEvent() function).
    519           *     - Limitations:
    520           *       - User may need to define his own events.
    521           *       - Same remark concerning the error management is applicable for this
    522           *         function if user decides to check only regular communication flags (and
    523           *         ignores error flags).
    524           *
    525           *
    526           *  3) Flag-based state monitoring:
    527           *     Using the function I2C_GetFlagStatus() which simply returns the status of
    528           *     one single flag (ie. I2C_FLAG_RXNE ...).
    529           *     - When to use:
    530           *        - This function could be used for specific applications or in debug phase.
    531           *        - It is suitable when only one flag checking is needed (most I2C events
    532           *          are monitored through multiple flags).
    533           *     - Limitations:
    534           *        - When calling this function, the Status register is accessed. Some flags are
    535           *          cleared when the status register is accessed. So checking the status
    536           *          of one Flag, may clear other ones.
    537           *        - Function may need to be called twice or more in order to monitor one
    538           *          single event.
    539           *
    540           *  For detailed description of Events, please refer to section I2C_Events in
    541           *  stm8s_i2c.h file.
    542           *
    543           */
    544          /**
    545           *
    546           *  1) Basic state monitoring
    547           *******************************************************************************
    548           */
    549          
    550          /**
    551            * @brief  Checks whether the last I2C Event is equal to the one passed
    552            *   as parameter.
    553            * @param  I2C_EVENT: specifies the event to be checked.
    554            *   This parameter can be one of the following values:
    555            *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1
    556            *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1
    557            *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1
    558            *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2
    559            *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2
    560            *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3
    561            *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3
    562            *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2
    563            *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4
    564            *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5
    565            *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6
    566            *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6
    567            *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7
    568            *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8
    569            *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2
    570            *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9
    571            *
    572            * @note: For detailed description of Events, please refer to section
    573            *    I2C_Events in stm8s_i2c.h file.
    574            *
    575            * @retval An ErrorStatus enumeration value:
    576            * - SUCCESS: Last event is equal to the I2C_EVENT
    577            * - ERROR: Last event is different from the I2C_EVENT
    578            */

   \                                 In section .far_func.text, align 1
    579          ErrorStatus I2C_CheckEvent(I2C_Event_TypeDef I2C_Event)
    580          {
   \                     I2C_CheckEvent:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 5202                  SUB       SP, #0x2
   \   000006 BF00                  LDW       S:?w4, X
    581            __IO uint16_t lastevent = 0x00;
   \   000008 5F                    CLRW      X
   \   000009 1F01                  LDW       (0x1,SP), X
    582            uint8_t flag1 = 0x00 ;
    583            uint8_t flag2 = 0x00;
    584            ErrorStatus status = ERROR;
    585          
    586            /* Check the parameters */
    587            assert_param(IS_I2C_EVENT_OK(I2C_Event));
   \   00000B BE00                  LDW       X, S:?w4
   \   00000D A30682                CPW       X, #0x682
   \   000010 2752                  JREQ      L:??CrossCallReturnLabel_18
   \   000012 A30202                CPW       X, #0x202
   \   000015 274D                  JREQ      L:??CrossCallReturnLabel_18
   \   000017 A31200                CPW       X, #0x1200
   \   00001A 2748                  JREQ      L:??CrossCallReturnLabel_18
   \   00001C A30240                CPW       X, #0x240
   \   00001F 2743                  JREQ      L:??CrossCallReturnLabel_18
   \   000021 A30350                CPW       X, #0x350
   \   000024 276A                  JREQ      L:??I2C_CheckEvent_0
   \   000026 A30684                CPW       X, #0x684
   \   000029 2739                  JREQ      L:??CrossCallReturnLabel_18
   \   00002B A30794                CPW       X, #0x794
   \   00002E 2760                  JREQ      L:??I2C_CheckEvent_0
   \   000030 A30004                CPW       X, #0x4
   \   000033 2760                  JREQ      L:??I2C_CheckEvent_1
   \   000035 A30010                CPW       X, #0x10
   \   000038 272A                  JREQ      L:??CrossCallReturnLabel_18
   \   00003A A30301                CPW       X, #0x301
   \   00003D 2725                  JREQ      L:??CrossCallReturnLabel_18
   \   00003F A30782                CPW       X, #0x782
   \   000042 2720                  JREQ      L:??CrossCallReturnLabel_18
   \   000044 A30302                CPW       X, #0x302
   \   000047 271B                  JREQ      L:??CrossCallReturnLabel_18
   \   000049 A30340                CPW       X, #0x340
   \   00004C 2716                  JREQ      L:??CrossCallReturnLabel_18
   \   00004E A30784                CPW       X, #0x784
   \   000051 2711                  JREQ      L:??CrossCallReturnLabel_18
   \   000053 A30780                CPW       X, #0x780
   \   000056 270C                  JREQ      L:??CrossCallReturnLabel_18
   \   000058 A30308                CPW       X, #0x308
   \   00005B 2707                  JREQ      L:??CrossCallReturnLabel_18
   \   00005D AE024B                LDW       X, #0x24b
   \   000060 8D000000              CALLF     ?Subroutine0
    588          
    589            if (I2C_Event == I2C_EVENT_SLAVE_ACK_FAILURE)
    590            {
    591              lastevent = I2C->SR2 & I2C_SR2_AF;
    592            }
    593            else
    594            {
    595              flag1 = I2C->SR1;
   \                     ??CrossCallReturnLabel_18:
   \   000064 C65217                LD        A, L:0x5217
   \   000067 B700                  LD        S:?b0, A
    596              flag2 = I2C->SR3;
   \   000069 C65219                LD        A, L:0x5219
    597              lastevent = ((uint16_t)((uint16_t)flag2 << (uint16_t)8) | (uint16_t)flag1);
   \   00006C 5F                    CLRW      X
   \   00006D 97                    LD        XL, A
   \   00006E 4F                    CLR       A
   \   00006F 02                    RLWA      X, A
   \   000070 9093                  LDW       Y, X
   \   000072 5F                    CLRW      X
   \   000073 B600                  LD        A, S:?b0
   \   000075 41                    EXG       A, XL
   \   000076 BF00                  LDW       S:?w0, X
   \   000078 93                    LDW       X, Y
   \   000079 01                    RRWA      X, A
   \   00007A BA00                  OR        A, S:?b1
   \                     ??I2C_CheckEvent_2:
   \   00007C 02                    RLWA      X, A
   \   00007D 1F01                  LDW       (0x1,SP), X
    598            }
    599            /* Check whether the last event is equal to I2C_EVENT */
    600            if (((uint16_t)lastevent & (uint16_t)I2C_Event) == (uint16_t)I2C_Event)
   \   00007F 1E01                  LDW       X, (0x1,SP)
   \   000081 01                    RRWA      X, A
   \   000082 B400                  AND       A, S:?b9
   \   000084 01                    RRWA      X, A
   \   000085 B400                  AND       A, S:?b8
   \   000087 01                    RRWA      X, A
   \   000088 B300                  CPW       X, S:?w4
   \   00008A 2613                  JRNE      L:??I2C_CheckEvent_3
    601            {
    602              /* SUCCESS: last event is equal to I2C_EVENT */
    603              status = SUCCESS;
   \   00008C A601                  LD        A, #0x1
   \   00008E 2010                  JRA       L:??I2C_CheckEvent_4
    604            }
   \                     ??I2C_CheckEvent_0:
   \   000090 A30004                CPW       X, #0x4
   \   000093 26CF                  JRNE      L:??CrossCallReturnLabel_18
   \                     ??I2C_CheckEvent_1:
   \   000095 C65218                LD        A, L:0x5218
   \   000098 5F                    CLRW      X
   \   000099 97                    LD        XL, A
   \   00009A 01                    RRWA      X, A
   \   00009B A404                  AND       A, #0x4
   \   00009D 20DD                  JRA       ??I2C_CheckEvent_2
    605            else
    606            {
    607              /* ERROR: last event is different from I2C_EVENT */
    608              status = ERROR;
   \                     ??I2C_CheckEvent_3:
   \   00009F 4F                    CLR       A
    609            }
    610          
    611            /* Return status */
    612            return status;
   \                     ??I2C_CheckEvent_4:
   \   0000A0 5B02                  ADD       SP, #0x2
   \   0000A2 AC000000              JPF       L:?epilogue_w4
    613          }
    614          
    615          /**
    616           *
    617           *  2) Advanced state monitoring
    618           *******************************************************************************
    619           */
    620          /**
    621            * @brief  Returns the last I2C Event.
    622            *
    623            * @note: For detailed description of Events, please refer to section
    624            *    I2C_Events in stm8s_i2c.h file.
    625            *
    626            * @retval The last event
    627            *   This parameter can be any of the  @ref I2C_Event_TypeDef enumeration.
    628            */

   \                                 In section .far_func.text, align 1
    629          I2C_Event_TypeDef I2C_GetLastEvent(void)
    630          {
   \                     I2C_GetLastEvent:
   \   000000 5202                  SUB       SP, #0x2
    631            __IO uint16_t lastevent = 0;
   \   000002 5F                    CLRW      X
   \   000003 1F01                  LDW       (0x1,SP), X
    632            uint16_t flag1 = 0;
    633            uint16_t flag2 = 0;
    634          
    635            if ((I2C->SR2 & I2C_SR2_AF) != 0x00)
   \   000005 7205521805            BTJF      L:0x5218, #0x2, L:??I2C_GetLastEvent_0
    636            {
    637              lastevent = I2C_EVENT_SLAVE_ACK_FAILURE;
   \   00000A AE0004                LDW       X, #0x4
   \   00000D 2014                  JRA       ??I2C_GetLastEvent_1
    638            }
    639            else
    640            {
    641              /* Read the I2C status register */
    642              flag1 = I2C->SR1;
   \                     ??I2C_GetLastEvent_0:
   \   00000F C65217                LD        A, L:0x5217
   \   000012 B700                  LD        S:?b0, A
    643              flag2 = I2C->SR3;
   \   000014 C65219                LD        A, L:0x5219
    644          
    645              /* Get the last event value from I2C status register */
    646              lastevent = ((uint16_t)((uint16_t)flag2 << 8) | (uint16_t)flag1);
   \   000017 97                    LD        XL, A
   \   000018 905F                  CLRW      Y
   \   00001A B600                  LD        A, S:?b0
   \   00001C 61                    EXG       A, YL
   \   00001D 90BF00                LDW       S:?w0, Y
   \   000020 BA00                  OR        A, S:?b1
   \   000022 02                    RLWA      X, A
   \                     ??I2C_GetLastEvent_1:
   \   000023 1F01                  LDW       (0x1,SP), X
    647            }
    648            /* Return status */
    649            return (I2C_Event_TypeDef)lastevent;
   \   000025 1E01                  LDW       X, (0x1,SP)
   \   000027 5B02                  ADD       SP, #0x2
   \   000029 87                    RETF
    650          }
    651          
    652          /**
    653           *
    654           *  3) Flag-based state monitoring
    655           *******************************************************************************
    656           */
    657          /**
    658            * @brief  Checks whether the specified I2C flag is set or not.
    659            * @param  I2C_FLAG: specifies the flag to check.
    660            *   This parameter can be one of the following values:
    661            *     @arg I2C_FLAG_GENERALCALL: General call header flag (Slave mode)
    662            *     @arg I2C_FLAG_TRANSMITTERRECEIVER: Transmitter/Receiver flag
    663            *     @arg I2C_FLAG_BUSBUSY: Bus busy flag
    664            *     @arg I2C_FLAG_MASTERSLAVE: Master/Slave flag
    665            *     @arg I2C_FLAG_WAKEUPFROMHALT: Wake up from HALT flag  
    666            *     @arg I2C_FLAG_OVERRUNUNDERRUN: Overrun/Underrun flag (Slave mode)
    667            *     @arg I2C_FLAG_ACKNOWLEDGEFAILURE: Acknowledge failure flag
    668            *     @arg I2C_FLAG_ARBITRATIONLOSS: Arbitration lost flag (Master mode)
    669            *     @arg I2C_FLAG_BUSERROR: Bus error flag
    670            *     @arg I2C_FLAG_TXEMPTY: Data register empty flag (Transmitter)
    671            *     @arg I2C_FLAG_RXNOTEMPTY: Data register not empty (Receiver) flag
    672            *     @arg I2C_FLAG_STOPDETECTION: Stop detection flag (Slave mode)
    673            *     @arg I2C_FLAG_HEADERSENT: 10-bit header sent flag (Master mode)
    674            *     @arg I2C_FLAG_TRANSFERFINISHED: Byte transfer finished flag
    675            *     @arg I2C_FLAG_ADDRESSSENTMATCHED: Address sent flag (Master mode) ADSL
    676            *   Address matched flag (Slave mode)ENDAD
    677            *     @arg I2C_FLAG_STARTDETECTION: Start bit flag (Master mode)
    678            * @retval The new state of I2C_FLAG (SET or RESET).
    679            */

   \                                 In section .far_func.text, align 1
    680          FlagStatus I2C_GetFlagStatus(I2C_Flag_TypeDef I2C_Flag)
    681          {
   \                     I2C_GetFlagStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 3B0000                PUSH      S:?b10
   \   000007 BF00                  LDW       S:?w4, X
    682            uint8_t tempreg = 0;
   \   000009 3F00                  CLR       S:?b10
    683            uint8_t regindex = 0;
    684            FlagStatus bitstatus = RESET;
    685          
    686            /* Check the parameters */
    687            assert_param(IS_I2C_FLAG_OK(I2C_Flag));
   \   00000B A30180                CPW       X, #0x180
   \   00000E 2752                  JREQ      L:??CrossCallReturnLabel_19
   \   000010 A30140                CPW       X, #0x140
   \   000013 274D                  JREQ      L:??CrossCallReturnLabel_19
   \   000015 A30110                CPW       X, #0x110
   \   000018 2748                  JREQ      L:??CrossCallReturnLabel_19
   \   00001A A30108                CPW       X, #0x108
   \   00001D 2743                  JREQ      L:??CrossCallReturnLabel_19
   \   00001F A30104                CPW       X, #0x104
   \   000022 273E                  JREQ      L:??CrossCallReturnLabel_19
   \   000024 A30102                CPW       X, #0x102
   \   000027 2739                  JREQ      L:??CrossCallReturnLabel_19
   \   000029 A30101                CPW       X, #0x101
   \   00002C 2734                  JREQ      L:??CrossCallReturnLabel_19
   \   00002E A30220                CPW       X, #0x220
   \   000031 272F                  JREQ      L:??CrossCallReturnLabel_19
   \   000033 A30208                CPW       X, #0x208
   \   000036 272A                  JREQ      L:??CrossCallReturnLabel_19
   \   000038 A30204                CPW       X, #0x204
   \   00003B 2725                  JREQ      L:??CrossCallReturnLabel_19
   \   00003D A30202                CPW       X, #0x202
   \   000040 2720                  JREQ      L:??CrossCallReturnLabel_19
   \   000042 A30201                CPW       X, #0x201
   \   000045 271B                  JREQ      L:??CrossCallReturnLabel_19
   \   000047 A30310                CPW       X, #0x310
   \   00004A 2716                  JREQ      L:??CrossCallReturnLabel_19
   \   00004C A30304                CPW       X, #0x304
   \   00004F 2711                  JREQ      L:??CrossCallReturnLabel_19
   \   000051 A30302                CPW       X, #0x302
   \   000054 270C                  JREQ      L:??CrossCallReturnLabel_19
   \   000056 A30301                CPW       X, #0x301
   \   000059 2707                  JREQ      L:??CrossCallReturnLabel_19
   \   00005B AE02AF                LDW       X, #0x2af
   \   00005E 8D000000              CALLF     ?Subroutine0
    688          
    689            /* Read flag register index */
    690            regindex = (uint8_t)((uint16_t)I2C_Flag >> 8);
    691            /* Check SRx index */
    692            switch (regindex)
   \                     ??CrossCallReturnLabel_19:
   \   000062 BE00                  LDW       X, S:?w4
   \   000064 4F                    CLR       A
   \   000065 01                    RRWA      X, A
   \   000066 9F                    LD        A, XL
   \   000067 4A                    DEC       A
   \   000068 2708                  JREQ      L:??I2C_GetFlagStatus_0
   \   00006A 4A                    DEC       A
   \   00006B 270A                  JREQ      L:??I2C_GetFlagStatus_1
   \   00006D 4A                    DEC       A
   \   00006E 270C                  JREQ      L:??I2C_GetFlagStatus_2
   \   000070 200F                  JRA       L:??I2C_GetFlagStatus_3
    693            {
    694                /* Returns whether the status register to check is SR1 */
    695              case 0x01:
    696                tempreg = (uint8_t)I2C->SR1;
   \                     ??I2C_GetFlagStatus_0:
   \   000072 C65217                LD        A, L:0x5217
   \   000075 2008                  JRA       ??I2C_GetFlagStatus_4
    697                break;
    698          
    699                /* Returns whether the status register to check is SR2 */
    700              case 0x02:
    701                tempreg = (uint8_t)I2C->SR2;
   \                     ??I2C_GetFlagStatus_1:
   \   000077 C65218                LD        A, L:0x5218
   \   00007A 2003                  JRA       ??I2C_GetFlagStatus_4
    702                break;
    703          
    704                /* Returns whether the status register to check is SR3 */
    705              case 0x03:
    706                tempreg = (uint8_t)I2C->SR3;
   \                     ??I2C_GetFlagStatus_2:
   \   00007C C65219                LD        A, L:0x5219
   \                     ??I2C_GetFlagStatus_4:
   \   00007F B700                  LD        S:?b10, A
    707                break;
    708          
    709              default:
    710                break;
    711            }
    712          
    713            /* Check the status of the specified I2C flag */
    714            if ((tempreg & (uint8_t)I2C_Flag ) != 0)
   \                     ??I2C_GetFlagStatus_3:
   \   000081 B600                  LD        A, S:?b9
   \   000083 B500                  BCP       A, S:?b10
   \   000085 2704                  JREQ      L:??I2C_GetFlagStatus_5
    715            {
    716              /* Flag is set */
    717              bitstatus = SET;
   \   000087 A601                  LD        A, #0x1
   \   000089 2001                  JRA       L:??I2C_GetFlagStatus_6
    718            }
    719            else
    720            {
    721              /* Flag is reset */
    722              bitstatus = RESET;
   \                     ??I2C_GetFlagStatus_5:
   \   00008B 4F                    CLR       A
    723            }
    724            /* Return the flag status */
    725            return bitstatus;
   \                     ??I2C_GetFlagStatus_6:
   \   00008C 320000                POP       S:?b10
   \   00008F AC000000              JPF       L:?epilogue_w4
    726          }
    727          
    728          /**
    729            * @brief  Clear flags
    730            * @param  I2C_Flag : Specifies the flag to clear
    731            *   This parameter can be any combination of the following values:
    732            *                       - I2C_FLAG_WAKEUPFROMHALT: Wakeup from Halt
    733            *                       - I2C_FLAG_OVERRUNUNDERRUN: Overrun/Underrun flag (Slave mode)
    734            *                       - I2C_FLAG_ACKNOWLEDGEFAILURE: Acknowledge failure flag
    735            *                       - I2C_FLAG_ARBITRATIONLOSS: Arbitration lost flag (Master mode)
    736            *                       - I2C_FLAG_BUSERROR: Bus error flag.
    737            * @note Notes:
    738            *                       - STOPF (STOP detection) is cleared by software
    739            *                         sequence: a read operation to I2C_SR1 register
    740            *                         (I2C_GetFlagStatus()) followed by a write operation
    741            *                         to I2C_CR2 register.
    742            *                       - ADD10 (10-bit header sent) is cleared by software
    743            *                         sequence: a read operation to I2C_SR1
    744            *                         (I2C_GetFlagStatus()) followed by writing the
    745            *                         second byte of the address in DR register.
    746            *                       - BTF (Byte Transfer Finished) is cleared by software
    747            *                         sequence: a read operation to I2C_SR1 register
    748            *                         (I2C_GetFlagStatus()) followed by a read/write to
    749            *                         I2C_DR register (I2C_SendData()).
    750            *                       - ADDR (Address sent) is cleared by software sequence:
    751            *                         a read operation to I2C_SR1 register
    752            *                         (I2C_GetFlagStatus()) followed by a read operation to
    753            *                         I2C_SR3 register ((void)(I2C->SR3)).
    754            *                       - SB (Start Bit) is cleared software sequence: a read
    755            *                         operation to I2C_SR1 register (I2C_GetFlagStatus())
    756            *                         followed by a write operation to I2C_DR register
    757            *                         (I2C_SendData()).
    758            * @retval None
    759            */

   \                                 In section .far_func.text, align 1
    760          void I2C_ClearFlag(I2C_Flag_TypeDef I2C_FLAG)
    761          {
   \                     I2C_ClearFlag:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    762            uint16_t flagpos = 0;
    763            /* Check the parameters */
    764            assert_param(IS_I2C_CLEAR_FLAG_OK(I2C_FLAG));
   \   000006 02                    RLWA      X, A
   \   000007 A4FD                  AND       A, #0xfd
   \   000009 02                    RLWA      X, A
   \   00000A 4F                    CLR       A
   \   00000B 02                    RLWA      X, A
   \   00000C 5D                    TNZW      X
   \   00000D 2604                  JRNE      L:??I2C_ClearFlag_0
   \   00000F BE00                  LDW       X, S:?w4
   \   000011 2607                  JRNE      L:??CrossCallReturnLabel_20
   \                     ??I2C_ClearFlag_0:
   \   000013 AE02FC                LDW       X, #0x2fc
   \   000016 8D000000              CALLF     ?Subroutine0
    765          
    766            /* Get the I2C flag position */
    767            flagpos = (uint16_t)I2C_FLAG & FLAG_Mask;
    768            /* Clear the selected I2C flag */
    769            I2C->SR2 = (uint8_t)((uint16_t)(~flagpos));
   \                     ??CrossCallReturnLabel_20:
   \   00001A B600                  LD        A, S:?b9
   \   00001C 43                    CPL       A
   \   00001D C75218                LD        L:0x5218, A
    770          }
   \   000020 AC000000              JPF       L:?epilogue_w4
    771          
    772          /**
    773            * @brief  Checks whether the specified I2C interrupt has occurred or not.
    774            * @param  I2C_ITPendingBit: specifies the interrupt source to check.
    775            *            This parameter can be one of the following values:
    776            *               - I2C_ITPENDINGBIT_WAKEUPFROMHALT: Wakeup from Halt
    777            *               - I2C_ITPENDINGBIT_OVERRUNUNDERRUN: Overrun/Underrun flag (Slave mode)
    778            *               - I2C_ITPENDINGBIT_ACKNOWLEDGEFAILURE: Acknowledge failure flag
    779            *               - I2C_ITPENDINGBIT_ARBITRATIONLOSS: Arbitration lost flag (Master mode)
    780            *               - I2C_ITPENDINGBIT_BUSERROR: Bus error flag
    781            *               - I2C_ITPENDINGBIT_TXEMPTY: Data register empty flag (Transmitter)
    782            *               - I2C_ITPENDINGBIT_RXNOTEMPTY: Data register not empty (Receiver) flag
    783            *               - I2C_ITPENDINGBIT_STOPDETECTION: Stop detection flag (Slave mode)
    784            *               - I2C_ITPENDINGBIT_HEADERSENT: 10-bit header sent flag (Master mode)
    785            *               - I2C_ITPENDINGBIT_TRANSFERFINISHED: Byte transfer finished flag
    786            *               - I2C_ITPENDINGBIT_ADDRESSSENTMATCHED: Address sent flag (Master mode) ADSL
    787            *                              Address matched flag (Slave mode)ENDAD
    788            *               - I2C_ITPENDINGBIT_STARTDETECTION: Start bit flag (Master mode)
    789            * @retval The new state of I2C_ITPendingBit
    790            *   This parameter can be any of the @ref ITStatus enumeration.
    791            */

   \                                 In section .far_func.text, align 1
    792          ITStatus I2C_GetITStatus(I2C_ITPendingBit_TypeDef I2C_ITPendingBit)
    793          {
   \                     I2C_GetITStatus:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 5201                  SUB       SP, #0x1
   \   000006 BF00                  LDW       S:?w4, X
    794            ITStatus bitstatus = RESET;
    795            __IO uint8_t enablestatus = 0;
   \   000008 4F                    CLR       A
   \   000009 6B01                  LD        (0x1,SP), A
    796            uint16_t tempregister = 0;
    797          
    798              /* Check the parameters */
    799              assert_param(IS_I2C_ITPENDINGBIT_OK(I2C_ITPendingBit));
   \   00000B A31680                CPW       X, #0x1680
   \   00000E 273E                  JREQ      L:??CrossCallReturnLabel_21
   \   000010 A31640                CPW       X, #0x1640
   \   000013 2739                  JREQ      L:??CrossCallReturnLabel_21
   \   000015 A31210                CPW       X, #0x1210
   \   000018 2734                  JREQ      L:??CrossCallReturnLabel_21
   \   00001A A31208                CPW       X, #0x1208
   \   00001D 272F                  JREQ      L:??CrossCallReturnLabel_21
   \   00001F A31204                CPW       X, #0x1204
   \   000022 272A                  JREQ      L:??CrossCallReturnLabel_21
   \   000024 A31202                CPW       X, #0x1202
   \   000027 2725                  JREQ      L:??CrossCallReturnLabel_21
   \   000029 A31201                CPW       X, #0x1201
   \   00002C 2720                  JREQ      L:??CrossCallReturnLabel_21
   \   00002E A32220                CPW       X, #0x2220
   \   000031 271B                  JREQ      L:??CrossCallReturnLabel_21
   \   000033 A32108                CPW       X, #0x2108
   \   000036 2716                  JREQ      L:??CrossCallReturnLabel_21
   \   000038 A32104                CPW       X, #0x2104
   \   00003B 2711                  JREQ      L:??CrossCallReturnLabel_21
   \   00003D A32102                CPW       X, #0x2102
   \   000040 270C                  JREQ      L:??CrossCallReturnLabel_21
   \   000042 A32101                CPW       X, #0x2101
   \   000045 2707                  JREQ      L:??CrossCallReturnLabel_21
   \   000047 AE031F                LDW       X, #0x31f
   \   00004A 8D000000              CALLF     ?Subroutine0
    800          
    801            tempregister = (uint8_t)( ((uint16_t)((uint16_t)I2C_ITPendingBit & ITEN_Mask)) >> 8);
    802          
    803            /* Check if the interrupt source is enabled or not */
    804            enablestatus = (uint8_t)(I2C->ITR & ( uint8_t)tempregister);
   \                     ??CrossCallReturnLabel_21:
   \   00004E BE00                  LDW       X, S:?w4
   \   000050 4F                    CLR       A
   \   000051 01                    RRWA      X, A
   \   000052 9F                    LD        A, XL
   \   000053 C4521A                AND       A, L:0x521a
   \   000056 A407                  AND       A, #0x7
   \   000058 6B01                  LD        (0x1,SP), A
    805          
    806            if ((uint16_t)((uint16_t)I2C_ITPendingBit & REGISTER_Mask) == REGISTER_SR1_Index)
    807            {
    808              /* Check the status of the specified I2C flag */
    809              if (((I2C->SR1 & (uint8_t)I2C_ITPendingBit) != RESET) && enablestatus)
    810              {
    811                /* I2C_IT is set */
    812                bitstatus = SET;
    813              }
    814              else
    815              {
    816                /* I2C_IT is reset */
    817                bitstatus = RESET;
    818              }
    819            }
    820            else
    821            {
    822              /* Check the status of the specified I2C flag */
    823              if (((I2C->SR2 & (uint8_t)I2C_ITPendingBit) != RESET) && enablestatus)
   \   00005A B600                  LD        A, S:?b9
   \   00005C C55218                BCP       A, L:0x5218
   \   00005F 2708                  JREQ      L:??I2C_GetITStatus_0
   \   000061 0D01                  TNZ       (0x1,SP)
   \   000063 2704                  JREQ      L:??I2C_GetITStatus_0
    824              {
    825                /* I2C_IT is set */
    826                bitstatus = SET;
   \   000065 A601                  LD        A, #0x1
   \   000067 2001                  JRA       L:??I2C_GetITStatus_1
    827              }
    828              else
    829              {
    830                /* I2C_IT is reset */
    831                bitstatus = RESET;
   \                     ??I2C_GetITStatus_0:
   \   000069 4F                    CLR       A
    832              }
    833            }
    834            /* Return the I2C_IT status */
    835            return  bitstatus;
   \                     ??I2C_GetITStatus_1:
   \   00006A 5B01                  ADD       SP, #0x1
   \   00006C AC000000              JPF       L:?epilogue_w4
    836          
    837          }
    838          
    839          /**
    840            * @brief  Clear IT pending bit
    841            * @param  I2C_IT: specifies the interrupt pending bit to clear.
    842            *            This parameter can be any combination of the following values:
    843            *                 - I2C_ITPENDINGBIT_WAKEUPFROMHALT: Wakeup from Halt
    844            *                 - I2C_ITPENDINGBIT_OVERRUNUNDERRUN: Overrun/Underrun interrupt (Slave mode)
    845            *                 - I2C_ITPENDINGBIT_ACKNOWLEDGEFAILURE: Acknowledge failure interrupt
    846            *                 - I2C_ITPENDINGBIT_ARBITRATIONLOSS: Arbitration lost interrupt (Master mode)
    847            *                 - I2C_ITPENDINGBIT_BUSERROR: Bus error interrupt
    848            *
    849            *             Notes:
    850            *                  - STOPF (STOP detection) is cleared by software
    851            *                    sequence: a read operation to I2C_SR1 register
    852            *                    (I2C_GetITStatus()) followed by a write operation to
    853            *                    I2C_CR2 register (I2C_AcknowledgeConfig() to configure
    854            *                    the I2C peripheral Acknowledge).
    855            *                  - ADD10 (10-bit header sent) is cleared by software
    856            *                    sequence: a read operation to I2C_SR1
    857            *                    (I2C_GetITStatus()) followed by writing the second
    858            *                    byte of the address in I2C_DR register.
    859            *                  - BTF (Byte Transfer Finished) is cleared by software
    860            *                    sequence: a read operation to I2C_SR1 register
    861            *                    (I2C_GetITStatus()) followed by a read/write to
    862            *                    I2C_DR register (I2C_SendData()).
    863            *                  - ADDR (Address sent) is cleared by software sequence:
    864            *                    a read operation to I2C_SR1 register (I2C_GetITStatus())
    865            *                    followed by a read operation to I2C_SR3 register
    866            *                    ((void)(I2C->SR3)).
    867            *                  - SB (Start Bit) is cleared by software sequence: a
    868            *                    read operation to I2C_SR1 register (I2C_GetITStatus())
    869            *                    followed by a write operation to I2C_DR register
    870            *                    (I2C_SendData()).
    871            * @retval None
    872            */

   \                                 In section .far_func.text, align 1
    873          void I2C_ClearITPendingBit(I2C_ITPendingBit_TypeDef I2C_ITPendingBit)
    874          {
   \                     I2C_ClearITPendingBit:
   \   000000 8D000000              CALLF     L:?push_w4
   \   000004 BF00                  LDW       S:?w4, X
    875            uint16_t flagpos = 0;
    876          
    877            /* Check the parameters */
    878            assert_param(IS_I2C_CLEAR_ITPENDINGBIT_OK(I2C_ITPendingBit));
   \   000006 A32220                CPW       X, #0x2220
   \   000009 271B                  JREQ      L:??CrossCallReturnLabel_22
   \   00000B A32108                CPW       X, #0x2108
   \   00000E 2716                  JREQ      L:??CrossCallReturnLabel_22
   \   000010 A32104                CPW       X, #0x2104
   \   000013 2711                  JREQ      L:??CrossCallReturnLabel_22
   \   000015 A32102                CPW       X, #0x2102
   \   000018 270C                  JREQ      L:??CrossCallReturnLabel_22
   \   00001A A32101                CPW       X, #0x2101
   \   00001D 2707                  JREQ      L:??CrossCallReturnLabel_22
   \   00001F AE036E                LDW       X, #0x36e
   \   000022 8D000000              CALLF     ?Subroutine0
    879          
    880            /* Get the I2C flag position */
    881            flagpos = (uint16_t)I2C_ITPendingBit & FLAG_Mask;
    882          
    883            /* Clear the selected I2C flag */
    884            I2C->SR2 = (uint8_t)((uint16_t)~flagpos);
   \                     ??CrossCallReturnLabel_22:
   \   000026 B600                  LD        A, S:?b9
   \   000028 43                    CPL       A
   \   000029 C75218                LD        L:0x5218, A
    885          }
   \   00002C AC000000              JPF       L:?epilogue_w4

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\Documents and Sett...">`:
   \   000000 433A5C446F63          DC8 43H, 3AH, 5CH, 44H, 6FH, 63H, 75H, 6DH
   \   000008 656E74732061          DC8 65H, 6EH, 74H, 73H, 20H, 61H, 6EH, 64H
   \   000010 205365747469          DC8 20H, 53H, 65H, 74H, 74H, 69H, 6EH, 67H
   \   000018 735C41646D69          DC8 73H, 5CH, 41H, 64H, 6DH, 69H, 6EH, 69H
   \   000020 73747261746F          DC8 73H, 74H, 72H, 61H, 74H, 6FH, 72H, 5CH
   \   000028 4465736B746F          DC8 44H, 65H, 73H, 6BH, 74H, 6FH, 70H, 5CH
   \   000030 73746D387331          DC8 73H, 74H, 6DH, 38H, 73H, 31H, 30H, 35H
   \   000038 6B2D636F6E74          DC8 6BH, 2DH, 63H, 6FH, 6EH, 74H, 72H, 6FH
   \   000040 6C6C65725C4C          DC8 6CH, 6CH, 65H, 72H, 5CH, 4CH, 69H, 62H
   \   000048 726172696573          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \   000050 544D38535F53          DC8 54H, 4DH, 38H, 53H, 5FH, 53H, 74H, 64H
   \   000058 506572697068          DC8 50H, 65H, 72H, 69H, 70H, 68H, 5FH, 44H
   \   000060 72697665725C          DC8 72H, 69H, 76H, 65H, 72H, 5CH, 73H, 72H
   \   000068 635C73746D38          DC8 63H, 5CH, 73H, 74H, 6DH, 38H, 73H, 5FH
   \   000070 6932632E6300          DC8 69H, 32H, 63H, 2EH, 63H, 0
    886          
    887          /**
    888            * @}
    889            */
    890          
    891          /**
    892            * @}
    893            */
    894          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                          Bytes
     --------------                          -----
     I2C_DeInit                                37
     ?Subroutine0                              12
     I2C_Init                                 365
     ?Subroutine1                              18
     ?Subroutine2                              12
     I2C_Cmd                                   24
     I2C_GeneralCallCmd                        24
     I2C_GenerateSTART                         24
     I2C_GenerateSTOP                          24
     I2C_SoftwareResetCmd                      24
     I2C_StretchClockCmd                       24
     I2C_AcknowledgeConfig                     52
     I2C_ITConfig                              82
     I2C_FastModeDutyCycleConfig               24
     I2C_ReceiveData                            4
     I2C_Send7bitAddress                       50
     I2C_SendData                               4
     I2C_CheckEvent                           166
     I2C_GetLastEvent                          42
     I2C_GetFlagStatus                        147
     I2C_ClearFlag                             36
     I2C_GetITStatus                          112
     I2C_ClearITPendingBit                     48
     ?<Constant "C:\\Documents and Sett...">  118

 
 1 355 bytes in section .far_func.text
   118 bytes in section .near.rodata
 
 1 355 bytes of CODE  memory
   118 bytes of CONST memory

Errors: none
Warnings: none
